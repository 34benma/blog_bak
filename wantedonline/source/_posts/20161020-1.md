---
title: '多线程带来的线程安全和线程通信问题'
date: 2016-10-20 17:29:07
tags: 
 - 并发
 - 多线程通信
 - 线程安全
categories: 深入理解
---
前文多次说过，多线程会带来线程安全问题以及线程与线程之间需要进行通信。在本文中，我想说说我理解的线程安全以及线程通信问题。当然，依然保持我博客的特点，很多东
西仅仅点到为止，不做非常深入的分析。原因在于我自认为我离专家还有一定的距离，因此对于这些知识不敢以专家自居。仅仅分享我的理解，起到一个提纲挈领的作用。读者如
果想要就某个点深入下去，还是需要一定的时间钻研的。 

<!--more-->

<h2>临界区</h2>

只要是涉及到多线程，就一定涉及到临界区。前文说过，线程与进程的重要区别是线程共享临界区。临界区就是多个线程共享的一块内存。可以这样说，线程安全和线程通信的基础就是临界区。因此，只要是多线程编程，一定要时刻考虑临界区的数据变化。

<h2>线程安全的本质</h2>

在《Java并发编程实战》这本著作中对线程安全的定义大概是这样的(大概意思，非原文)，多线程的数据表现和单线程的数据表现是一样的话我们认为这个是线程安全的。我认为线程安全有这么几种情况。

<h3>1 指令线程安全</h3>

指令线程安全这个术语是本人原创(如有雷同，纯属意外)。对于**a++**类似的语句，我们都知道，JVM会编译成三条指令。因此如果在多线程环境下，因为线程上下文切换等就可能造成线程安全问题最终导致数据不一致。这种情况的办法一般只有使用原子锁或一些线程安全机制了(比如CAS)。指令线程安全还有一种情况是指令的重排序。

**重排序**

重排序是指CPU或者操作系统或者编译器在考虑性能的情况下对某些彼此关系不是很大的指令进行了优化和调整执行顺序。这里需要说明的是如果两条指令有非常明显的逻辑顺序，颠倒的话会影响语义的话是不会进行重排序的。重排序有三个层次，分别是CPU基本的重排序，操作系统执行时的重排序以及Java编译器的重排序。如果不考虑原子性或者可见性，在多线程环境下因为指令重排序是会导致线程安全问题的。因此针对这些，Java才定义了一个JMM(Java Memory Model Java内存模型)。关于JMM，这里不再展开，后面相关专题再涉及。

<h3>2 共享数据线程安全</h3>

所谓共享数据是指临界区的数据。在多线程环境下，这些数据事实上是暴露给各个线程的。各个线程都有权对其进行操作。因此这里自然就产生了线程安全问题。同样，共享数据只能通过加锁或者私有化(著名的ThreadLocal可以理解为干这事)或者直接让其不可变(final,权限控制)来实现线程安全，有句话说最好的线程安全就是让其不可变。

<h2>线程通信的本质</h2>

在保证线程安全的情况下，多线程之间需要进行通信的。这里的通信不是指发消息这种通信。我们可以把线程通信理解为多线程之间线程之间的协调。而协调的一些机制就是通过发送指令或者一种消息给JVM或操作系统来实现协调的。

<h3>线程通信的手段</h3>

Java里实现线程通信的方法有很多。最常见的有Object类的wait和notify系列。Thread里的sleep和Join等。同时在J.U.C里，提供了很多方式来实现线程通信，比如闭锁(CountDownLatch)，栅栏(CyclicBarrier)，条件类(Condition)等。同时，线程还提供了中断机制等，我们自己也可以控制一个线程的执行。需要说明的是因为消息安全(比如丢失消息)问题导致的死锁等，JDK已经废弃了Thread的stop等方法。

<h2>总结</h2>

本文从大逻辑点到了多线程带来的线程安全问题和线程之间通信的方法。很多东西如果研究下去又可以单独写一篇文章了。在后面会对一些比较重要的地方再做说明。

