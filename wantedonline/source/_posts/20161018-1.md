---
title: Java并发编程的基本手段
date: 2016-10-18 23:25:18
tags: 
 - 并发编程
 - 并发
 - 线程
categories: 深入理解
---

实现并发的一个关键或者说核心手段就是使用多线程。线程就是轻量级的进程。它和进程的区别在于是否共享临界区或者说共享数据内存。我们一般把可以分解的任务使用多线程来实现。所谓可以分解的任务就是可以并行化的任务。比如从1加到100，我们可以先两两相加，求得的和再两两相加。这里两两相加都一样的，只是输入的加数不一样而已，显然是可以并行化的。本文将介绍Java中实现并发的几种方法以及两个重要的关键字的用法。

<!--more-->

<h2>继承Thread类</h2>

初学Java的人学到多线程介绍的方法一定是继承**Thread**类，然后覆写其中的**run**方法。启动线程的时候再调用该Thread类的start方法。

但是Java只支持单继承，如果要既要实现线程，又要继承其他类的话就需要使用接口了。因此才有了**Runnable**接口。

<h2>实现Runnable接口</h2>

所谓接口，就是一个约定，一个规范。Runnable接口约定了我们如果要抽象出一个任务来实现多线程，只要实现run方法接口。然后把这个Runnable子类放到Thread作为参数去调用即可。

查看Thread源码或Runnable的run方法签名即可知道，这两种方式执行完都是没有返回值的。假如我们有一个任务需要将返回值返回出来怎么办？一种方式是通过传参，并且这个参数是引用参数。但是这种方式有点C语言味道。在Java里，更加直观的方式显然是通过返回值。怎么办呢？

<h2>实现Callable接口</h2>

在J.U.C(java.util.concurrent)包里，从J.D.K 1.5开始就提供了一个叫做**Callable**接口的类。这个接口有一个方法叫做**call**，在使用前需要指定返回值V，该方法就可以返回一个V类型的对象。

除了有返回值，这个接口和**Runnable**接口的功能一模一样。但是用法稍微有些不同。显然，不能像Runnable一样放到Thread里。这个接口是J.U.C提供的，自然在J.U.C里有相应的类来执行Callable子类。

这就是Executors框架。

Executors框架最常见的功能就是提供了4中类型的线程池。抽象线程池(AbstractExecutorService)提供了一个submit方法和newTaskFor方法。submit方法就是将一个Callable类作为参数提交到线程池，当线程池执行完之后会返回一个Future对象将返回值带出来。newTaskFor是一个装饰器方法，返回一个RunableFuture对象，这个对象就是一个包装的任务。可以用于线程池的工作窃取队列等地方。详细的线程池以及使用在后面用单独的文章来说明。

<h2>线程的本质</h2>

关于线程的形象描述。我只服这篇[文章](https://segmentfault.com/a/1190000004694556)。

这里阐述线程的本质，我打算从Java中Thread类的源码角度来阐述。

首先，看看javadoc关于线程的一些描述。

{% cq %}A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently. {% endcq %}

从这里我们可以看出，Java中的线程是虚拟机层面的线程。是由虚拟机来保证并发的。那么它和操作系统层面提供的线程是否是一一对应？这点我没有看过JVM的源码，因此无法说出准确答案。但是从Thread源码来看,虚拟机的线程和操作系统是有关系的。因为在Thread类中引用了一些native方法，只是这些native方法源码以及实现我目前还无法得知。

``` 
private static native void registerNatives(); 
```

一个线程的一些基本属性有优先级，线程名(可以不指定)等。这些属性在初始化一个线程的时候，可以通过构造函数来设置。


<h3>线程的一些基本概念</h3>


<h4>1 守护线程</h4>

所谓守护线程是指一些优先级比较低(通常情况下),在后台执行的一些线程。比如我们的程序入口main函数所在的线程，JVM的垃圾回收线程等。守护线程的特点就是它要等其他所有非守护线程执行完成，JVM虚拟机打算退出的时候它在结束运行。守护线程的作用就是用于一些后台执行的任务，一般来说，他们的优先级不是很高。不然其他普通线程都没有时间片去执行了。

<h4>2 线程组</h4>

ThreadGroup就是将一些功能相近的线程或者有父子关系的线程放到一个集合里。这个集合就是ThreadGroup，它内部就是一个数组。同时也可以将ThreadGroup放进去。这样相互联系的一些线程之间的拓扑关系就可以表达出来。使用线程组的好处是我们可以一次设置一组线程的属性，比如优先级，名字，是否是守护线程等。同时还可以一次控制一组线程(线程组的暂停唤醒方法因为安全问题已经不建议使用了)。

<h4>3 线程优先级</h4>

这个概念应该很好理解。Java里将线程优先级定义为 1-10，同时定义了三个常量：

```
public final static int MIN_PRIORITY = 1;

public final static int NORM_PRIORITY = 5;

public final static int MAX_PRIORITY = 10;

```

一般我们就用这三种级别来设定线程优先级即可。优先级越高，就越优先执行。

<h3>线程的生命周期</h3>

前面说过，启动一个线程调用Thread的start方法。线程从启动开始到线程执行完毕被操作系统回收，是有一系列的生命周期状态转换的。在Java里，这些状态定义在Thread内部的一个枚举State里。这5个状态分别是	NEW,RUNNABLE,BLOCKED,WAITTING,TIMED_WAITING。关于状态的互相转换以及如何观察线程状态可以另开一篇文章来说明了。这里不再详述，总之和操作系统课上关于进程的状态转换有一点点类似。

<h3>线程的通信</h3>

线程最重要的一个话题就是线程之间的通信。因为线程之间彼此共享内存，因此必然存在一些线程安全问题和线程通信问题。线程中的wait,join,notify,sleep等方法都是为线程通信而产生的。具体作用可以在文档以及后续博文中找到。

<h3>static,final等对线程安全的意义</h3>

关于static，final这两个关键字的一些用法是每个资深Javaer必须掌握的。static对于线程安全的意义更多的体现在修饰一个变量上。当一个变量是static变量时意味着这个变量是个类变量，被全部线程所共享。因此必然存在线程安全问题。而final修饰一个变量则是不可变的意思。修饰引用指引用关系不可变。因此，在多线程里，可以使用static和final来实现依一些数据共享和线程安全的问题。

<h3>总结展望</h3>

本文很简单的介绍了Java中实现并发的几种方式。同时概括性地点到了线程的一些基本概念和线程通信和安全问题。要说清楚这些问题不是这么一篇文章能够说清楚的。这里我感到自己语言总结和学识的精通程度还没有达到专家水准。因此有些问题尽管我知道在生产实践中应该怎么用以及会出现什么问题，但是要介绍给读者却有些困难。希望后面有时间能够详细阐释清楚每一个问题。


[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)
