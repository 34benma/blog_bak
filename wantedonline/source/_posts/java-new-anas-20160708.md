---
title: Java中当我们new一个对象时我们是在干啥？
date: 2016-07-08 17:48:56
tags:
  - JVM
  - 类加载机制
categories: 深入理解
---
{% centerquote %}Java程序员不需要女票，因为他们每天都在面向对象...{% endcenterquote %}

Java是一门面向对象的语言。如果不借助于Spring等这类IoC容器，我们在获得一个对象实例的时候通常都是用new这个关键字了（当然还可以用反射）。相比每一个Javaer都知道这个关键字是做什么用的。当我们使用它new一个新对象实例时，JVM到底为我们做了啥？

<!--more-->

当我们写完一个xxx.java源文件后，java编译器会帮我们生成xxx.class文件。这个文件就是虚拟机的输入。如果这个class文件代表一个普通的对象，当我们new的时候事实上就是初始化这个xxx.class文件。因此一句话概括当我们new一个对象的时候就是初始化一个对象实例。

对于程序员，一个new就可以获得一个对象实例，但是对于Java虚拟机来说，前前后后做了大量的工作。本文将简单分析一下Java虚拟机的类装载机制。

<h2>Java虚拟机的类装载过程</h2>

![类的生命周期](http://o9z6i1a1s.bkt.clouddn.com/life_of_a_class.png)

当我们写完一个Java源文件编译成一个.class文件的时候，如果加载进JVM，就要经历一个上图所示的生命周期。当虚拟机遇到一条new指令的时候，首先去常量池定位这个类的符号引用，如果这个类已经被加载，解析和初始化了，则直接使用(比如单例对象)。否则，就执行上述过程。当一个类对象之前已经实例化过了，再次生成一个新对象时只需要初始化了。

<h3>类的加载</h3>

类的加载是通过类加载器(ClassLoader)来完成。类加载器通过一个类的全限定名来获取这个类的二进制流，也就是那个.class文件流，将一些类的静态信息(字段，方法名，常量等)放到方法区，生成这个类的Class对象。事实上，虚拟机并不一定要求这个class文件必须在本地，也没有要求必须是java语言编写的(Groovy等也可以)。这个类可以来源于网络，也可以来源于数据库，甚至我们还可以手动写一个符合规范的class文件(CGlib)。当把这个class文件加载进虚拟机就完成了类加载的过程。

<h3>验证阶段</h3>

因为class文件可以通过各种途径获取，还可以不使用java语言来编写，在类加载的过程中怎么保证加载的class文件是合符规范并且不会在运行过程中引起JVM宕机呢？这就需要一个验证阶段。验证阶段完成了class文件格式的验证(比如魔数，版本号等)，元数据的验证(类的继承合法性)，字节码验证，符号引用验证等。当一个class文件完全通过JVM检验合格之后就可以进入准备阶段了。

<h3>准备阶段</h3>

准备阶段做的事情很简单。就是为这个类的一些类变量(static)在方法区分配内存但没有初始化(初始化都是在初始化阶段完成)。但是常量字段除外（static final）。这些字段在这个阶段已经赋值并且放入方法区的常量池了。

<h3>解析阶段</h3>

类的解析是虚拟机做的最复杂的一项工作。它会将一些符号引用(虚地址)替换为直接引用(实际地址)，完成类的继承关系的解析，完成字段和方法的解析。还会进行各种权限的验证。当一个类的各种符号引用被替换为了直接引用。它的各种父类，接口，字段，方法完成了解析。这个类就可以进入初始化阶段了。

<h3>初始化阶段</h3>

类的初始化阶段简单的说就是执行一个< init>方法。这个方法是Java虚拟机帮我们生成的。是在构造函数执行(构造函数是程序员主动调用的)前由java虚拟机调用执行。目的在于完成类实例各个变量的初始化赋值，静态代码块的执行等。当然，如果一个类没有静态代码块，也没有变量赋值，那么这个< init>方法什么也不用干了。我们可以写一个类，它什么也不干，然后反编译看下如果加载这个类虚拟机将执行哪些指令。

    class TestObject {
   
    }

javap一下，可以看到以下输出：

![Class反汇编](http://o9z6i1a1s.bkt.clouddn.com/init_class.png)

这个类啥事也不干，因此如果虚拟机加载这个类，还是会调用<init>方法，但是这个方法事实上啥事也没有干。

这个时候，调用new将生产一个对象实例，这个实例的内存占用是在Java堆上。这里有一个问题，假如我们有个线程A在堆内存地址为0x123的地方实例化一个对象，但是还没有实例化完成，这时线程B也想在堆内存地址为0x123的地方实例化一个对象，会不会把线程A还没有实例化完成的对象信息给抹掉？

<h3>如何保证线程安全的类初始化</h3>

一种很简单的办法是同步化。虚拟机可以采用CAS操作(在并发系列中将讲到CAS操作)来保证原子化，还有一种方式是将分配对象堆内存的工作按照线程划分在不同的线程空间中进行。这个线程空间的名字就叫做TLAB(Thread Local Allocation Buffer)。我们看到java虚拟机参数中有一些参数是跟TLAB有关的。

```
	-XX:+UseTLAB //是否开启TLAB，JDK1.4之前是false
```
```
	-XX:TLABWasteTargetPercent //TLAB占整个eden区的百分比
```
```
	-XX:+PrintTLAB //查看TLAB的使用情况
```

当堆内存分配完了，< init>方法也执行完了，一个对象就初始化完成了。这时候就开始执行构造函数，对象就到了程序员手里，可以被程序员使用了。



*参考文献*
*《深入理解Java虚拟机》 --周志明著*
*http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#largepages*

