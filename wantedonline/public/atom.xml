<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术家园</title>
  <subtitle>王诚的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wantedonline.cn/"/>
  <updated>2016-12-09T11:57:44.000Z</updated>
  <id>http://wantedonline.cn/</id>
  
  <author>
    <name>LouisWang</name>
    <email>wantedonline@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我想做一个后端服务器</title>
    <link href="http://wantedonline.cn/2016/12/09/20161209/"/>
    <id>http://wantedonline.cn/2016/12/09/20161209/</id>
    <published>2016-12-09T11:50:45.000Z</published>
    <updated>2016-12-09T11:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>从上一家公司莫名其妙离职后(是的，对于不可言说的事情我都是用莫名其妙，乱七八糟这样的词汇形容~~~)进入新公司，主力还是做后端服务器API开发，这也是我一直感兴趣的方向。目前我们的技术框架主体是Tomcat+Spring+SpringMVC+Redis+MySQL。<br>估计，这也是大多数互联网公司所采用的技术框架。因为开源，好用~</p>
<p>这个技术框架和我上一家(上家技术就是*雷的技术)基本类似，不过服务器和技术架构还是差别挺大。两个关键区别是Netty框架VSTomcat容器，动静分离，前后端分离VS动静结合，前后端结合。结合我在新公司上手项目和上一家上手项目的速度以及软件架构设计和项目运维的实际情况，我萌发了想做一款后端服务器的想法。</p>
<a id="more"></a>
<h2>动静分离,前后端分离</h2>

<p>动静分离指的是Web项目中动态资源和静态资源的分离。所谓动态资源我理解就是逻辑数据。比如说一个游戏排行榜，排行榜的数据是动态更新的，但是排行榜的样式是固定不变的。这些样式是由图片，HTML，JS，CSS等构成。而数据的产生就是服务器的逻辑代码经过逻辑运算最终产生。分离就是要分离这些东西。这里动态数据的产生就需要后端程序员来提供，而HTML，JS，CSS等各种样式，动态展现效果等的实现是前端工程师，重构工程师，UI设计师等共同实现。</p>
<p>因此动静分离带来的结果就是前后端分离。后端工程师只要懂后端，不需要调界面，写JS了。前端工程师只要做效果，和用户交互，不需要考虑数据的来源以及正确性了。</p>
<p>前后端交互则通过HTTP请求，数据表现形式通常是JSON。有的也用XML，但我觉得JSON性能和易用性上明显要高于XML。</p>
<h2>Tomcat可以实现动静分离，前后端分离吗？</h2>

<p>我觉得答案是可以，必须可以。Tomcat是一个非常优秀的Servlet容器。无论从设计上还是代码编写上(曾经深入读过Tomcat大部分源码)都是一个非常优秀的容器(其作者也是Struts的作者，因此设计思想上有些类似，但是Struts现在基本没人用了，Tomcat作为服务器还在被大量使用)。但是Tomcat也仅仅是个Servlet容器。它提供的组件式，可插入式的设计思想非常灵活。</p>
<p>但灵活带来的代价我认为是复杂性。Tomcat的配置还是比较麻烦的。默认的HTTP请求处理模式是BIO，如果使用NIO需要专门的配置。同时，随着项目的体积增大，启动Tomcat和调试程序都变成了一件非常复杂需要很多耐心的事情。因此，从项目入手和项目维护简易上来说，Tomcat做的比较糟糕。</p>
<h2>一切回归main</h2>

<p>main函数是一切程序启动的入口。因为Tomcat帮我们把main函数(在Tomcat的Bootstrap类里)写了。因此我们Web程序的代码实际上都是逻辑代码。一坨我们不需要写入口的代码。Tomcat为什么叫做容器？从这里也可以找到一点点依据。所有类的加载和执行我们都控制不了。如果一个程序需要我们手动来写main函数，给我们的感觉是我们在控制程序的入口，那么我们的逻辑代码就不再是被放到容器中来了。我们的项目也不在需要是一个标准的Java Web项目，而是一个标准的Java项目。因此，回归到main，将更加容易理解并调试项目。</p>
<h2>NIO框架</h2>

<p>NIO框架里两个非常优秀的框架是Netty和Mina。Mina暂时还没研究过。因为工作经历的关系，研究过Netty。Netty作为一个非常优秀的NIO框架让我们编写一个基于NIO的服务器变得非常简单。特别是Netty4在Netty3基础上对线程模型的改进。因此基于Netty4编写一个后端服务器，应该是有非常良好的IO处理性能和并发处理性能。</p>
<h2>我为什么想做一个后端服务器？</h2>

<p>因为种种乱七八糟的原因，上一家自研的服务器框架没有开源出来造福广大后端服务器程序员。因此有上一家公司的工作经历后，加上Tomcat和SpringMVC给程序员以及项目开发速度上带来的问题，我觉得做一个高性能，高可靠的易用的后端服务器是一件非常有意义的事情。基于我对Netty4和上家公司后端服务器框架的理解，加上我自己在项目开发和管理中遇到的一些痛点，我决定写一个后端服务器。</p>
<p>这个服务器原始的需求基本和上一家公司的很类似(不得不赞叹*雷技术实力和前瞻性，这款服务器开发于2010年，有些理念最近才逐渐火起来)。但是，我不会直接引用。最大的区别是Netty版本的区别。我将废弃Netty3，使用Netty4。</p>
<p>它要达到的目标是让动静分离变得极其简单，让后端程序员专注做后端，专注在高性能，可靠性，可拓展性等问题上，前端程序员专注在极好的用户体验和正确的用户数据上。</p>
<p>最重要的是，它要实现项目的极快速开发和高质量，高可靠性。软件开发相关专业的毕业生能够在一周内上手项目并且能写出高质量的逻辑代码。因为框架屏蔽了Spring,SpringMVC，Redis,MySQL等一些部署和使用细节。真正实现后端程序员只要关注BO和DAO，并且设计良好的数据模型即可。</p>
<p>这就是我想做的~目前已经有一个良好的开始。</p>
<p>我把项目名字取名Puppy。可爱的小狗的意思。感兴趣的同学可以<a href="mailto:wantedonline@outlook.com" target="_blank" rel="external">联系我</a>，一起做这个还算有意义的事情。目前我正在做<a href="https://github.com/34benma/Puppy/blob/master/doc/puppy_plan" target="_blank" rel="external">V0.4.0</a></p>
<p>项目地址: <a href="https://github.com/34benma/Puppy" target="_blank" rel="external">https://github.com/34benma/Puppy</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从上一家公司莫名其妙离职后(是的，对于不可言说的事情我都是用莫名其妙，乱七八糟这样的词汇形容~~~)进入新公司，主力还是做后端服务器API开发，这也是我一直感兴趣的方向。目前我们的技术框架主体是Tomcat+Spring+SpringMVC+Redis+MySQL。&lt;br&gt;估计，这也是大多数互联网公司所采用的技术框架。因为开源，好用~&lt;/p&gt;
&lt;p&gt;这个技术框架和我上一家(上家技术就是*雷的技术)基本类似，不过服务器和技术架构还是差别挺大。两个关键区别是Netty框架VSTomcat容器，动静分离，前后端分离VS动静结合，前后端结合。结合我在新公司上手项目和上一家上手项目的速度以及软件架构设计和项目运维的实际情况，我萌发了想做一款后端服务器的想法。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发" scheme="http://wantedonline.cn/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="服务器开发" scheme="http://wantedonline.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="Netty" scheme="http://wantedonline.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>不要随便升级系统</title>
    <link href="http://wantedonline.cn/2016/12/06/20161206/"/>
    <id>http://wantedonline.cn/2016/12/06/20161206/</id>
    <published>2016-12-06T14:04:08.000Z</published>
    <updated>2016-12-09T11:55:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>我总是喜欢用最新稳定版的软件，操作系统也一样。今晚将Mac OS升级到了最新的10.12.1，花费了大约15分钟，没想到的是这次这个所谓的Release版本对开发者似乎不太友好。</p>
<a id="more"></a>
<p>升级之后，发现我的博客工程hexo不能正常使用了。发现原来是node.js自动没了。当时也没有检查是否是path失效了，直接到node.js下载了稳定版本6.2安装了，然后又安装hexo。结果发现现在每次运行hexo命令，将报如下异常。</p>
<p><img src="http://o9z6i1a1s.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-06%2022.04.22.png" alt=""></p>
<p>虽然不影响正常使用，但是作为error零容忍的强迫症患者，总是感觉不舒服。</p>
<p>查了一下，原来是node.js版本太高导致。OMG…. <a href="http://stackoverflow.com/questions/37507140/nodejs-error-module-version-mismatch-expected-48-got-46" target="_blank" rel="external">查询依据</a></p>
<p>想起了以前项目开发环境迁移，升级了MySQL版本，结果导致编码出问题，对于上100G的数据简直是个噩梦。</p>
<p>软件运维还真不是一件容易的事情。新版本的发布需要考虑太多兼容的问题~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我总是喜欢用最新稳定版的软件，操作系统也一样。今晚将Mac OS升级到了最新的10.12.1，花费了大约15分钟，没想到的是这次这个所谓的Release版本对开发者似乎不太友好。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发日常" scheme="http://wantedonline.cn/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="软件日常" scheme="http://wantedonline.cn/tags/%E8%BD%AF%E4%BB%B6%E6%97%A5%E5%B8%B8/"/>
    
      <category term="Hexo异常" scheme="http://wantedonline.cn/tags/Hexo%E5%BC%82%E5%B8%B8/"/>
    
      <category term="系统升级" scheme="http://wantedonline.cn/tags/%E7%B3%BB%E7%BB%9F%E5%8D%87%E7%BA%A7/"/>
    
      <category term="软件运维" scheme="http://wantedonline.cn/tags/%E8%BD%AF%E4%BB%B6%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>镜头下的所思</title>
    <link href="http://wantedonline.cn/2016/11/12/20161112-2/"/>
    <id>http://wantedonline.cn/2016/11/12/20161112-2/</id>
    <published>2016-11-12T10:19:51.000Z</published>
    <updated>2016-11-12T10:21:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015年某个阳光明媚的周末摄于深圳莲花山公园。当时发表在QQ空间，今天偶然发现，这是目前为止我摄影天赋表现得最高的一次了(其实是这之后就没拿起过相机拍过照了。。没时间，没心情)。特地转到个人博客发表。关于照片中水印是’PHOTO TAKED BY JACKWANG’ 中的JackWang就是LouisWang，16年前的英文名。后面在好朋友的建议下改成了LouisWang。</p>
<a id="more"></a>
<p><img src="http://o9z6i1a1s.bkt.clouddn.com/1.jpg" alt="1"><br><img src="http://o9z6i1a1s.bkt.clouddn.com/2.jpg" alt="2"><br><strong>漫漫人生路</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/3.jpg" alt=""><br><strong>有时候，我们根本看不到前方是什么，即便如此，也只能往前，因为别无选择</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/4.jpg" alt=""><br><strong>当选择真正来临的时候，反而会辗转反侧</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/5.jpg" alt=""><br><strong>因为前方的路，总是有些模糊和不安</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/6.jpg" alt=""><br><strong>别急，走下去，总有一天，会慢慢清晰</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/7.jpg" alt=""><br><strong>累了的时候，可以休息一下，既然选择远方，便要风雨兼程</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/8.jpg" alt=""><br><img src="http://o9z6i1a1s.bkt.clouddn.com/9.jpg" alt=""><br><strong>前进的过程中，有可能会碰到志同道合的同伴</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/10.jpg" alt=""><br><strong>也可能是独自一人</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/11.jpg" alt=""><br><strong>但不管怎样，坚持下去，最后都会看到别样的风景</strong><br><strong>只是有时候，我们以为自己是第一个</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/12.jpg" alt=""><br><strong>其实，早就有人比你先登上峰顶</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/13.jpg" alt=""><br><strong>但是，那又怎样？我看到的是我的世界里的风景</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/14.jpg" alt=""><br><strong>在前进的道路上，有时需要指引，才不至于迷失自己</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/15.jpg" alt=""><br><strong>有的指引，就是一盏路灯，照亮了前进的道路</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/16.jpg" alt=""><br><strong>瞬间，前面的路变得宽敞又明亮</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/17.jpg" alt=""><br><strong>你站在桥上看风景，看风景的人在楼上看你</strong><br><strong>羡慕别人的时候，殊不知自己也被人羡慕</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/18.jpg" alt=""><br><strong>有时，我们会遇到这样的人</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/19.jpg" alt=""><br><strong>有时，不能相信自己的眼睛</strong><br><strong>因为，有时自己都不知道谁应该被帮助</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/20.jpg" alt=""><br><strong>坚持走下去，人生，就是一个自我完善的过程……</strong><br>————华丽的分割——————<br><img src="http://o9z6i1a1s.bkt.clouddn.com/21.jpg" alt=""><br><strong>再见，小时候</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/22.jpg" alt=""><br><strong>别总是工作，不要辜负阳光和青草</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/23.jpg" alt=""><br><strong>年轻，真好。青春，真好！</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/24.jpg" alt=""><br><strong>噢，你到底爱不爱我~</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/25.jpg" alt=""><br><img src="http://o9z6i1a1s.bkt.clouddn.com/26.jpg" alt=""><br><img src="http://o9z6i1a1s.bkt.clouddn.com/27.jpg" alt=""><br><strong>人生，最满足的事情莫过于和好哥们一起，把兴趣当成谋生</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/28.jpg" alt=""><br><strong>幼有所养，老有所依</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/29.jpg" alt=""><br><img src="http://o9z6i1a1s.bkt.clouddn.com/30.jpg" alt=""><br><strong>无论我们飘多远，总有一条线拉着</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/31.jpg" alt=""><br><img src="http://o9z6i1a1s.bkt.clouddn.com/32.jpg" alt=""><br><strong>有故事有意思的大爷，他说，我喜欢满世界拉琴~~~</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015年某个阳光明媚的周末摄于深圳莲花山公园。当时发表在QQ空间，今天偶然发现，这是目前为止我摄影天赋表现得最高的一次了(其实是这之后就没拿起过相机拍过照了。。没时间，没心情)。特地转到个人博客发表。关于照片中水印是’PHOTO TAKED BY JACKWANG’ 中的JackWang就是LouisWang，16年前的英文名。后面在好朋友的建议下改成了LouisWang。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="摄影" scheme="http://wantedonline.cn/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="人生思考" scheme="http://wantedonline.cn/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C概述</title>
    <link href="http://wantedonline.cn/2016/11/12/20161112/"/>
    <id>http://wantedonline.cn/2016/11/12/20161112/</id>
    <published>2016-11-12T09:04:22.000Z</published>
    <updated>2016-11-12T09:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇基本说的是并发理论性的东西。除了很简单的介绍了一下synchonized和volatile两个关键字。从本篇开始，还是继续介绍一些理论性的东西。不过这些理论上的东西不同于前面。而是实实在在的工具类。</p>
<p>J.U.C是java.util.concurrent.*的简写。从JDK 1.5开始，JDK开始提供了一个专门用于简化并发编程的工具包，这个工具包就是J.U.C。</p>
<a id="more"></a>
<p>业界有一句话说’并发不知<a href="http://g.oswego.edu" target="_blank" rel="external">Doug Lea</a>，学尽Java也枉然’。事实上，J.U.C的整个设计以及中间很多类的编写都是Doug Lea。上面链接是他的主页。他还编写了一本书叫做<java并发编程实践>.这本书对于Java程序员研究并发编程的理论与实践绝对帮助很大。</java并发编程实践></p>
<h2>Executors类</h2>

<p>这个包主要提供了一些线程池的工具类。事实上，创建线程和销毁线程都是一些消耗比较大的操作。因此J.U.C提供了这样一些类来简化线程的创建和销毁以及管理。主要有这么四中线程池：newCachedThreadPool，可缓存的线程池。它的用法是当我们希望创建的线程使用完之后不要马上销毁，可以给下一个任务去使用。因此可以将这些线程缓存起来重用。这样就节省了线程频繁创建于销毁带来的开支；newFixedThreadPool，固定大小的线程池。如果我们的任务数固定，而且可以确定线程数量使用这种线程池就比较好。不会有资源的浪费；newScheduledThreadPool，可调度的线程池。有一些任务我们希望在某个时间点或者某种频率触发，就可以使用这种线程池；newSingleThreadExecutor,单个线程的线程池。这种线程池一般用于任务数比较少，可以固定一个线程来执行。生产实践中我个人还是很少用到。</p>
<p>跟线程池相关的自然是任务。J.U.C简化了我们创建和销毁以及管理线程的步骤，我们要做的只是将可以并行化的部分抽象出任务，写好task类即可。而task又可以带返回值和不带返回值。这些是通过Future等类实现。同时，在这个Executors框架里还提供了ForkJoin机制的实现类，用于工作窃取机制算法的实现。关于这个算法的原理，可以参考这个<a href="http://ifeve.com/fork-join-1/" target="_blank" rel="external">文档</a>。涉及到线程池，涉及到任务，自然就会牵扯到很多东西，比如任务队列，优先级，启动和中断等。这些都定义在Executors这个框架里。</p>
<h2>并发集合类</h2>

<p>J.U.C提供了非常丰富的线程安全的集合类。比如队列，Map,List等数据结构。其中生产实践中用的最多的恐怕是ConcurrentHashMap了。这个类型的Map的详细介绍后面会有。它是一个线程安全的HashMap，但是性能比直接用HashTable或者同步化包装的HashMap高很多。原因需要看这个类的实现才能理解。根据不同的适用场景，提供了非常丰富的集合类供程序员适用。</p>
<h2>原子信号量工具类</h2>

<p>锁，信号量等在Java代码层面实现了。而且J.U.C提供的Lock类更加灵活，据说性能已经开始超过synchonized等关键字了。同时提供了一些信号量用于实现一些比如流控或者自定义锁等功能。</p>
<h2>原子基本类</h2>

<p>对于int,long，double等一些基本类，提供了一些对应的原子类的实现。这些类的线程安全保证是通过无锁化的CAS操作实现的。详细的后面的文章也会介绍。</p>
<p>同时还有一些比如TimeUnit等工具类。</p>
<h2>总结</h2>

<p>J.U.C给Java程序员实现并发编程带来了极大的便利，因为并发编程本来就是一项比较复杂难以测试的事情，因此虽然J.U.C已经最大程度上简化了程序员的工作，但还是需要程序员对并发编程的理论非常熟悉，经历过很多次实践才能用好并发编程带来性能效率上的提升。</p>
<p><a href="http://wantedonline.cn/2016/09/08/20160908-1/">专题目录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面几篇基本说的是并发理论性的东西。除了很简单的介绍了一下synchonized和volatile两个关键字。从本篇开始，还是继续介绍一些理论性的东西。不过这些理论上的东西不同于前面。而是实实在在的工具类。&lt;/p&gt;
&lt;p&gt;J.U.C是java.util.concurrent.*的简写。从JDK 1.5开始，JDK开始提供了一个专门用于简化并发编程的工具包，这个工具包就是J.U.C。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="J.U.C" scheme="http://wantedonline.cn/tags/J-U-C/"/>
    
  </entry>
  
  <entry>
    <title>软件开发日常思考(二)</title>
    <link href="http://wantedonline.cn/2016/11/08/20161108/"/>
    <id>http://wantedonline.cn/2016/11/08/20161108/</id>
    <published>2016-11-08T14:07:00.000Z</published>
    <updated>2016-11-08T14:09:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续<a href="http://wantedonline.cn/2016/08/20/20160820-1/">上一篇</a>的话题。上一篇谈到了单元测试和团队代码规范问题.事实上到目前为止，我还没有碰到过一个团队对单元测试有过高的要求。我碰到的大部分团队可以说是对单元测试没有要求。这也和目前大部分开发团队碰到的现实情况是相符合的，开发的时间以及团队对代码的质量没有太多的要求。功能为王，实现功能就好，至于可维护性，可读性，可拓展性等等这些问题从来不考虑。这一篇我想谈一谈我对程序员代码质量的思考。</p>
<a id="more"></a>
<p>很感恩和很幸运，我毕业后第一家公司是华为。为什么这么说呢？在大学的时候，我接触的项目和学到的东西，基本都是书上的。读了很多关于代码质量，代码风格以及软件工程理论性的东西。而真正巩固和实践是从工作开始的。入职华为前以及入职后新员工时期，大部分是培训。这里我从华为学到的两个重要的东西就是下面这两点。</p>
<h2>以客户为中心</h2>

<p>所有新员工入职华为大队培训一定有一堂非常重要的课就是讲华为的企业文化–以客户为中心，以奋斗者为本。</p>
<p>作为一个研发人员，我们不可能接触到一线客户。当时我所在的大部门(2012实验室)是一个SBG(Service Business Group)，我们服务的对象是产品线的兄弟。我学到的第一个理念是我们的客户是我们的上一道工序。</p>
<p>严格来说，无论在什么时候，对待任何人以及对待任何事，如果能够真正以客户为中心，也就是以服务好上一道工序为起点，那么很多事情都会有一个比较好的结果。</p>
<p>这个和我想讲的软件开发有什么关系呢？</p>
<p>软件开发是一个团队合作的活动。如果团队比较小，可能一个人就负责一个模块甚至一个项目。如果团队比较大，我们很多时候需要写一些公共接口给其他人用。这时候就有一个沟通和合作的问题。</p>
<p>过去我的经验是，谁写的接口谁负责维护。因此，如果只为了省事图个简单，没有任何接口doc说明也没有约定一个编码规范，很有可能就要出问题。比如说接口返回数据问题。如果返回了错误数据或者空指针等就是接口编写者的问题。而不应该要求使用者去做参数校验来避免踩坑。这一点我认为就是一个客户为中心的问题。</p>
<p>当然，在这一点上，过去的两年多，我一直在努力。我也看到了自己从一个经常犯错误的新手慢慢成长为一个比较少的犯错误的老油条。在这条路上，我还有很多事情可以做。</p>
<h2>代码质量–程序员的尊严</h2>

<p>软件开发是一个非常复杂的团队合作活动。在这项活动里，我比较认同两个东西。</p>
<p>短板理论</p>
<p>项目成功或失败不是一个或两个比较牛掰的人能决定得了的。取决于团队的整体水平以及团队中的短板。如果一个团队有比较好的编码规范以及90%的人都有较强的软件工程思想和编码水平，那么剩下的10%的短板也会跟着团队逐渐成长，最终整个团队的作战能力都能提升上去。开发出来的代码质量一定不会太低。</p>
<p>破窗理论</p>
<p>如果项目从一开始就向坏的方向发展，比如代码混乱，隐藏了很多潜在的安全问题。最后发展到最后一定会越来越坏，最终可能在某个重要的时间点爆发，然后彻底蹦了。因此，从项目一开始就保持一种比较严格的要求我觉得是一个比较好的做法。</p>
<p>这两个东西和主题代码质量的关系。</p>
<p>很多的时候，如果我们不注重这两点，任有项目代码做布朗运动，可能最终导致的结果是很不可控的。也许我们目前的资源以及条件，是功能为主，不要考虑网络资源，内存资源，CPU资源，安全问题等。但是最终当出现问题的时候已经不可控了，只能推到重来了。这就是一个失败的项目。</p>
<p>因此，作为程序员，珍惜每一点内存，即便是一个Java程序员，即便我们有非常足够的内存可使用；珍视每一点性能提升，时间复杂度的下降，空间复杂度的下降；保持一套可读性，可维护性高的代码风格和命名规范是极其重要的。</p>
<p>我们的代码写完之后很有可能是其他人维护，这时候别人的体验就是代码质量的体现，就是程序员尊严的体现，</p>
<h2>总结</h2>

<p>软件开发是一项复杂的活动。是一项团队合作，团队整体作战能力要求非常高的活动。因此，有时候项目的成败从团队水平就决定了。有时候可能一年两年看不出来问题，但当真正出现问题的时候已经无力回天了。而最初那批创造原始代码的人可能已经不在这里了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续&lt;a href=&quot;http://wantedonline.cn/2016/08/20/20160820-1/&quot;&gt;上一篇&lt;/a&gt;的话题。上一篇谈到了单元测试和团队代码规范问题.事实上到目前为止，我还没有碰到过一个团队对单元测试有过高的要求。我碰到的大部分团队可以说是对单元测试没有要求。这也和目前大部分开发团队碰到的现实情况是相符合的，开发的时间以及团队对代码的质量没有太多的要求。功能为王，实现功能就好，至于可维护性，可读性，可拓展性等等这些问题从来不考虑。这一篇我想谈一谈我对程序员代码质量的思考。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发日常" scheme="http://wantedonline.cn/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="软件开发" scheme="http://wantedonline.cn/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="IT生涯" scheme="http://wantedonline.cn/tags/IT%E7%94%9F%E6%B6%AF/"/>
    
  </entry>
  
  <entry>
    <title>这个世界会好吗？</title>
    <link href="http://wantedonline.cn/2016/11/03/20161103-1/"/>
    <id>http://wantedonline.cn/2016/11/03/20161103-1/</id>
    <published>2016-11-03T13:13:32.000Z</published>
    <updated>2016-11-04T00:26:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>想来想去也想不出一个什么好的标题来概括我想要表达的东西。恰好音乐播放到李志的&lt;这个世界会好吗&gt;，就用这个标题好了。走入社会后，总是会遇到各种各样的人，还有各种各样的事儿。有些人，有些事甚至会让自己不断怀疑自己的三观是不是错了，严重的还会怀疑整个人生。因此借文字来吐槽发泄一下吧。发泄完之后依然需要笑对生活，笑对世界~纵使生活**我千百遍，我待生活如初恋~</p>
<a id="more"></a>
<p>吃亏是福。但不意味着凡事都要选择吃亏。当我把你当成值得信赖的朋友的话，我可以一直吃亏。但是我的朋友也从没有让我一直吃亏过。但是如果仅仅是普通人，就没有必要一直选择吃亏了。小事还好，大事更加不想让自己吃亏。本分最重要，人都是自私的。总是想着占别人便宜的人最后一定占不到便宜。</p>
<p>耿直与真诚。和耿直的人交往会觉得说话做事效率特别高。我是个性子比较急躁的人。也觉得是一个比较耿直的人。很多事情直接说比委婉的说或者遮遮掩掩的说给人的感觉更愉快。至于真诚，人与人的交往如果都缺少了真诚，自然没有什么意思了。你对我真诚，我对你也真诚~</p>
<p>自我与换位思考。以前我是一个很自我的人，把自己当初世界的中心。走入社会后，自然会发现行不通。没有谁一定要围着谁转。也没有谁离不开谁。常常换位思考，自然能够理解别人，也自然能够被别人理解。</p>
<p>这个世界多点真诚，少点套路，多点关怀，多点爱，多好~~~</p>
<p>又快到了双十一了，请给我们这些单身狗多点关怀多点真诚。汪~汪~</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=30967310&auto=1&height=66"></iframe>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想来想去也想不出一个什么好的标题来概括我想要表达的东西。恰好音乐播放到李志的&amp;lt;这个世界会好吗&amp;gt;，就用这个标题好了。走入社会后，总是会遇到各种各样的人，还有各种各样的事儿。有些人，有些事甚至会让自己不断怀疑自己的三观是不是错了，严重的还会怀疑整个人生。因此借文字来吐槽发泄一下吧。发泄完之后依然需要笑对生活，笑对世界~纵使生活**我千百遍，我待生活如初恋~&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://wantedonline.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>分享一个Java IO方面的好东西</title>
    <link href="http://wantedonline.cn/2016/11/02/20161102-1/"/>
    <id>http://wantedonline.cn/2016/11/02/20161102-1/</id>
    <published>2016-11-02T12:09:50.000Z</published>
    <updated>2016-11-02T12:11:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在研究NIO的时候找到一个好东西，并发大师Doug Lea关于NIO方面的PPT文档。非常清晰明了~分享出来，自己需要的时候也可以看看 ^V^</p>
<a id="more"></a>
<p><a href="http://o9z6i1a1s.bkt.clouddn.com/nio.pdf" target="_blank" rel="external">Scalable IO in Java</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在研究NIO的时候找到一个好东西，并发大师Doug Lea关于NIO方面的PPT文档。非常清晰明了~分享出来，自己需要的时候也可以看看 ^V^&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="JavaIO" scheme="http://wantedonline.cn/tags/JavaIO/"/>
    
      <category term="Doug Lea" scheme="http://wantedonline.cn/tags/Doug-Lea/"/>
    
      <category term="分享" scheme="http://wantedonline.cn/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>理解Java内存模型(JMM)</title>
    <link href="http://wantedonline.cn/2016/10/29/20161029-1/"/>
    <id>http://wantedonline.cn/2016/10/29/20161029-1/</id>
    <published>2016-10-29T07:43:57.000Z</published>
    <updated>2016-10-29T07:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>当对并发编程的学习从初级阶段进入到高级阶段的过程中，对Java内存模型(JMM)的理解我认为是一个重要的分水岭。只有真正理解了JMM，才可能对并发中的线程、同步、线程通信以及后续并发编程高级技巧以及性能优化等问题有所理解。本文将总结我对JMM的一些理解。当然如果需要真正深入理解透彻JMM，还是需要读一读参考文献中的链接。</p>
 <a id="more"></a>
 <h2>1 什么是Java内存模型</h2>

<p> Java内存模型(JMM)不是Java语言所特有的。事实上像C#,Go等也有所谓的内存模型。这几门语言的内存模型总的来说要目标是一致的，但是可能语言之间的一些细节是有所差别的。<strong>Java内存模型要解决的一个问题是多线程中线程私有内存和主内存之间的数据一致性以及数据通信问题,这里需要重点说明的是这里主内存不是堆内存，这里的主内存是个抽象概念，并不对应JVM或者操作系统某块内存。</strong>事实上，不仅仅是JVM存在这个问题，在多处理器多寄存器架构中，也一定存在这个问题。考虑这样一种场景：多CPU，多寄存器通过总线共享主内存。如果在多线程环境下，CPU1中线程甲对数据A进行了修改操作，这时候CPU2中线程乙需要读取数据A。数据A分别在CPU1和CPU2的寄存器中存在副本。如果没有一种机制来保证数据通信，就一定会有数据一致性问题。JVM中，线程的一些数据是存在线程栈帧中的，多线程环境下，如何保证某些需要共享的数据的一致性和通信问题就需要一种机制来保证。因此才有了Java内存模型，对Java内存模型的定义以及一些规范是在JSR-133。</p>
 <h2>2 Java内存模型中几个重要概念</h2>

<p> Java内存模型中比较重要的也就是下面的三个概念了。这几个概念的最直观体现就是对synchonized,volatile,final,static等一些关键字的合理使用所带来的效果了。</p>
 <h3>重排序</h3>

<p> 关于重排序在上一篇文章中也有所提到。重排序有三个层次，分别是编译器的重排序，操作系统的重排序以及CPU指令级别的重排序。之所以会有重排序，是因为我们的编译器，操作系统，CPU已经很智能化了，它能够在不影响语义的情况下对某些指令进行优化以及调整顺序，以此来达到性能优化，减少一些不必要的指令执行的目的。但是在多线程环境下，重排序会导致数据一致性问题。因此才需要一些必要的保证手段来防止这三个层次的重排序。比如synchonized，volatile等。</p>
 <h3>内存屏障</h3>

<p> 内存屏障这个概念事实上以及是指令级别了。它规定了某些操作的先后顺序以及可见性问题。比如多处理环境下，对某些指令的执行必须要先于其他指令，可能就需要一个loadload指令等等。内存屏障的种类也有很多，比如loadload，loadstore，storestore等。不同的屏障功能不一样，适用场景也不一样。这一点对上层程序员是透明的。因此我觉得了解即可。</p>
 <h3>Happen-Before</h3>

<p> Happen-Before是JMM所定义的一些规则。这些规则保证了一些操作的顺序问题。这些顺序是有JVM来保证，并且保证不会被编译器或CPU等重排序所打破。Happen-Before也是定义的一个顺序问题。但是和内存屏障相比，它不再是指令级别，而是一个概念级别。或者一个原则问题。因此，有的书上也直接把这个叫做Happen-Before原则。具体的Happen-Before原则有这儿几条：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happen-before与该线程的后续操作</li>
<li>监视器锁规则：对一个监视器锁的解锁，happen-before于随后对这个监视器锁的加锁</li>
<li>volatile变量规则:对一个volatile域的写，happen-before于任意后续对这个volatile域的读</li>
<li>传递性：如果A happen-before B，B happen-before C，那么A happen-before C</li>
<li>Thread.start()的调用happen-before于启动线程里面的动作</li>
<li><p>Thread中的所有动作都happen-before于其他线程从Thread.join中成功返回</p>
<h2>3 Java内存模型对并发编程的意义</h2>

<p>JSR-133还定义了final，static等关键字的一些详细含义。因此如果要理解JMM，势必是要读一读JSR-133的。理解JMM，对于并发编程的最大意义我认为是在于对synchonized，volatile，fianl,static等关键字的合理运用，编写性能更好的并发程序来。</p>
<h3>参考文献</h3>

<ol>
<li><a href="https://jcp.org/en/jsr/detail?id=133" target="_blank" rel="external">JSR-133</a></li>
<li><a href="http://www.cs.umd.edu/%7Epugh/java/memoryModel/" target="_blank" rel="external">Java Memory Model</a></li>
</ol>
</li>
</ul>
<p><a href="http://wantedonline.cn/2016/09/08/20160908-1/">专题目录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当对并发编程的学习从初级阶段进入到高级阶段的过程中，对Java内存模型(JMM)的理解我认为是一个重要的分水岭。只有真正理解了JMM，才可能对并发中的线程、同步、线程通信以及后续并发编程高级技巧以及性能优化等问题有所理解。本文将总结我对JMM的一些理解。当然如果需要真正深入理解透彻JMM，还是需要读一读参考文献中的链接。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发编程" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="JMM" scheme="http://wantedonline.cn/tags/JMM/"/>
    
      <category term="Java内存模型" scheme="http://wantedonline.cn/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解原子性与可见性</title>
    <link href="http://wantedonline.cn/2016/10/21/20161021-1/"/>
    <id>http://wantedonline.cn/2016/10/21/20161021-1/</id>
    <published>2016-10-21T11:24:36.000Z</published>
    <updated>2016-10-21T13:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在并发编程的世界里，有两个非常重要的关键字，分别是synchronized和volatile. 一句话概括这两个关键字的作用的话就是synchronized保证了原子性，volatile保证了可见性。本文将深入分析原子性和可见性。</p>
<a id="more"></a>
<h2>原子性</h2>

<p>所谓原子性就是指操作不可分解，不会出现一半成功，一半失败的情况。我们都知道事务具有ACID属性，其中的A就是原子性。事务中的原子性也是说一个完整的事务中定义的全部操作步骤要么全部成功，要么全部不成功，不可分解。和我们这里的原子性定义是一样的。在并发编程中，我们在临界区的某些操作，必须具有原子性。因为我们无法控制线程的切换，所以就有可能发生线程执行到某个中间位置，因为时间片或者等待资源的情况发了上下文切换，切入到另外一个线程，这时候就破坏了数据的一致性。因此，我们必须保证临界区中这些操作的原子性。</p>
<h3>保证原子性的手段</h3>

<p>保证原子性的手段之一就是加锁。所谓锁，我们可以这么理解，当我们某个线程获取了锁，就代表他获得了一个特殊通行证，并且这个通行证一定是唯一的。在它归还这个通行证之前，其他线程是没办法进入到锁区域的。自然其他线程也就无法看到锁区域中数据的状态，也不能修改其状态。因此，只要我们的线程没有释放锁，其他线程是无法进入到锁区域的。直到我们成功释放了锁，我们的操作都是原子性的，不会被其他线程所干扰。</p>
<p>加锁的第一种方式是synchronized，这是Java提供的一个关键字，这个关键字的含义就是内置锁或者监视器锁。当我们的线程进入到了synchronized区域时，自动会获取锁，当退出这个区域是自动释放锁。如果我们使用javap打印一下一个synchronized修饰的代码块，我们会发现，有个叫<strong>enter monitor</strong>和<strong>exit monitor</strong>的两条指令，它们所包围的指令就是使用synchronized修饰的区域。</p>
<p>在J.U.C里，提供了更加灵活的加锁机制，就是Lock类，这是从Java代码层面提供的锁机制。这套机制比synchronized更加灵活，而且从JDK 1.6之后，这套锁机制的性能比synchronized更好了。这里面将锁划分的更细，可以有互斥锁(写锁)和共享锁(读锁)。获取锁和释放锁的操作都是可控的了，因此更加灵活，但是带来的使用复杂性也更加高了，如果我们获取了锁忘记释放锁或者释放锁失败将有可能会造成死锁等。</p>
<p>当我们看过J.U.C实现锁的方式(基于AQS)，我们自己也可以实现锁。如果使用Semaphore类的话，自己实现锁就更加简单了。</p>
<p>当然，保证原子性的手段并不是只有加锁这一种。事实上，锁机制对指令执行性能是有影响的。因此，如果不是有必要，我们不要随便加锁，而且加锁的区域尽量保证最小化，不要将没有必要加锁的代码放到锁区域中来。</p>
<p>原子性的另外一种方式是无锁化。这个看起来比较矛盾，其实是不矛盾的。无锁化是通过CAS(Compare and set)来实现的。J.U.C中提供了一些原子类，它保证原子性的方式就是CAS。后续我们分析J.U.C的原子类时将详细讲解CAS操作。</p>
<p>两种实现原子性的方式并不是可以互相替代的，而是他们在特定的场景具有特定的使用方式。加锁一般是代码块。而无锁化则是一些需要原子化的变量，通过CAS比使用加锁在变量层面性能更高。</p>
<h2>可见性</h2>

<p>所谓可见性是指我们希望对于某些状态我们进行了修改，希望其他线程能够感知到。这里就有线程通信的意思在里面了。考虑这样一种场景，变量x是两个线程A,B都可以看到的，线程A，B都保存了一份副本在彼此的栈帧里，当线程A修改了x时，如果没有一种机制去通信告知线程B，线程B仍然使用的是旧的x值。因此可见性就是要保证线程B能及时感知到x的状态变化。同样在CPU层面，也有这种场景，比如多核多寄存器。同样有变量的缓存以及修改需要通知其他CPU或寄存器变量的修改。当然这个层面不是JVM来保证了。</p>
<h3>保证可见性的手段</h3>

<p>保证可见性的第一种方法是直接使用锁，从效果上是可以的。但是前文说过，锁的方式对性能影响比较大。因此Java提供了另外一个关键字叫做volatile。这个关键字就是用来保证可见性的，它还有一个别称叫“轻量级锁”。</p>
<p>volatile为什么可以保证可见性呢? 这里可以从JMM找到原理。在下一篇讲解JMM时我们将详细分析synchronized和volatile两个关键字的原理。</p>
<h2>总结</h2>

<p>原子性和可见性是并发编程里两个非常重要的基础概念，只有深入理解了这两个概念，我们才能用好锁，用好可见性。才能编写出性能优越，线程安全的代码来。</p>
<p><a href="http://wantedonline.cn/2016/09/08/20160908-1/">专题目录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在并发编程的世界里，有两个非常重要的关键字，分别是synchronized和volatile. 一句话概括这两个关键字的作用的话就是synchronized保证了原子性，volatile保证了可见性。本文将深入分析原子性和可见性。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发编程" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="原子性" scheme="http://wantedonline.cn/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    
      <category term="可见性" scheme="http://wantedonline.cn/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>多线程带来的线程安全和线程通信问题</title>
    <link href="http://wantedonline.cn/2016/10/20/20161020-1/"/>
    <id>http://wantedonline.cn/2016/10/20/20161020-1/</id>
    <published>2016-10-20T09:29:07.000Z</published>
    <updated>2016-10-20T09:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>前文多次说过，多线程会带来线程安全问题以及线程与线程之间需要进行通信。在本文中，我想说说我理解的线程安全以及线程通信问题。当然，依然保持我博客的特点，很多东西仅仅点到为止，不做非常深入的分析。原因在于我自认为我离专家还有一定的距离，因此对于这些知识不敢以专家自居。仅仅分享我的理解，起到一个提纲挈领的作用。读者如果想要就某个点深入下去，还是需要一定的时间钻研的。 </p>
<a id="more"></a>
<h2>临界区</h2>

<p>只要是涉及到多线程，就一定涉及到临界区。前文说过，线程与进程的重要区别是线程共享临界区。临界区就是多个线程共享的一块内存。可以这样说，线程安全和线程通信的基础就是临界区。因此，只要是多线程编程，一定要时刻考虑临界区的数据变化。</p>
<h2>线程安全的本质</h2>

<p>在《Java并发编程实战》这本著作中对线程安全的定义大概是这样的(大概意思，非原文)，多线程的数据表现和单线程的数据表现是一样的话我们认为这个是线程安全的。我认为线程安全有这么几种情况。</p>
<h3>1 指令线程安全</h3>

<p>指令线程安全这个术语是本人原创(如有雷同，纯属意外)。对于<strong>a++</strong>类似的语句，我们都知道，JVM会编译成三条指令。因此如果在多线程环境下，因为线程上下文切换等就可能造成线程安全问题最终导致数据不一致。这种情况的办法一般只有使用原子锁或一些线程安全机制了(比如CAS)。指令线程安全还有一种情况是指令的重排序。</p>
<p><strong>重排序</strong></p>
<p>重排序是指CPU或者操作系统或者编译器在考虑性能的情况下对某些彼此关系不是很大的指令进行了优化和调整执行顺序。这里需要说明的是如果两条指令有非常明显的逻辑顺序，颠倒的话会影响语义的话是不会进行重排序的。重排序有三个层次，分别是CPU基本的重排序，操作系统执行时的重排序以及Java编译器的重排序。如果不考虑原子性或者可见性，在多线程环境下因为指令重排序是会导致线程安全问题的。因此针对这些，Java才定义了一个JMM(Java Memory Model Java内存模型)。关于JMM，这里不再展开，后面相关专题再涉及。</p>
<h3>2 共享数据线程安全</h3>

<p>所谓共享数据是指临界区的数据。在多线程环境下，这些数据事实上是暴露给各个线程的。各个线程都有权对其进行操作。因此这里自然就产生了线程安全问题。同样，共享数据只能通过加锁或者私有化(著名的ThreadLocal可以理解为干这事)或者直接让其不可变(final,权限控制)来实现线程安全，有句话说最好的线程安全就是让其不可变。</p>
<h2>线程通信的本质</h2>

<p>在保证线程安全的情况下，多线程之间需要进行通信的。这里的通信不是指发消息这种通信。我们可以把线程通信理解为多线程之间线程之间的协调。而协调的一些机制就是通过发送指令或者一种消息给JVM或操作系统来实现协调的。</p>
<h3>线程通信的手段</h3>

<p>Java里实现线程通信的方法有很多。最常见的有Object类的wait和notify系列。Thread里的sleep和Join等。同时在J.U.C里，提供了很多方式来实现线程通信，比如闭锁(CountDownLatch)，栅栏(CyclicBarrier)，条件类(Condition)等。同时，线程还提供了中断机制等，我们自己也可以控制一个线程的执行。需要说明的是因为消息安全(比如丢失消息)问题导致的死锁等，JDK已经废弃了Thread的stop等方法。</p>
<h2>总结</h2>

<p>本文从大逻辑点到了多线程带来的线程安全问题和线程之间通信的方法。很多东西如果研究下去又可以单独写一篇文章了。在后面会对一些比较重要的地方再做说明。</p>
<p><a href="http://wantedonline.cn/2016/09/08/20160908-1/">专题目录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文多次说过，多线程会带来线程安全问题以及线程与线程之间需要进行通信。在本文中，我想说说我理解的线程安全以及线程通信问题。当然，依然保持我博客的特点，很多东西仅仅点到为止，不做非常深入的分析。原因在于我自认为我离专家还有一定的距离，因此对于这些知识不敢以专家自居。仅仅分享我的理解，起到一个提纲挈领的作用。读者如果想要就某个点深入下去，还是需要一定的时间钻研的。 &lt;/p&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="多线程通信" scheme="http://wantedonline.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
      <category term="线程安全" scheme="http://wantedonline.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程的基本手段</title>
    <link href="http://wantedonline.cn/2016/10/18/20161018-1/"/>
    <id>http://wantedonline.cn/2016/10/18/20161018-1/</id>
    <published>2016-10-18T15:25:18.000Z</published>
    <updated>2016-10-18T12:49:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>实现并发的一个关键或者说核心手段就是使用多线程。线程就是轻量级的进程。它和进程的区别在于是否共享临界区或者说共享数据内存。我们一般把可以分解的任务使用多线程来实现。所谓可以分解的任务就是可以并行化的任务。比如从1加到100，我们可以先两两相加，求得的和再两两相加。这里两两相加都一样的，只是输入的加数不一样而已，显然是可以并行化的。本文将介绍Java中实现并发的几种方法以及两个重要的关键字的用法。</p>
<a id="more"></a>
<h2>继承Thread类</h2>

<p>初学Java的人学到多线程介绍的方法一定是继承<strong>Thread</strong>类，然后覆写其中的<strong>run</strong>方法。启动线程的时候再调用该Thread类的start方法。</p>
<p>但是Java只支持单继承，如果要既要实现线程，又要继承其他类的话就需要使用接口了。因此才有了<strong>Runnable</strong>接口。</p>
<h2>实现Runnable接口</h2>

<p>所谓接口，就是一个约定，一个规范。Runnable接口约定了我们如果要抽象出一个任务来实现多线程，只要实现run方法接口。然后把这个Runnable子类放到Thread作为参数去调用即可。</p>
<p>查看Thread源码或Runnable的run方法签名即可知道，这两种方式执行完都是没有返回值的。假如我们有一个任务需要将返回值返回出来怎么办？一种方式是通过传参，并且这个参数是引用参数。但是这种方式有点C语言味道。在Java里，更加直观的方式显然是通过返回值。怎么办呢？</p>
<h2>实现Callable接口</h2>

<p>在J.U.C(java.util.concurrent)包里，从J.D.K 1.5开始就提供了一个叫做<strong>Callable</strong>接口的类。这个接口有一个方法叫做<strong>call</strong>，在使用前需要指定返回值V，该方法就可以返回一个V类型的对象。</p>
<p>除了有返回值，这个接口和<strong>Runnable</strong>接口的功能一模一样。但是用法稍微有些不同。显然，不能像Runnable一样放到Thread里。这个接口是J.U.C提供的，自然在J.U.C里有相应的类来执行Callable子类。</p>
<p>这就是Executors框架。</p>
<p>Executors框架最常见的功能就是提供了4中类型的线程池。抽象线程池(AbstractExecutorService)提供了一个submit方法和newTaskFor方法。submit方法就是将一个Callable类作为参数提交到线程池，当线程池执行完之后会返回一个Future对象将返回值带出来。newTaskFor是一个装饰器方法，返回一个RunableFuture对象，这个对象就是一个包装的任务。可以用于线程池的工作窃取队列等地方。详细的线程池以及使用在后面用单独的文章来说明。</p>
<h2>线程的本质</h2>

<p>关于线程的形象描述。我只服这篇<a href="https://segmentfault.com/a/1190000004694556" target="_blank" rel="external">文章</a>。</p>
<p>这里阐述线程的本质，我打算从Java中Thread类的源码角度来阐述。</p>
<p>首先，看看javadoc关于线程的一些描述。</p>
<blockquote class="blockquote-center"><p>A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently. </p>
</blockquote>
<p>从这里我们可以看出，Java中的线程是虚拟机层面的线程。是由虚拟机来保证并发的。那么它和操作系统层面提供的线程是否是一一对应？这点我没有看过JVM的源码，因此无法说出准确答案。但是从Thread源码来看,虚拟机的线程和操作系统是有关系的。因为在Thread类中引用了一些native方法，只是这些native方法源码以及实现我目前还无法得知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static native void registerNatives();</div></pre></td></tr></table></figure>
<p>一个线程的一些基本属性有优先级，线程名(可以不指定)等。这些属性在初始化一个线程的时候，可以通过构造函数来设置。</p>
<h3>线程的一些基本概念</h3>


<h4>1 守护线程</h4>

<p>所谓守护线程是指一些优先级比较低(通常情况下),在后台执行的一些线程。比如我们的程序入口main函数所在的线程，JVM的垃圾回收线程等。守护线程的特点就是它要等其他所有非守护线程执行完成，JVM虚拟机打算退出的时候它在结束运行。守护线程的作用就是用于一些后台执行的任务，一般来说，他们的优先级不是很高。不然其他普通线程都没有时间片去执行了。</p>
<h4>2 线程组</h4>

<p>ThreadGroup就是将一些功能相近的线程或者有父子关系的线程放到一个集合里。这个集合就是ThreadGroup，它内部就是一个数组。同时也可以将ThreadGroup放进去。这样相互联系的一些线程之间的拓扑关系就可以表达出来。使用线程组的好处是我们可以一次设置一组线程的属性，比如优先级，名字，是否是守护线程等。同时还可以一次控制一组线程(线程组的暂停唤醒方法因为安全问题已经不建议使用了)。</p>
<h4>3 线程优先级</h4>

<p>这个概念应该很好理解。Java里将线程优先级定义为 1-10，同时定义了三个常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public final static int MIN_PRIORITY = 1;</div><div class="line"></div><div class="line">public final static int NORM_PRIORITY = 5;</div><div class="line"></div><div class="line">public final static int MAX_PRIORITY = 10;</div></pre></td></tr></table></figure>
<p>一般我们就用这三种级别来设定线程优先级即可。优先级越高，就越优先执行。</p>
<h3>线程的生命周期</h3>

<p>前面说过，启动一个线程调用Thread的start方法。线程从启动开始到线程执行完毕被操作系统回收，是有一系列的生命周期状态转换的。在Java里，这些状态定义在Thread内部的一个枚举State里。这5个状态分别是    NEW,RUNNABLE,BLOCKED,WAITTING,TIMED_WAITING。关于状态的互相转换以及如何观察线程状态可以另开一篇文章来说明了。这里不再详述，总之和操作系统课上关于进程的状态转换有一点点类似。</p>
<h3>线程的通信</h3>

<p>线程最重要的一个话题就是线程之间的通信。因为线程之间彼此共享内存，因此必然存在一些线程安全问题和线程通信问题。线程中的wait,join,notify,sleep等方法都是为线程通信而产生的。具体作用可以在文档以及后续博文中找到。</p>
<h3>static,final等对线程安全的意义</h3>

<p>关于static，final这两个关键字的一些用法是每个资深Javaer必须掌握的。static对于线程安全的意义更多的体现在修饰一个变量上。当一个变量是static变量时意味着这个变量是个类变量，被全部线程所共享。因此必然存在线程安全问题。而final修饰一个变量则是不可变的意思。修饰引用指引用关系不可变。因此，在多线程里，可以使用static和final来实现依一些数据共享和线程安全的问题。</p>
<h3>总结展望</h3>

<p>本文很简单的介绍了Java中实现并发的几种方式。同时概括性地点到了线程的一些基本概念和线程通信和安全问题。要说清楚这些问题不是这么一篇文章能够说清楚的。这里我感到自己语言总结和学识的精通程度还没有达到专家水准。因此有些问题尽管我知道在生产实践中应该怎么用以及会出现什么问题，但是要介绍给读者却有些困难。希望后面有时间能够详细阐释清楚每一个问题。</p>
<p><a href="http://wantedonline.cn/2016/09/08/20160908-1/">专题目录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现并发的一个关键或者说核心手段就是使用多线程。线程就是轻量级的进程。它和进程的区别在于是否共享临界区或者说共享数据内存。我们一般把可以分解的任务使用多线程来实现。所谓可以分解的任务就是可以并行化的任务。比如从1加到100，我们可以先两两相加，求得的和再两两相加。这里两两相加都一样的，只是输入的加数不一样而已，显然是可以并行化的。本文将介绍Java中实现并发的几种方法以及两个重要的关键字的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发编程" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程" scheme="http://wantedonline.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>博客更新说明(2016.09)</title>
    <link href="http://wantedonline.cn/2016/09/20/20160920-1/"/>
    <id>http://wantedonline.cn/2016/09/20/20160920-1/</id>
    <published>2016-09-20T11:59:41.000Z</published>
    <updated>2016-10-07T06:44:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>计划永远赶不上变化，原计划9月份更新5-6篇并发方面的文章，谁知工作生活发生了一些变化，让我有些猝不及防。 :(</p>
<p>原计划9，10月完成的并发专题可能不能按时完成了。 :(</p>
<p>我又拖欠作业了….<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计划永远赶不上变化，原计划9月份更新5-6篇并发方面的文章，谁知工作生活发生了一些变化，让我有些猝不及防。 :(&lt;/p&gt;
&lt;p&gt;原计划9，10月完成的并发专题可能不能按时完成了。 :(&lt;/p&gt;
&lt;p&gt;我又拖欠作业了….&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="博客更新" scheme="http://wantedonline.cn/tags/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>并发编程概述</title>
    <link href="http://wantedonline.cn/2016/09/08/20160908-2/"/>
    <id>http://wantedonline.cn/2016/09/08/20160908-2/</id>
    <published>2016-09-08T08:26:31.000Z</published>
    <updated>2016-09-20T11:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>并发编程(Concurrency Programming)，从字面意思来看，自然让人联想到两个或多个的意思。并发编程的出现是计算机硬件，操作系统进步的结果，也是计算机科学追求更快速度，更高效率解决问题的结果。</p>
<a id="more"></a>
<h2>在并发出现之前</h2><br>在并发出现之前，程序的执行自然就都是串行了。那时计算机CPU都是单核的，内存也非常小。需要利用计算机解决的问题也远没有现在这样复杂。因此将程序串行化自然能够解决很多问题。<br><br>随着计算机软件和硬件的发展，不仅一台计算机可以有多个CPU，一个CPU还可以有多核。内存变得越来越大，速度也变得越来越快了。为了充分利用这些资源，同时为了提高计算效率和应对更大的计算量，自然而然出现了并发。<br><br><h2>并发的基本概念</h2>

<p><strong>并发和并行</strong></p>
<p>和并发这个概念有一字之差的就是并行。虽然只有一字之差，事实上这两个概念有很大的不同。并发是多个线程做同一件事情，并行是多个进程做不同的事情。这些进程可能一点关系也没有。举个例子，求N个数之和，我们可以将这N个数分成M分，用M个线程去分别求和，最后再由一个线程合并求和。这就是并发。一个程序做的事情是求N个数之和，不管这个程序是一个线程完成还是多个线程完成。另一个程序做的事情是求N个数的乘积，也不管这个程序是一个线程完成还是多个线程完成。这两个线程在各自的内存区域共同受一个CPU调度，而且这两个程序还是同时进行。那这就是并行。</p>
<p>由并发牵扯到的一个最重要的概念就是<strong>线程</strong>(Thread)，并发的手段就是多线程。因此并发编程也可以叫做多线程编程。如果没有多线程的编程绝对不能叫做并发编程。</p>
<p>那线程又是什么？<strong>线程</strong>可以理解为小粒度的进程，和进程的区别在于线程之间共享内存，进程之间独立内存。关于线程的形象完整表述我认为这篇<a href="https://segmentfault.com/a/1190000004694556" target="_blank" rel="external">文章</a>写的非常好。</p>
<p>总结来说，并发是彼此之间有联系，可以共享数据。并行是彼此之间没有多少联系，做着不同的事情不会共享数据。</p>
<p><strong>串行和并行</strong></p>
<p>串行的反义词应该是并行。串行可以理解为一次只做一个事情，充分发挥愚公移山的精神。从微观层面来看，CPU的指令执行必定都是串行的，一个时钟周期内，单个CPU的单个核内不可能同时执行两条指令。并行的话上面说过，是多个进程做不同的事情。从微观上来看，一个多核CPU或者多个CPU在同一个时钟周期内，执行不同的指令可以认为是并行。</p>
<p><strong>单核和多核</strong></p>
<p>前面说过，随着计算机硬件的发展，逐渐出现了多核甚至多个CPU(宏观上我们可以把多核和多CPU等同)，这样并发编程就自然而然出现了。事实上，这种说明严格来说，是不符合历史的。我们不能说多核就一定是并发，单核就一定只能是串行。单核也可以并发，多核自然绝对可以串行。在多CPU(或者说多核)出现之前，是有并发的。只不过这时候的并发从指令的微观层面来看，它是串行化的。一个CPU时钟周期内，一定只有一个线程在运行。因此，这个时候，多线程编程的性能和效率不一定比串行编程要高。当然，并行比串行自然效率要高。举个例子，某个程序是CPU密集计算，某个时刻正在CPU计算，另一个程序是IO密集的，同一时刻可以调度它去进行IO计算而不影响CPU密集计算的程序，这样自然就提高了效率。</p>
<p>单核可以并发，也可以并行，多核的场景下进行并发编程比单核效率要高很多。这里有一个阿姆达尔定律来说明这个事情。关于<a href="http://ifeve.com/amdahls-law/" target="_blank" rel="external">阿姆达尔定律</a>，我觉得这篇文章说的比较清楚。</p>
<h2>并发编程的影响</h2>

<p>很显然，并发编程带来的最大影响是提高了计算效率，充分利用了计算资源(并行也是为了充分利用计算资源)。但同时并发编程也带来了一个巨大的影响，那就是使得编写并发程序变得困难起来。编写正确的程序就已经比较难了，编写正确的并行程序就是难上加难。</p>
<p>编写并发程序为什么更加困难？原因在于并发程序需要处理线程调度，数据共享问题。因为数据共享带来的线程安全问题。同时，多线程就意味着需要额外的调度逻辑，这多出来的调度会带来线程的上下文切换等损耗。因此多线程不是高性能的良方。恰当地使用多线程，小心翼翼地编写并发程序才是对策。有时候，我们甚至不能忽略线程切换带来的性能下降，更加不能容忍多线程带来的线程安全导致错误的计算结果问题。</p>
<h2>还可以提高计算效率吗</h2>

<p>很显然，多线程不是高性能的最好办法。可以这样说，多线程的目的在于充分利用计算机硬件资源和软件资源，使其不断处于忙碌状态从而提高生产效率。而高性能的解决办法有时候需要从更加宏观的地方入手。</p>
<p><strong>分布式架构</strong></p>
<p>目前，互联网里分布式架构应该比较流行。因为解决高并发，大流量问题很多时候就是分布式。现在比较流行的<strong>微服务</strong>也可以理解为更小粒度的SOA。计算机科学里还是现实生活中，我们解决大问题的思路就是拆分。将大问题拆分成小问题，将大模块拆分成小模块。然后利用多实例，多服务来解决。因此，从宏观层面来看，分布式和并发的思想上有某种契合。都是化大为小，各个击破。</p>
<p><strong>协程</strong></p>
<p>多线程必然带来线程切换的问题。线程切换就会消耗额外的计算资源。因此计算机科学里又有了一种<strong>协程</strong>的说法。可以这样认为，线程是小粒度的进程，而协程可以理解为小粒度的线程。协程不需要上下文切换，在方法调用里调用其他的方法不需要切换资源。这里的关键在于利用了CPU的中断。因此避免了线程切换带来的资源消耗。未来，Java必将支持协程。而目前Python已经支持协程了。关于协程的说明，可以参考这篇<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000" target="_blank" rel="external">文章</a></p>
<p>协程出现后，将来的并发编程并发编程将变得更加简单还是更加复杂了呢？可以肯定的是，协程出现后，并发编程带来的效率提升又会上一个台阶。</p>
<p><a href="http://wantedonline.cn/2016/09/08/20160908-1/">专题目录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发编程(Concurrency Programming)，从字面意思来看，自然让人联想到两个或多个的意思。并发编程的出现是计算机硬件，操作系统进步的结果，也是计算机科学追求更快速度，更高效率解决问题的结果。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发编程" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="并发专题" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>并发编程专题开篇</title>
    <link href="http://wantedonline.cn/2016/09/08/20160908-1/"/>
    <id>http://wantedonline.cn/2016/09/08/20160908-1/</id>
    <published>2016-09-08T04:31:16.000Z</published>
    <updated>2016-11-12T09:10:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>自认为还算是一个技术爱好者(软件相关)。不管是在学校还是在工作岗位上，都一直保持买书，看书的这样一个优良习惯。除了保持内心沉(zhuang)静(bi)，更重要的是我能系统深入学到很多东西。</p>
<p>但是自从患上拖延症和懒癌之后，我学到的很多东西都藏在肚子里，最后烂在肚子里了，也就白学了。因此，我决定，未来4个月好好总结和回顾过去学到的东西，并且以专题的形式总结和分享出来(尽最大努力酿酒，巷子深浅与否看造化了)。</p>
<p>9月和10月(2016)我想总结和分享的专题是Java编程里最具有挑战性的一个—-并发编程。<br><a id="more"></a><br>根据我对并发编程的理解，我将深入浅出，由表入里，步步为营将并发编程分成这样12篇文章来讲解。当然，这远远不是并发编程的全部。很多知识点我也只能说一个思路或者大概样貌，不可能面面俱到。下面是我暂时拟出的一个讲解框架:</p>
<ol>
<li><p><a href="http://wantedonline.cn/2016/09/08/20160908-2/">并发编程概述</a><br><br>这里主要说一下并发编程的由来，一些基本概念和术语。同时会从宏观(分布式)和微观(多线程)谈一下并发。最后，展望一下未来，说一下协程。</p>
</li>
<li><p><a href="http://wantedonline.cn/2016/10/18/20161018-1/">Java并发编程的基本手段</a><br><br>实现Java多线程的手段以及基本用法(Thread,Runnable,Callable)，static,final等对线程安全的意义</p>
</li>
<li><p><a href="http://wantedonline.cn/2016/10/20/20161020-1/">多线程带来的线程安全和线程通信问题</a><br><br>引出临界区，数据竞争以及线程通信模型,深入讲解线程通信的方法(分析ThreadLocal类)以及意义</p>
</li>
<li><p><a href="http://wantedonline.cn/2016/10/21/20161021-1/">深入理解原子性与可见性</a><br><br>因为多线程通信问题，可能引发原子性和可见性等问题，从Java语言层面讲解原子性和可见性</p>
</li>
<li><p><a href="http://wantedonline.cn/2016/10/29/20161029-1">理解Java内存模型(JMM)</a><br><br>继续深入，理解JMM</p>
</li>
<li><p><a href="http://wantedonline.cn/2016/11/12/20161112">J.U.C概述</a><br><br>JDK并发工具包介绍,从该包的结构以及功能上做一个概述，为后面的分解铺垫思路</p>
</li>
<li><p>深入J.U.C中的锁<br><br> 深入分析Java语言层面提供的锁机制以及实现原理，对比分析synchronized的异同和优劣</p>
</li>
<li><p>深入J.U.C中Executor框架<br><br> 深入分析Java中线程池，比较分析4中线程池的异同以及用法</p>
</li>
<li><p>深入J.U.C中并发容器类<br><br> 简单分析各个容器类的作用和用法，重点分析ConcurrentHashMap</p>
</li>
<li><p>深入J.U.C中原子类<br><br> 简单分析各种原子类的用法以及作用，重点分析CAS操作的实现以及底层机制</p>
</li>
<li><p>深入J.U.C中并发工具类<br><br> 简单分析各个工具类的用法以及作用，重点分析CountDownLatch和CyclicBarrier</p>
</li>
<li><p>并发编程总结<br><br> 总结这个专题的意义以及不足，说一下并发的测试思路</p>
</li>
</ol>
<p>这个思路从简单到复杂，基本是按照并发编程学习的思路来的。当然，各个章节也很独立。可以作为单独的复习或学习参考。希望这个专题能给自己和他人带来知识上的梳理与巩固。<br>Good Luck to you and me!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自认为还算是一个技术爱好者(软件相关)。不管是在学校还是在工作岗位上，都一直保持买书，看书的这样一个优良习惯。除了保持内心沉(zhuang)静(bi)，更重要的是我能系统深入学到很多东西。&lt;/p&gt;
&lt;p&gt;但是自从患上拖延症和懒癌之后，我学到的很多东西都藏在肚子里，最后烂在肚子里了，也就白学了。因此，我决定，未来4个月好好总结和回顾过去学到的东西，并且以专题的形式总结和分享出来(尽最大努力酿酒，巷子深浅与否看造化了)。&lt;/p&gt;
&lt;p&gt;9月和10月(2016)我想总结和分享的专题是Java编程里最具有挑战性的一个—-并发编程。&lt;br&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发编程" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="深入理解" scheme="http://wantedonline.cn/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
      <category term="并发" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>亲自动手做的工具(一)</title>
    <link href="http://wantedonline.cn/2016/08/24/20160826-1/"/>
    <id>http://wantedonline.cn/2016/08/24/20160826-1/</id>
    <published>2016-08-24T09:46:29.000Z</published>
    <updated>2016-09-20T11:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>结合工作需要，做了一个为Javaer Web开发者提供的自动化PO文件生成工具，同时支持生成docx格式的数据字典</p>
<a id="more"></a>
<h2>工具用途</h2>

<p>在Java Web开发过程中，我们总要手动去生成一些PO类(Persistent Object),这些类一般映射到数据库中的一张表。这些代码简单，模式化程度高。因此做了这个工具来简化开发者的工作。</p>
<p>本工具为一个maven 工程，使用非常简单，效率极高。</p>
<h2>目前支持</h2>


<ul>
<li>批量生成所配置的数据库的全部表；</li>
<li>自定义类后缀</li>
<li>自定义生成类路径</li>
<li>根据数据库表字段注释生成java文件字段注释</li>
<li>自定义排除特定表的生成类</li>
</ul>
<h2>后续可能支持特性</h2>

<ul>
<li>自定义生成特定表的生成类</li>
<li>更加智能化和易用化</li>
</ul>
<h2>约束</h2>

<p>要生成开发者友好的文件，建议数据库表名，字段名采用驼峰命名法。命名合符Java规范。</p>
<h2>使用方法</h2>

<p>Step 1 down下本工程，导入Maven工程：<br><img src="http://o9z6i1a1s.bkt.clouddn.com/2016082401.png" alt=""></p>
<p>导入成功后，工程目录如下：<br><img src="http://o9z6i1a1s.bkt.clouddn.com/2016082402.png" alt=""></p>
<p><em>注意： 如果要生成docx格式的数据字典，需要依赖POI，直接使用maven导入poi依赖会报错，因此采用本地导入，建了一个lib目录，已经将依赖包放到lib目录，在pom配置文件中配置好了本地依赖</em></p>
<p>Step2 根据自己的需求，修改配置文件，配置文件在工程根目录下，文件名字是 <strong>datasource.properties</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/2014082403.png" alt=""><br><strong>配置说明</strong></p>
<ul>
<li>mysqlDriver 目前仅支持mysql，因此这里可以不用变(后续可能会支持多种数据库)</li>
<li>globalUserName 如果你有很多数据库要生成，并且这些数据库的用户名一样，可以配置这个变量</li>
<li>globalPassword 同上，这里是配置统一的密码</li>
<li>url_jdbc_your_db<em>name 单独配置某个数据库的链接url，注意，url</em>这个前缀必须统一</li>
<li>username_your_db_name 单独配置某个数据库的用户名，这里前缀必须有，如果全部数据库都用一个用户名，这里可以缺省不配</li>
<li>password_your_db_name 同上，配置密码，如果全局密码一致，可以缺省</li>
<li>exclude_your_db_name 跳过生成PO的表,使用英文状态下的逗号分隔 前缀固定 databaseName必须是所连接的数据库真实名称</li>
<li>po_package 你要生成的PO文件包名，使用标准的包，用 . 分隔，生成的PO文件会直接放到这下面，方便直接拖入你的工程</li>
<li>po_suffix 生成的PO文件后缀，默认是xxxPO.java，可以自定义</li>
<li>serialize 是否需要序列化，默认是false，如果该选项为true，则自动实现序列化接口</li>
</ul>
<p><em>可以一次配置多个数据库，只要按照格式注意前缀和数据库名，如果连接失败会报错</em></p>
<p>配置完之后，找到入口Main.java, 按下F11 运行工程即可。如果需要生成数据字段，则将入参配置为true<br><img src="http://o9z6i1a1s.bkt.clouddn.com/2016082404.png" alt=""></p>
<p>如果没有任何输出就结束了工程就是好结果。</p>
<p>如果有输出，根据输出排错</p>
<h2>正确生成的结果</h2>

<p>生成的部分文件<br><img src="http://o9z6i1a1s.bkt.clouddn.com/2016082405.png" alt=""><br>文件内容<br><img src="http://o9z6i1a1s.bkt.clouddn.com/2014082406.png" alt=""><br>生成的数据字典样式<br><img src="http://o9z6i1a1s.bkt.clouddn.com/2016082407.png" alt=""></p>
<h2>关键源码说明：</h2>

<p>Main.java 启动类</p>
<p>DataBaseEntity.java 业务类，具体的生产逻辑都在这里</p>
<p>utils包中</p>
<p>ConfigParser.java 配置文件解析类，校验配置有效性也在这里完成</p>
<p>ConnectionHelper.java Mysql 链接获取以及操作类</p>
<h2>致谢</h2>

<p>生成PO文件的逻辑是在同事的基础上修改完成，修改引用了同事(仇老板)的parse(我修改为了parseTable)，自动生成字段，get，set方法，文件输出等逻辑，在此表示感谢~~~</p>
<h2>获取项目</h2>

<p><a href="https://github.com/34benma/PORobot" target="_blank" rel="external">GitHub地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结合工作需要，做了一个为Javaer Web开发者提供的自动化PO文件生成工具，同时支持生成docx格式的数据字典&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://wantedonline.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://wantedonline.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="生产效率" scheme="http://wantedonline.cn/tags/%E7%94%9F%E4%BA%A7%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>软件开发日常思考</title>
    <link href="http://wantedonline.cn/2016/08/20/20160820-1/"/>
    <id>http://wantedonline.cn/2016/08/20/20160820-1/</id>
    <published>2016-08-20T14:36:04.000Z</published>
    <updated>2016-08-20T15:41:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果不算大学，我从事软件行业已经两年多了。这两年，我从一个制度流程非常完善的大公司跳到一个刚成立不久的小互联网公司(脑子没有进水，仅仅是为了追求初心而已)。本文将总结我这两年在软件开发中一些体会。</p>
<a id="more"></a>
<h2>流程很重要</h2>

<p>私下和前同事交流，发现大家最大的感受就是流程很重要。以前在老东家的时候，大家都痛恨老东家冗长的流程。出来了，没有流程了，才发现一团糟。给我们的工作带来的是混乱和效率低下。什么是流程？流程就是对某到工序的流程的抽象描述。任何一个人，只要按照这个流程走，就不会出错，效率和沟通也非常有效。一旦没有了流程，大家就按照自己的风格和喜好来做事。然后就有了各种低效的沟通和无穷尽的错误。</p>
<p>日常办公有OA系统，有各种电子流。同样，软件开发从需求定义到交付维护，也可以有完整标准的流程。不管团队大小，其实都适用。有了流程，大家就有了标准。知道下一步应该怎样做。沟通自然也就高效了。</p>
<h2>需求应该是可控的</h2>

<p>程序员最大的痛苦就是需求一日三变。刚写完的代码还没有保存，产品经理就告诉你，需求变了；刚发布上线，还没有用三天，又告诉你需求变了。在这不断变化的需求中，我们的代码也变得千疮百孔，一个月之后，程序员自己都很难明白有些地方为啥要这样写了。</p>
<p>如果团队碰上这样的产品，也就陷入了无限循环的更改和加班中了。一个不成熟的想法不应该作为需求交付给开发人员。这是对开发者最大的不尊重。项目管理者也应该拒绝这样的需求。</p>
<h2>TDD会成倍提高效率</h2>

<p>TDD，测试驱动开发。尊崇但愿测试。讲究测试覆盖率。理论上来说，我们发布的代码都应该测试覆盖率达到100%，开发者提交给测试的代码但愿测试用例应该覆盖了全部代码。但是现实是，我们抛弃了单元测试。理由往往只有一个，没有时间写单元测试。</p>
<p>开发的时间被一压再压，上线之后就是无限的与bug作斗争。整个项目没有一个专门的test包来写一个单元测试用例。这样的代码质量可想而知。</p>
<p>放弃了单元测试，等于放弃了质量。势必就会陷入加班的死循环中。</p>
<h2>代码规范很重要</h2>

<p>有多少团队会遵循一套统一的属于自己的编程规范？代码规范应该作为团队成员必须遵循的军规。每个新成员加入时都应该培训代码规范。在开发过程中也应该强制遵循代码规范。这样的代码才能交给维护团队去维护。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果不算大学，我从事软件行业已经两年多了。这两年，我从一个制度流程非常完善的大公司跳到一个刚成立不久的小互联网公司(脑子没有进水，仅仅是为了追求初心而已)。本文将总结我这两年在软件开发中一些体会。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发日常" scheme="http://wantedonline.cn/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="周末随笔" scheme="http://wantedonline.cn/tags/%E5%91%A8%E6%9C%AB%E9%9A%8F%E7%AC%94/"/>
    
      <category term="软件开发" scheme="http://wantedonline.cn/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="IT生涯" scheme="http://wantedonline.cn/tags/IT%E7%94%9F%E6%B6%AF/"/>
    
  </entry>
  
  <entry>
    <title>忧愁的香烟</title>
    <link href="http://wantedonline.cn/2016/08/07/20160807-1/"/>
    <id>http://wantedonline.cn/2016/08/07/20160807-1/</id>
    <published>2016-08-07T15:28:06.000Z</published>
    <updated>2016-08-07T15:34:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>今晚(2016-08-07)夜跑结束，一种孤独和忧愁涌上心头。便买来香烟一个人坐在草地上思考了人生……</p>
<a id="more"></a>
<p>我点燃一根香烟<br>一个人静静地坐在草地上</p>
<p>偶尔有路人带着疲惫和忧愁从我身边目视前方走过<br>我不知道他们在忧愁什么<br>就像他们不知道我在忧愁什么一样</p>
<p>不远处三位大妈<br>正在谈论着彼此儿女的婚姻<br>她们不理解儿女的一些事儿<br>我也不理解所谓的爱情和婚姻</p>
<p>我静静地坐在草地上<br>抽了一根又一根的香烟<br>今夜，我愿就这样沉睡下去<br>带着我的香烟和忧愁<br>永远地沉睡下去</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今晚(2016-08-07)夜跑结束，一种孤独和忧愁涌上心头。便买来香烟一个人坐在草地上思考了人生……&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://wantedonline.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="孤独" scheme="http://wantedonline.cn/tags/%E5%AD%A4%E7%8B%AC/"/>
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="小诗" scheme="http://wantedonline.cn/tags/%E5%B0%8F%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>微型秒杀模型的几点思考</title>
    <link href="http://wantedonline.cn/2016/08/04/20160804-1/"/>
    <id>http://wantedonline.cn/2016/08/04/20160804-1/</id>
    <published>2016-08-04T12:25:10.000Z</published>
    <updated>2016-08-07T15:26:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作上做了几个抢票的活动。其中有一部分抢票活动非常火爆，用户访问量非常大。任何一个系统，只要涉及到高并发，分布式就会变得复杂起来。本文是我对这类问题的一些思考和总结。后面有时间还将分享关于流控模型的一些思考，敬请期待。<br><a id="more"></a></p>
<h2>一 几点解释以及场景分析</h2>

<h3>1.1 关于微型</h3>

<p>微型并不是说并发量比较小或者逻辑比较简单。微型的意思是指库存比较小。而库存就是指我们要抢的东西的总量。当库存比较大的时候，架构和逻辑复杂度也会有相应的变化。</p>
<h3>1.2 场景分析</h3>

<p>我们有100个宝贝，这些宝贝非常抢手，很多人都想得到。但很显然，最终真正得到宝贝的人只有100个。如果出现了超过100个人购买成功了就是超卖，最终超卖的部分只能通过协商解决了。但是从发起购买到购买成功的过程中会有一个支付的过程。必须支付成功才能购买成功。因此如果库存的增减不恰当可能会出现假卖的情况。也就是有可能很多人同一时间购买，但大家都没有付款成功。后面的人来买的话提示没有库存了，事实上这些宝贝还没有卖出去，最终导致想要买宝贝的人没能买到。整个购买模型如下图所示：</p>
<p><img src="http://o9z6i1a1s.bkt.clouddn.com/2016080401.png" alt=""></p>
<p>这里的关键在于会异步调用第三方支付网站完成支付，在这个过程中，库存应该怎样减？在哪个步骤减？如何处理支付问题等很多问题会影响商品购买流程。</p>
<h3>1.3 一种假设</h3>

<p>如果我们的网站架构师单实例单库，很多问题会非常简单。我们可以通过加锁，限流，串行化等手段解决。但是这样的网站架构显然不满足高并发，分布式的要求，不能承受较大的点击量。因此，我们的秒杀模型都是基于多实例，分布式，Redis缓存，MySQL分表分库等架构。能够承受较大的并发。</p>
<h2>二 几种秒杀模型分析</h2>

<h3>2.1 在支付前扣减库存</h3>

<p>为了防止超卖，我们可以在跳转到第三方支付进行支付之前扣减库存，这样可以有效防止商品因为超卖而导致的退款流程。但是很显然，这样会带来假卖的问题。假如一下子非常多的用户涌进来，他们占完了全部库存，但是迟迟不付款或者支付失败。导致后面的用户点击购买的时候提示没有库存而无法购买。一种稍微好点的办法是在支付成功时统计一下购买成功的总数，用总库存减去购买成功数得到剩余库存做一次修正。这样可以修正某些场景，但是如果有恶意用户，提交很多不支付的订单将库存消耗完(占着茅坑不拉屎),就会导致假卖问题。</p>
<h3>2.2 在支付成功后减库存</h3>

<p>为了防止2.1模型的假卖问题，我们将扣减库存问题放在支付成功后。这样可以解决假卖问题，但是会带来超卖问题。设想这样一种场景：大量用户点击购买，已经跳转到第三方支付网站进行支付，因为我们还没有获得支付结果，支付网关不会回调我们的支付完成逻辑，因此不会扣减库存。这样可以让无限的用户进入支付环节。最终如果这些用户全部支付成功显然会导致大量超卖的情况。</p>
<h3>2.3 排队模型</h3>

<p>联系到现实生活的场景，这样的问题最好的办法就是引入排队机制。排在前面的人可以成功购买，后面的人如果没有库存自然无法购买。大家按照时间顺序先后来，如果中间有人放弃，自然有后面的人顶替。这样自然保证了公平，公正。而且也不会出现超卖假卖问题。</p>
<p>这个思路是对的，关键是如何实现的问题。</p>
<h2> 三 实现排队模型</h2>

<p>排队模型里有一个关键问题，就是锁票超时机制。比如我们买电影票，飞机票。都有一个锁票支付机制。超时之后如果没有完成支付则自动释放当前锁定的票资源，重新进入票池给别人购买。这样可以解决占着茅坑不拉屎的问题。</p>
<h3>3.1 单实例模型</h3>

<p>假如是单实例模型，我们可以将发起的请求全部放入一个数组，这个数组的长度就是宝贝数量(微型的意义在于宝贝数量较少，可以保证这里不会占用太多的空间)。启动一个线程，专门处理那些超时或者中途放弃的用户，以便让新用户能及时进入排队购买。但是假如这个线程挂掉或阻塞了，同样会导致假卖的问题。</p>
<p>因此较好的办法就是设置自动超时的缓存，对于超时的用户自动清除，以便让后来的用户可以进入支付环节。这个缓存可以自己实现，也可以使用Guava。</p>
<h3>3.2 多实例分布式模型</h3>

<p>显然对于多实例分布式模型设置本地缓存是行不通的。多实例分布式的话可以借助Redis缓存。但是Redis缓存的超时都是以key为基础的。使用哪种缓存结构可以实现我们的需求？</p>
<p>想来想去只有结合两种模式。Hash和String。使用String存放单个的用户，代表排队位。谁先支付完成谁就买到票。使用Hash统计排队人数。每次加入的时候，先遍历Hash，将因为超时失效的String用户剔除掉，这样就自然释放了资源。</p>
<p>类似于这样：任何一个用户进来必须先获得一张入场券，这个入场券的有效时长是设定的超时时间。如果在这个时间内完成了支付，则购买成功。如果没有支付，则超时后下一名购买者进来的时候自动剔除，同时获得这张券。当一个用户购买成功后，释放这张券。每个用户进来的时候，都要保证当前发放的入场券总量不超过库存剩余总量。当发放的券总量等于库存剩余的时候，后面的人自然提示暂时没有空余票，稍后再试。</p>
<p>这样我们就避免了另外开启线程来清除超时释放库存，也有效地在支付前控制了假卖，在很大几率上避免了超卖。但是存在一个问题，因为每个用户进来我们都要循环遍历一遍缓存，清理超时用户。因此库存不宜过大，否则循环耗时太长，用户体验不太好。</p>
<h2>四 总结和拓展</h2>

<p>对于秒杀模型，可能出现的问题就是假卖和超卖问题。而解决这个问题的办法就是排队和超时机制。如果我们的库存非常大(这样就不需要秒杀了)，在最后库存余量不是很大的情况下如果出现高并发没有排队和超时机制同样会出现超卖和假卖问题。为了保险起见，其实在运营手段上也应该采取一些办法，比如本来总共1000件商品，我只买980件，剩余20件用于补给超卖部分。考虑到用户体验和退款等，宁愿少卖也不多卖。当然这些应该根据具体的业务需求来决定。</p>
<p>假如是库存非常大的情况，我们也可以考虑化大为小。在分布式环境下，将其平均分配，每台实例上卖一部分就将库存消化了。也可以引入大型排队系统和超时回调机制。当超时时自动触发一些业务流程。当然这些实现需要我们自己写很多代码，不能依赖Redis等缓存超时机制了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作上做了几个抢票的活动。其中有一部分抢票活动非常火爆，用户访问量非常大。任何一个系统，只要涉及到高并发，分布式就会变得复杂起来。本文是我对这类问题的一些思考和总结。后面有时间还将分享关于流控模型的一些思考，敬请期待。&lt;br&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="模式设计" scheme="http://wantedonline.cn/tags/%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="高并发" scheme="http://wantedonline.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="分布式" scheme="http://wantedonline.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>周末随笔</title>
    <link href="http://wantedonline.cn/2016/07/23/weekend-article-1/"/>
    <id>http://wantedonline.cn/2016/07/23/weekend-article-1/</id>
    <published>2016-07-23T05:39:10.000Z</published>
    <updated>2016-08-07T15:26:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>生活不是诗，不能活在文艺的情怀里，生活大部分都是在柴米油盐酱醋茶中走过。</p>
<a id="more"></a>
<p>20岁的时候特别喜欢赵雷的歌，而现在25岁，特别喜欢李志的歌~</p>
<p>这5年里，蜕掉了一些稚气，增添了一些责任和想法。满嘴胡言乱语和自我嘲笑中隐藏了一些无人诉说又无人可懂的无奈和辛酸。</p>
<p>留恋一座城市，大部分原因是因为那里有一些人和事吧~</p>
<embed type="video/mp4" allowscriptaccess="always" allowfullscreen="true" wmode="transparent" quality="high" height="480" width="700" src="http://o9z6i1a1s.bkt.clouddn.com/%E6%9D%8E%E5%BF%97%20-%20%E5%85%B3%E4%BA%8E%E9%83%91%E5%B7%9E%E7%9A%84%E8%AE%B0%E5%BF%86.mp4"> 
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活不是诗，不能活在文艺的情怀里，生活大部分都是在柴米油盐酱醋茶中走过。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="心情" scheme="http://wantedonline.cn/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>生活的意义</title>
    <link href="http://wantedonline.cn/2016/07/16/what-is-life-meaning/"/>
    <id>http://wantedonline.cn/2016/07/16/what-is-life-meaning/</id>
    <published>2016-07-16T15:25:18.000Z</published>
    <updated>2016-11-28T14:27:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>我们之所以会去思(zhuang)考(bi)人生或生活,是因为在无聊(alone or lonely?)的生活中总要(xian)找(de)点(dan)乐(teng)子。</p><p> LouisWang </p> <p></p>
</blockquote>
<p>人如果闲下来就会想很多。最近加班稍微少点，难得恢复了正常的周末，才发现我生活最大的娱乐活动竟然是加班了。突然不加班反而觉得生活有一点点枯燥和无聊……想到一个问题，我现在的生活意义是什么？我活着的意义什么？忽然正襟危坐，细思极恐……</p>
<a id="more"></a>
<p>之所以会想这个问题，是因为今天看了一部叫做<a href="https://movie.douban.com/subject/1777612/" target="_blank" rel="external">《阳光小美女》</a>的电影。也许每个人的关注点都不一样。我从这部影片中看到的是生活痛苦的一面，看到的是作为人痛苦的一面。</p>
<p>从生下来开始，痛苦便伴随一生。小时候吃的，穿的，玩的会让人烦恼(即便是出生在富豪家庭也有各种烦恼吧)，入学后各种考试，选拔。长大后，工作，事业，家庭，爱情。总是有太多太多的烦恼。人只要有欲望，就会有痛苦。</p>
<p>但是也因为有了痛苦，才有了快乐。无论是男的，女的，老的，少的，有家庭的，单身狗的，贫穷的，富裕的，上层阶级的，底层劳动人民的，积极的，消极的，异性恋的，同性恋的。只要是人，只要活着。只要有欲望也就会有快乐。生活不可能一直是痛苦的。</p>
<p>我不知道我给别人带来了多大的影响。也不知道给这个社会带来了多大的效应。只希望能平平凡凡过好这一生。</p>
<p>《教父》中的唐.柯里昂作为纽约最大的黑手党，老了心脏病死亡的时候最后一句话是“生活如此美好”。但愿那一天，每个人都能发出这样的感叹~</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;我们之所以会去思(zhuang)考(bi)人生或生活,是因为在无聊(alone or lonely?)的生活中总要(xian)找(de)点(dan)乐(teng)子。&lt;p&gt; LouisWang &lt;/p&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人如果闲下来就会想很多。最近加班稍微少点，难得恢复了正常的周末，才发现我生活最大的娱乐活动竟然是加班了。突然不加班反而觉得生活有一点点枯燥和无聊……想到一个问题，我现在的生活意义是什么？我活着的意义什么？忽然正襟危坐，细思极恐……&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="人生思考" scheme="http://wantedonline.cn/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
      <category term="心情" scheme="http://wantedonline.cn/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
</feed>
