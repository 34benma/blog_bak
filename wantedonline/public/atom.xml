<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术家园</title>
  <subtitle>王诚的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wantedonline.cn/"/>
  <updated>2017-04-09T14:29:11.000Z</updated>
  <id>http://wantedonline.cn/</id>
  
  <author>
    <name>LouisWang</name>
    <email>wantedonline@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单身日记(三)</title>
    <link href="http://wantedonline.cn/2017/04/09/20170409/"/>
    <id>http://wantedonline.cn/2017/04/09/20170409/</id>
    <published>2017-04-09T14:27:54.000Z</published>
    <updated>2017-04-09T14:29:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>9/4/2017  成都  多云</p>
<p>今天想了一个想了很久的问题–我人生的意义到底是什么？</p>
<a id="more"></a>
<p>这个问题以前和朋友探讨过，我们活着到底为了什么？</p>
<p>小时候都写过《我的理想》这样的命题作文，那时自然不知道科学家或者企业家这样的概念意味着什么，可以天马行空乱想一气。上大学时自然变得实际一些，理想自然是找一份喜欢的工作，做喜欢的事情。走入社会后，慢慢会发现，所谓喜欢的工作或者别人眼中不错的工作其实很多时候都觉得没有多大意义。</p>
<p>随着年龄增长，各种压力越来越大。这段时间一直在想房子的事情。明明知道，现在房价是在一个高位，房子的造价远远低于市场的房价。辛辛苦苦舍不得玩，舍不得吃存下钱来，好像就是为了买房，结束那种漂泊感。但是，当真正买了房之后，身上压力更大，成为房奴，生活自然加上了另外一个枷锁。不禁在想，一辈子辛辛苦苦工作就是为了房子和车子？</p>
<p>之所以会去想这些问题，其实还是生活背景和个人所处的社会阶层吧。没有真正的自由平等。也没有真正的公平公开。一个人来到这个世界上，就已经决定了其将来的社会阶层和角色。当然，个人努力也很重要，但是不管怎么努力，能够改变的终究有限，大部分人都是这样吧，少部分人因为各种环境因素使然以及运气，社会，历史潮流，可能一下子从一个阶层跃升到另一个阶层。但这毕竟只是少数。</p>
<p>电影《兰戈》很有意义。关于信仰，关于人生，关于角色有很实际的思考。</p>
<p>其实，我也不知道我的信仰是什么，好像还处于一种迷茫期。不知道那些共产主义战士他们的信仰是否真的是共产主义。</p>
<p>很多时候，都是社会大环境使然。一个人的力量再大，也难以改变社会大环境，最终必须要适应社会大环境才能比较体面的生活下去。</p>
<p>追求一切真正美好的事物，微笑对待生活和世界，影响身边的人，爱每一个善良的人，睡到自然醒，做一道美味佳肴……可能这些美好的东西才是人生的意义吧……</p>
<p>又或者其实人生根本没意义，只是自己强加一些意义而已。</p>
<p>淡然，微笑，开放，拥抱生活就是最大的幸福吧~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;9/4/2017  成都  多云&lt;/p&gt;
&lt;p&gt;今天想了一个想了很久的问题–我人生的意义到底是什么？&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="人生" scheme="http://wantedonline.cn/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="意义" scheme="http://wantedonline.cn/tags/%E6%84%8F%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>单身日记(二)</title>
    <link href="http://wantedonline.cn/2017/04/09/20170408/"/>
    <id>http://wantedonline.cn/2017/04/09/20170408/</id>
    <published>2017-04-08T16:10:21.000Z</published>
    <updated>2017-04-08T16:11:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>8/4/2017   成都 晴</p>
<p>晚饭过后，喜欢一个人插着耳机听着逼哥的歌漫无目的地走路。就这样一直走一直走…这是最近养成的一种放松方式了，我非常喜欢。</p>
<a id="more"></a>
<p>逼哥的歌总是百听不厌。不知道为什么，虽然逼哥的歌确实写的很俗，有些作品甚至还带有Color和anti-society，但听起来却感觉很舒服。</p>
<p>只是觉得他的旋律，他的歌词确实产生了共鸣吧。算不上消极和愤世，而是虽然知道世界，社会是这样，但依然不改变那份意志，不同流合污，也不自暴自弃地苟且地活着的顽强吧。感觉这确实很逼哥。</p>
<p>一个人静静地漫无目的地走着，心情是非常平静的。反思过去，思考未来。</p>
<p>过去的错误和心高气傲都是今后的成熟稳重所必须的铺垫吧。未来会怎样依然不可期。过去的错过和辜负自然无可挽回。</p>
<p>忽然感觉自己异常的孤独。无人可以倾诉，无人可以依赖，无人理解自己的孤独……</p>
<p>也许还将永远孤独下去……毕竟，人，终将孤独地走完人生的旅程……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;8/4/2017   成都 晴&lt;/p&gt;
&lt;p&gt;晚饭过后，喜欢一个人插着耳机听着逼哥的歌漫无目的地走路。就这样一直走一直走…这是最近养成的一种放松方式了，我非常喜欢。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="孤独" scheme="http://wantedonline.cn/tags/%E5%AD%A4%E7%8B%AC/"/>
    
      <category term="逼哥" scheme="http://wantedonline.cn/tags/%E9%80%BC%E5%93%A5/"/>
    
  </entry>
  
  <entry>
    <title>单身日记(一)</title>
    <link href="http://wantedonline.cn/2017/04/02/20170402/"/>
    <id>http://wantedonline.cn/2017/04/02/20170402/</id>
    <published>2017-04-02T15:43:56.000Z</published>
    <updated>2017-04-02T15:48:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>2/4/2017       成都     多云</p>
<p>今天是清明假期第一天，无所事事，宅在家里学习前端技术，练习吉他，但是学习效率却不怎么高。平淡无奇，两点一线的生活似乎永远是这样波澜不惊。</p>
<a id="more"></a>
<p>年纪不小，却依然孤身一人。忽然很想总结和反思自己，通过不定期写日记的方式来记录吧。也许会永久地孤独下去，也许有幸会遇到理想的对象。不管怎样，以这种形式记录现在的生活状态。一来让自己内心更加平静，二来借此抒发自己内心的苦闷吧。</p>
<p>自从独自一人踏入社会后，交际圈变得更加窄了。性格慢慢变得内向，少言了。已经记不清上一次发自内心开怀大笑是什么时候，因为什么事情了。最近一次伤心流泪好像还是9年前爷爷去世而我却是最后一个知道的时候了。</p>
<p>生活，就是这样平淡无奇，波澜不惊。没有太多让自己开怀大笑的乐事，也似乎没有真正感到永久失去而痛哭流泪的人或事。很少请假，来了成都后也很少加班。每天重复着上班，做饭，睡觉，宅的生活。偶尔朋友小聚，偶尔和父母吵吵嘴皮子。现在想想，我的生活真是一潭死水。</p>
<p>但是……</p>
<p>即便认识到了我的生活是一潭死水，我也无能为力。心中有很多想法，想去认识这个世界，想去认识更多的人，想去体验一些不一样的生活。但是目前的生活条件和社会角色，我无法改变，也不敢去改变。</p>
<p>意识到心中依然有很多想法，但却因为生活的枷锁而无法动弹的时候，可能就是开始慢慢变老的时候了吧。</p>
<p>无法感叹生活的无奈和无趣。可能一切的一切只是因为自己能力还没达到一个高度，生活阅历还没达到一个层次罢了吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2/4/2017       成都     多云&lt;/p&gt;
&lt;p&gt;今天是清明假期第一天，无所事事，宅在家里学习前端技术，练习吉他，但是学习效率却不怎么高。平淡无奇，两点一线的生活似乎永远是这样波澜不惊。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="单身日记" scheme="http://wantedonline.cn/tags/%E5%8D%95%E8%BA%AB%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>记CentOS 7防火墙配置遇到的坑</title>
    <link href="http://wantedonline.cn/2017/02/26/20170225/"/>
    <id>http://wantedonline.cn/2017/02/26/20170225/</id>
    <published>2017-02-25T17:08:36.000Z</published>
    <updated>2017-02-25T17:10:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>今晚打算在空闲的机器上搭一个jenkins玩一玩，结果搞了半天，本地能访问jenkins，但是同一个局域网远程访问就是不行。最后发现原来是防火墙配置的问题。</p>
<p>第一个玩这个东西，很多知识都只能靠度娘(吐槽一下度娘搜索质量之低以及中文技术文章重复率之高)，搞半天都是有关iptables的配置。但是在我机器上，虽然有iptables命令，但是就是没有/etc/sysconfig/iptables这个文件。 搞了两个小时才发现，原来CentOS 7 已经弃用了iptables做防火墙，而改用firewalld了。</p>
<a id="more"></a>
<p>记录一些关于firewalld一些重要设置命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</div></pre></td></tr></table></figure>
<p>打开8080端口，–zone表示作用域，–permanent表示永久生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart firewalld.service</div></pre></td></tr></table></figure>
<p>重启防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl status firewalld</div></pre></td></tr></table></figure>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --state</div></pre></td></tr></table></figure></p>
<p>查看状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl disable firewalld</div></pre></td></tr></table></figure>
<p>停止防火墙,将 disable换成stop就是禁用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --reload</div></pre></td></tr></table></figure>
<p>更新防火墙规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --set-default-zone=public</div></pre></td></tr></table></figure>
<p>设置默认接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd -zone=dmz --list-ports</div></pre></td></tr></table></figure>
<p>查看所有打开的端口</p>
<p>因此我只需要开启8080端口，然后重启服务就好。</p>
<p>如果这招不管用，就直接上大招，去掉全部防火墙规则即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -F</div></pre></td></tr></table></figure>
<hr>
<p><em>参考文献</em></p>
<ol>
<li><a href="http://www.cnblogs.com/archoncap/p/5402983.html" target="_blank" rel="external">Centos 7防火墙firewalld开放80端口</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今晚打算在空闲的机器上搭一个jenkins玩一玩，结果搞了半天，本地能访问jenkins，但是同一个局域网远程访问就是不行。最后发现原来是防火墙配置的问题。&lt;/p&gt;
&lt;p&gt;第一个玩这个东西，很多知识都只能靠度娘(吐槽一下度娘搜索质量之低以及中文技术文章重复率之高)，搞半天都是有关iptables的配置。但是在我机器上，虽然有iptables命令，但是就是没有/etc/sysconfig/iptables这个文件。 搞了两个小时才发现，原来CentOS 7 已经弃用了iptables做防火墙，而改用firewalld了。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发日常" scheme="http://wantedonline.cn/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="Linux" scheme="http://wantedonline.cn/tags/Linux/"/>
    
      <category term="防火墙配置" scheme="http://wantedonline.cn/tags/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"/>
    
      <category term="运维" scheme="http://wantedonline.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>孤独随感</title>
    <link href="http://wantedonline.cn/2017/02/12/20170212/"/>
    <id>http://wantedonline.cn/2017/02/12/20170212/</id>
    <published>2017-02-12T12:55:03.000Z</published>
    <updated>2017-02-12T13:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o9z6i1a1s.bkt.clouddn.com/lonely.jpg" alt=""></p>
<p>不小心划破了手指，必须单手洗几天碗了。估计这两天不可避免地要吃点脏东西了，好在这些脏碗都是我一个人吃的。也还好~<br>一个人漂泊在外面，要是有家人或者有个对象多好啊。这时候可以有人可以依赖。</p>
<a id="more"></a>
<p>孤独应该分三层境界，对应三层修炼。</p>
<p>第一层境界，是物理层面的孤独，是外部世界的孤独。喜欢热闹，害怕独处。一旦一个人的时候，心里患得患失。不能集中注意力做好一件事情。刚从象牙塔走入社会的青年人，必然会经历这个阶段吧。</p>
<p>第二层境界，开始进入心理层面孤独，更多的是思想上，精神上的孤独。即便是一群人的狂欢，也是别人的狂欢。早已经习惯一个人吃饭，一个人睡觉，一个人逛超市，一个人看电影，甚至一个人做手术……</p>
<p>这个境界的孤独，总是难以把控好情绪。明明不喜欢这样的状态，却总是无法逃脱这样的状态。情绪忽好忽坏。好的时候很享受这种孤独，一个人听歌，一个人看电影，一个人做好吃的，一个人学习各种新的知识，一个人挑战全世界，但是也有不好的时候。不好的时候会特别自卑，情绪极其低落。仿佛看透世事，了却红尘。只想遁入空门。没有任何事情可以勾起自己的情绪了。这种好坏的情绪总是波浪式起伏，不会一直好，也不会一直坏。</p>
<p>第三层境界，是一个理想的境界。也是精神上和思想上的孤独。</p>
<p>这个世界上没有两片相同的树叶，也没有两个一样思想的人。有时候明明是最亲近的人，却是最不懂自己的人。</p>
<p>人生苦短，知己难求~</p>
<p>修炼到第三种境界，自然心如止水了吧。不以物喜，不以己悲。早已看破红尘，了却世俗的欲望。</p>
<p>学会了享受孤独，应该就慢慢变成了世俗人眼中的成熟吧。</p>
<p>孤独，会让人从喜欢热闹慢慢变得喜欢安静；会让人从喜欢争辩变得喜欢沉默；会让人从一个愤青变得看透世事，遵守规则。</p>
<p>曾经看过一篇文章，大意是讲学会享受孤独是人最重要的能力。每个人都在逃离孤独，但是似乎没有人能够逃离孤独。</p>
<p><img src="http://o9z6i1a1s.bkt.clouddn.com/qrcode_for_gh_71949902d944_258.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o9z6i1a1s.bkt.clouddn.com/lonely.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不小心划破了手指，必须单手洗几天碗了。估计这两天不可避免地要吃点脏东西了，好在这些脏碗都是我一个人吃的。也还好~&lt;br&gt;一个人漂泊在外面，要是有家人或者有个对象多好啊。这时候可以有人可以依赖。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="孤独" scheme="http://wantedonline.cn/tags/%E5%AD%A4%E7%8B%AC/"/>
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>再见，2016！你好，2017</title>
    <link href="http://wantedonline.cn/2016/12/30/20161230/"/>
    <id>http://wantedonline.cn/2016/12/30/20161230/</id>
    <published>2016-12-30T12:29:01.000Z</published>
    <updated>2016-12-30T12:32:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><br>伪文艺青年的年终总结<br></blockquote>

<p><img src="http://o9z6i1a1s.bkt.clouddn.com/2017-b.jpg" alt=""></p>
<a id="more"></a>
<p>坐在电脑前，思来想去，也不知道过去的一年到底做了些什么。就这样浑浑噩噩一年就过了。</p>
<p>马上就26了，想想30也快了。每每想到30岁的情景，就不由得心头一紧。原来自己也害怕年老啊。已经不再是叫做长大了，而是叫做变老了。</p>
<p>过去的一年也做了一点点事情吧。</p>
<p>工作和技术发展上</p>
<ul>
<li>深入学习了Java并发，JVM</li>
<li>对大型Web系统架构和关键技术比较熟悉了</li>
<li>对待工作更加平和，更加严谨一些了</li>
<li>明确了今后的职业发展路线和技术路线</li>
</ul>
<p>生活上</p>
<ul>
<li>最重大的变化就是择城而居了，虽然依然是背井离乡。</li>
<li>好像没有了，依然单身，依然喜欢独处，依然不善于交际</li>
</ul>
<p>工作上，还算平稳中进步吧。生活上，依然是个loser。</p>
<p>2017，估计也不会有太大的变化吧。</p>
<p>今年能做好三件事情就很不错了。</p>
<ol>
<li>把自己的开源项目<a href="https://github.com/34benma/Puppy" target="_blank" rel="external">Puppy</a>做好；</li>
<li>参与其他有益的项目，往架构师方向努力；</li>
<li>Open，Open，Open. 周末能多多参加有益的活动吧，不要再这样把自己固定在一个地方了。</li>
</ol>
<p>希望2017，在这三个事情上，能有所收获~</p>
<hr>
<p>我也玩一把微信公众号吧，不知道自己能不能坚持下去。<img src="http://o9z6i1a1s.bkt.clouddn.com/qrcode_for_gh_71949902d944_258.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;br&gt;伪文艺青年的年终总结&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://o9z6i1a1s.bkt.clouddn.com/2017-b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="年终总结" scheme="http://wantedonline.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JDK中Collections的shuffle函数</title>
    <link href="http://wantedonline.cn/2016/12/27/20161227/"/>
    <id>http://wantedonline.cn/2016/12/27/20161227/</id>
    <published>2016-12-27T13:02:03.000Z</published>
    <updated>2016-12-27T13:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作上做了一个随机化的需求。类似于洗牌，需要将一个原本有序的东西打乱然后顺序取出元素。一开始我以为要自己写随机算法，后面发现JDK库中Collections提供了一个shuffle函数，就是干这个事情的。特地研究了一下这个算法的实现。</p>
<a id="more"></a>
<p>洗牌函数的一些基本要求：</p>
<ul>
<li>元素数量有限</li>
<li>每个元素出现在某个位置的概率都为1/n (n为元素总量)</li>
<li>每次洗牌都是一个独立的事件</li>
</ul>
<p>基于上面的三个要求，我们希望洗牌函数时间复杂度和空间复杂度都能尽量最好。具体如何实现呢？</p>
<h2>Collections的shuffle原理</h2>

<p>Collections的shuffle函数时间复杂度和空间复杂度都是O(n)，性能较为优越。基本原理是这样的，遍历一遍集合，每一次迭代都将迭代的位置和一个随机的元素交换，因此这里关键在于如何选取随机元素下标。</p>
<p>shuffle是这样处理的。每次以迭代的下标作为上界，保证每次随机数不超过下标即可。这样就保证了已经迭代过的元素位置固定不变，只随机交换未迭代的元素，从而实现了每个元素在某个位置的概率都是1/n(n为元素总量)。每次调用该函数，自然都是一个独立的事件。因为不会因为初始元素排列的情况而影响到随机的结果。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list, Random rnd)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> size = list.size();</div><div class="line">    <span class="keyword">if</span> (size &lt; SHUFFLE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</div><div class="line">            swap(list, i-<span class="number">1</span>, rnd.nextInt(i));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Object arr[] = list.toArray();</div><div class="line"></div><div class="line">        <span class="comment">// Shuffle array</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</div><div class="line">            swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</div><div class="line"></div><div class="line">        <span class="comment">// Dump array back into list</span></div><div class="line">        <span class="comment">// instead of using a raw type here, it's possible to capture</span></div><div class="line">        <span class="comment">// the wildcard but it will require a call to a supplementary</span></div><div class="line">        <span class="comment">// private method</span></div><div class="line">        ListIterator it = list.listIterator();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</div><div class="line">            it.next();</div><div class="line">            it.set(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要说明的是，第一个if语句。SHUFFLE_THRESHOLD的值默认是5，这个值不可以更改。作用是当list元素小于5个时，直接交换，如果大于5个而且不支持随机访问，比如链表或hash等，则先将其转换成数组，支持随机访问。因为链表这种数据结构不支持随机访问。如果直接交换元素位置的话，时间复杂度将非常高。</p>
<p>如果list支持随机访问，当然直接交换元素位置即可。否则转成数组之后再交换随机位置。</p>
<h2>总结</h2>

<p>一个看似有点复杂的逻辑，其实原理和实现都非常简单。关键在于随机位置的选取。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作上做了一个随机化的需求。类似于洗牌，需要将一个原本有序的东西打乱然后顺序取出元素。一开始我以为要自己写随机算法，后面发现JDK库中Collections提供了一个shuffle函数，就是干这个事情的。特地研究了一下这个算法的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术" scheme="http://wantedonline.cn/categories/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="基础技术" scheme="http://wantedonline.cn/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
      <category term="洗牌算法" scheme="http://wantedonline.cn/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>无他,先占个坑</title>
    <link href="http://wantedonline.cn/2016/12/18/20161218/"/>
    <id>http://wantedonline.cn/2016/12/18/20161218/</id>
    <published>2016-12-18T14:26:24.000Z</published>
    <updated>2016-12-18T14:28:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作上做了一个随机化的需求。类似于洗牌，需要将一个原本有序的东西打乱然后取元素。一开始以为要自己写随机算法，后面发现JDK库中Collections提供了一个shuffle函数，就是干这个事情的。</p>
<a id="more"></a>
<p>嗯，计划好好研究下这个算法。先占个坑，等我研究透了再分享。之所以现在写这个东西在这里，原因有二，一是提醒自己还有件事情没做完，拖延症晚期<del>~二是12月份还有一个指标没有完成</del>无他~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作上做了一个随机化的需求。类似于洗牌，需要将一个原本有序的东西打乱然后取元素。一开始以为要自己写随机算法，后面发现JDK库中Collections提供了一个shuffle函数，就是干这个事情的。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="乱七八糟" scheme="http://wantedonline.cn/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"/>
    
      <category term="拖延症" scheme="http://wantedonline.cn/tags/%E6%8B%96%E5%BB%B6%E7%97%87/"/>
    
  </entry>
  
  <entry>
    <title>你到现在还找不到对象，一定是很&#39;挑&#39;吧</title>
    <link href="http://wantedonline.cn/2016/12/11/20161211/"/>
    <id>http://wantedonline.cn/2016/12/11/20161211/</id>
    <published>2016-12-11T07:08:13.000Z</published>
    <updated>2016-12-11T07:09:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>莫名奇妙被人说眼光高，到现在都找不到对象。一定是太’挑’了。</p>
<p>程序员因为职业关系，人际关系简单，做技术的基本都是汉子。加上做技术的基本跟木纳，宅能联系起来。因此单身率居高不下自然而然就是很正常的了。</p>
<a id="more"></a>
<p>所谓的’挑’,也许只是一种追求完美的心理。但是自己本来就不完美，自然没有想过一定要十全十美了。</p>
<p>所谓的’挑’,也有可能只是把一些条条框框看的太重要了，以致忽略了对方其他闪亮或者压根都不想去看其他闪亮的地方了~</p>
<p>一直觉得人与人交往能否深入下去的根基是是否有相似的三观。这是聊得来的基础。只有聊得来才能感觉到愉快和幸福。恋人是这样的，朋友也是~当然，不一定三观相近，有相同的人生理想的人一定可以聊的来。也是讲究方法和技巧的。更重要的是还需要耐心和善解人意~这也是高情商的一个方面吧~</p>
<p>三观不一致也不一定不能够共同生活下去。不过需要更多的理解，需要更多的发现对方的闪光点，从而放小那些自己觉得很在乎的东西的重要性~</p>
<p>我不’挑’,从没有把外貌，身高，身材，年龄，学历作为唯一的依据。只是接触面比较窄，没有遇到懂得欣赏自己的人而已~~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;莫名奇妙被人说眼光高，到现在都找不到对象。一定是太’挑’了。&lt;/p&gt;
&lt;p&gt;程序员因为职业关系，人际关系简单，做技术的基本都是汉子。加上做技术的基本跟木纳，宅能联系起来。因此单身率居高不下自然而然就是很正常的了。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="胡言乱语" scheme="http://wantedonline.cn/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>我想做一个后端服务器</title>
    <link href="http://wantedonline.cn/2016/12/09/20161209/"/>
    <id>http://wantedonline.cn/2016/12/09/20161209/</id>
    <published>2016-12-09T11:50:45.000Z</published>
    <updated>2016-12-09T11:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>从上一家公司莫名其妙离职后(是的，对于不可言说的事情我都是用莫名其妙，乱七八糟这样的词汇形容~~~)进入新公司，主力还是做后端服务器API开发，这也是我一直感兴趣的方向。目前我们的技术框架主体是Tomcat+Spring+SpringMVC+Redis+MySQL。<br>估计，这也是大多数互联网公司所采用的技术框架。因为开源，好用~</p>
<p>这个技术框架和我上一家(上家技术就是*雷的技术)基本类似，不过服务器和技术架构还是差别挺大。两个关键区别是Netty框架VSTomcat容器，动静分离，前后端分离VS动静结合，前后端结合。结合我在新公司上手项目和上一家上手项目的速度以及软件架构设计和项目运维的实际情况，我萌发了想做一款后端服务器的想法。</p>
<a id="more"></a>
<h2>动静分离,前后端分离</h2>

<p>动静分离指的是Web项目中动态资源和静态资源的分离。所谓动态资源我理解就是逻辑数据。比如说一个游戏排行榜，排行榜的数据是动态更新的，但是排行榜的样式是固定不变的。这些样式是由图片，HTML，JS，CSS等构成。而数据的产生就是服务器的逻辑代码经过逻辑运算最终产生。分离就是要分离这些东西。这里动态数据的产生就需要后端程序员来提供，而HTML，JS，CSS等各种样式，动态展现效果等的实现是前端工程师，重构工程师，UI设计师等共同实现。</p>
<p>因此动静分离带来的结果就是前后端分离。后端工程师只要懂后端，不需要调界面，写JS了。前端工程师只要做效果，和用户交互，不需要考虑数据的来源以及正确性了。</p>
<p>前后端交互则通过HTTP请求，数据表现形式通常是JSON。有的也用XML，但我觉得JSON性能和易用性上明显要高于XML。</p>
<h2>Tomcat可以实现动静分离，前后端分离吗？</h2>

<p>我觉得答案是可以，必须可以。Tomcat是一个非常优秀的Servlet容器。无论从设计上还是代码编写上(曾经深入读过Tomcat大部分源码)都是一个非常优秀的容器(其作者也是Struts的作者，因此设计思想上有些类似，但是Struts现在基本没人用了，Tomcat作为服务器还在被大量使用)。但是Tomcat也仅仅是个Servlet容器。它提供的组件式，可插入式的设计思想非常灵活。</p>
<p>但灵活带来的代价我认为是复杂性。Tomcat的配置还是比较麻烦的。默认的HTTP请求处理模式是BIO，如果使用NIO需要专门的配置。同时，随着项目的体积增大，启动Tomcat和调试程序都变成了一件非常复杂需要很多耐心的事情。因此，从项目入手和项目维护简易上来说，Tomcat做的比较糟糕。</p>
<h2>一切回归main</h2>

<p>main函数是一切程序启动的入口。因为Tomcat帮我们把main函数(在Tomcat的Bootstrap类里)写了。因此我们Web程序的代码实际上都是逻辑代码。一坨我们不需要写入口的代码。Tomcat为什么叫做容器？从这里也可以找到一点点依据。所有类的加载和执行我们都控制不了。如果一个程序需要我们手动来写main函数，给我们的感觉是我们在控制程序的入口，那么我们的逻辑代码就不再是被放到容器中来了。我们的项目也不在需要是一个标准的Java Web项目，而是一个标准的Java项目。因此，回归到main，将更加容易理解并调试项目。</p>
<h2>NIO框架</h2>

<p>NIO框架里两个非常优秀的框架是Netty和Mina。Mina暂时还没研究过。因为工作经历的关系，研究过Netty。Netty作为一个非常优秀的NIO框架让我们编写一个基于NIO的服务器变得非常简单。特别是Netty4在Netty3基础上对线程模型的改进。因此基于Netty4编写一个后端服务器，应该是有非常良好的IO处理性能和并发处理性能。</p>
<h2>我为什么想做一个后端服务器？</h2>

<p>因为种种乱七八糟的原因，上一家自研的服务器框架没有开源出来造福广大后端服务器程序员。因此有上一家公司的工作经历后，加上Tomcat和SpringMVC给程序员以及项目开发速度上带来的问题，我觉得做一个高性能，高可靠的易用的后端服务器是一件非常有意义的事情。基于我对Netty4和上家公司后端服务器框架的理解，加上我自己在项目开发和管理中遇到的一些痛点，我决定写一个后端服务器。</p>
<p>这个服务器原始的需求基本和上一家公司的很类似(不得不赞叹*雷技术实力和前瞻性，这款服务器开发于2010年，有些理念最近才逐渐火起来)。但是，我不会直接引用。最大的区别是Netty版本的区别。我将废弃Netty3，使用Netty4。</p>
<p>它要达到的目标是让动静分离变得极其简单，让后端程序员专注做后端，专注在高性能，可靠性，可拓展性等问题上，前端程序员专注在极好的用户体验和正确的用户数据上。</p>
<p>最重要的是，它要实现项目的极快速开发和高质量，高可靠性。软件开发相关专业的毕业生能够在一周内上手项目并且能写出高质量的逻辑代码。因为框架屏蔽了Spring,SpringMVC，Redis,MySQL等一些部署和使用细节。真正实现后端程序员只要关注BO和DAO，并且设计良好的数据模型即可。</p>
<p>这就是我想做的~目前已经有一个良好的开始。</p>
<p>我把项目名字取名Puppy。可爱的小狗的意思。感兴趣的同学可以<a href="mailto:wantedonline@outlook.com" target="_blank" rel="external">联系我</a>，一起做这个还算有意义的事情。目前我正在做<a href="https://github.com/34benma/Puppy/blob/master/doc/puppy_plan" target="_blank" rel="external">V0.4.0</a></p>
<p>项目地址: <a href="https://github.com/34benma/Puppy" target="_blank" rel="external">https://github.com/34benma/Puppy</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从上一家公司莫名其妙离职后(是的，对于不可言说的事情我都是用莫名其妙，乱七八糟这样的词汇形容~~~)进入新公司，主力还是做后端服务器API开发，这也是我一直感兴趣的方向。目前我们的技术框架主体是Tomcat+Spring+SpringMVC+Redis+MySQL。&lt;br&gt;估计，这也是大多数互联网公司所采用的技术框架。因为开源，好用~&lt;/p&gt;
&lt;p&gt;这个技术框架和我上一家(上家技术就是*雷的技术)基本类似，不过服务器和技术架构还是差别挺大。两个关键区别是Netty框架VSTomcat容器，动静分离，前后端分离VS动静结合，前后端结合。结合我在新公司上手项目和上一家上手项目的速度以及软件架构设计和项目运维的实际情况，我萌发了想做一款后端服务器的想法。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发" scheme="http://wantedonline.cn/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="服务器开发" scheme="http://wantedonline.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="Netty" scheme="http://wantedonline.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>不要随便升级系统</title>
    <link href="http://wantedonline.cn/2016/12/06/20161206/"/>
    <id>http://wantedonline.cn/2016/12/06/20161206/</id>
    <published>2016-12-06T14:04:08.000Z</published>
    <updated>2016-12-09T11:55:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>我总是喜欢用最新稳定版的软件，操作系统也一样。今晚将Mac OS升级到了最新的10.12.1，花费了大约15分钟，没想到的是这次这个所谓的Release版本对开发者似乎不太友好。</p>
<a id="more"></a>
<p>升级之后，发现我的博客工程hexo不能正常使用了。发现原来是node.js自动没了。当时也没有检查是否是path失效了，直接到node.js下载了稳定版本6.2安装了，然后又安装hexo。结果发现现在每次运行hexo命令，将报如下异常。</p>
<p><img src="http://o9z6i1a1s.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-06%2022.04.22.png" alt=""></p>
<p>虽然不影响正常使用，但是作为error零容忍的强迫症患者，总是感觉不舒服。</p>
<p>查了一下，原来是node.js版本太高导致。OMG…. <a href="http://stackoverflow.com/questions/37507140/nodejs-error-module-version-mismatch-expected-48-got-46" target="_blank" rel="external">查询依据</a></p>
<p>想起了以前项目开发环境迁移，升级了MySQL版本，结果导致编码出问题，对于上100G的数据简直是个噩梦。</p>
<p>软件运维还真不是一件容易的事情。新版本的发布需要考虑太多兼容的问题~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我总是喜欢用最新稳定版的软件，操作系统也一样。今晚将Mac OS升级到了最新的10.12.1，花费了大约15分钟，没想到的是这次这个所谓的Release版本对开发者似乎不太友好。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发日常" scheme="http://wantedonline.cn/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="软件日常" scheme="http://wantedonline.cn/tags/%E8%BD%AF%E4%BB%B6%E6%97%A5%E5%B8%B8/"/>
    
      <category term="Hexo异常" scheme="http://wantedonline.cn/tags/Hexo%E5%BC%82%E5%B8%B8/"/>
    
      <category term="系统升级" scheme="http://wantedonline.cn/tags/%E7%B3%BB%E7%BB%9F%E5%8D%87%E7%BA%A7/"/>
    
      <category term="软件运维" scheme="http://wantedonline.cn/tags/%E8%BD%AF%E4%BB%B6%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>镜头下的所思</title>
    <link href="http://wantedonline.cn/2016/11/12/20161112-2/"/>
    <id>http://wantedonline.cn/2016/11/12/20161112-2/</id>
    <published>2016-11-12T10:19:51.000Z</published>
    <updated>2016-11-12T10:21:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015年某个阳光明媚的周末摄于深圳莲花山公园。当时发表在QQ空间，今天偶然发现，这是目前为止我摄影天赋表现得最高的一次了(其实是这之后就没拿起过相机拍过照了。。没时间，没心情)。特地转到个人博客发表。关于照片中水印是’PHOTO TAKED BY JACKWANG’ 中的JackWang就是LouisWang，16年前的英文名。后面在好朋友的建议下改成了LouisWang。</p>
<a id="more"></a>
<p><img src="http://o9z6i1a1s.bkt.clouddn.com/1.jpg" alt="1"><br><img src="http://o9z6i1a1s.bkt.clouddn.com/2.jpg" alt="2"><br><strong>漫漫人生路</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/3.jpg" alt=""><br><strong>有时候，我们根本看不到前方是什么，即便如此，也只能往前，因为别无选择</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/4.jpg" alt=""><br><strong>当选择真正来临的时候，反而会辗转反侧</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/5.jpg" alt=""><br><strong>因为前方的路，总是有些模糊和不安</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/6.jpg" alt=""><br><strong>别急，走下去，总有一天，会慢慢清晰</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/7.jpg" alt=""><br><strong>累了的时候，可以休息一下，既然选择远方，便要风雨兼程</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/8.jpg" alt=""><br><img src="http://o9z6i1a1s.bkt.clouddn.com/9.jpg" alt=""><br><strong>前进的过程中，有可能会碰到志同道合的同伴</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/10.jpg" alt=""><br><strong>也可能是独自一人</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/11.jpg" alt=""><br><strong>但不管怎样，坚持下去，最后都会看到别样的风景</strong><br><strong>只是有时候，我们以为自己是第一个</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/12.jpg" alt=""><br><strong>其实，早就有人比你先登上峰顶</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/13.jpg" alt=""><br><strong>但是，那又怎样？我看到的是我的世界里的风景</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/14.jpg" alt=""><br><strong>在前进的道路上，有时需要指引，才不至于迷失自己</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/15.jpg" alt=""><br><strong>有的指引，就是一盏路灯，照亮了前进的道路</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/16.jpg" alt=""><br><strong>瞬间，前面的路变得宽敞又明亮</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/17.jpg" alt=""><br><strong>你站在桥上看风景，看风景的人在楼上看你</strong><br><strong>羡慕别人的时候，殊不知自己也被人羡慕</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/18.jpg" alt=""><br><strong>有时，我们会遇到这样的人</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/19.jpg" alt=""><br><strong>有时，不能相信自己的眼睛</strong><br><strong>因为，有时自己都不知道谁应该被帮助</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/20.jpg" alt=""><br><strong>坚持走下去，人生，就是一个自我完善的过程……</strong><br>————华丽的分割——————<br><img src="http://o9z6i1a1s.bkt.clouddn.com/21.jpg" alt=""><br><strong>再见，小时候</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/22.jpg" alt=""><br><strong>别总是工作，不要辜负阳光和青草</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/23.jpg" alt=""><br><strong>年轻，真好。青春，真好！</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/24.jpg" alt=""><br><strong>噢，你到底爱不爱我~</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/25.jpg" alt=""><br><img src="http://o9z6i1a1s.bkt.clouddn.com/26.jpg" alt=""><br><img src="http://o9z6i1a1s.bkt.clouddn.com/27.jpg" alt=""><br><strong>人生，最满足的事情莫过于和好哥们一起，把兴趣当成谋生</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/28.jpg" alt=""><br><strong>幼有所养，老有所依</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/29.jpg" alt=""><br><img src="http://o9z6i1a1s.bkt.clouddn.com/30.jpg" alt=""><br><strong>无论我们飘多远，总有一条线拉着</strong><br><img src="http://o9z6i1a1s.bkt.clouddn.com/31.jpg" alt=""><br><img src="http://o9z6i1a1s.bkt.clouddn.com/32.jpg" alt=""><br><strong>有故事有意思的大爷，他说，我喜欢满世界拉琴~~~</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015年某个阳光明媚的周末摄于深圳莲花山公园。当时发表在QQ空间，今天偶然发现，这是目前为止我摄影天赋表现得最高的一次了(其实是这之后就没拿起过相机拍过照了。。没时间，没心情)。特地转到个人博客发表。关于照片中水印是’PHOTO TAKED BY JACKWANG’ 中的JackWang就是LouisWang，16年前的英文名。后面在好朋友的建议下改成了LouisWang。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="摄影" scheme="http://wantedonline.cn/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="人生思考" scheme="http://wantedonline.cn/tags/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C概述</title>
    <link href="http://wantedonline.cn/2016/11/12/20161112/"/>
    <id>http://wantedonline.cn/2016/11/12/20161112/</id>
    <published>2016-11-12T09:04:22.000Z</published>
    <updated>2016-11-12T09:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇基本说的是并发理论性的东西。除了很简单的介绍了一下synchonized和volatile两个关键字。从本篇开始，还是继续介绍一些理论性的东西。不过这些理论上的东西不同于前面。而是实实在在的工具类。</p>
<p>J.U.C是java.util.concurrent.*的简写。从JDK 1.5开始，JDK开始提供了一个专门用于简化并发编程的工具包，这个工具包就是J.U.C。</p>
<a id="more"></a>
<p>业界有一句话说’并发不知<a href="http://g.oswego.edu" target="_blank" rel="external">Doug Lea</a>，学尽Java也枉然’。事实上，J.U.C的整个设计以及中间很多类的编写都是Doug Lea。上面链接是他的主页。他还编写了一本书叫做<java并发编程实践>.这本书对于Java程序员研究并发编程的理论与实践绝对帮助很大。</java并发编程实践></p>
<h2>Executors类</h2>

<p>这个包主要提供了一些线程池的工具类。事实上，创建线程和销毁线程都是一些消耗比较大的操作。因此J.U.C提供了这样一些类来简化线程的创建和销毁以及管理。主要有这么四中线程池：newCachedThreadPool，可缓存的线程池。它的用法是当我们希望创建的线程使用完之后不要马上销毁，可以给下一个任务去使用。因此可以将这些线程缓存起来重用。这样就节省了线程频繁创建于销毁带来的开支；newFixedThreadPool，固定大小的线程池。如果我们的任务数固定，而且可以确定线程数量使用这种线程池就比较好。不会有资源的浪费；newScheduledThreadPool，可调度的线程池。有一些任务我们希望在某个时间点或者某种频率触发，就可以使用这种线程池；newSingleThreadExecutor,单个线程的线程池。这种线程池一般用于任务数比较少，可以固定一个线程来执行。生产实践中我个人还是很少用到。</p>
<p>跟线程池相关的自然是任务。J.U.C简化了我们创建和销毁以及管理线程的步骤，我们要做的只是将可以并行化的部分抽象出任务，写好task类即可。而task又可以带返回值和不带返回值。这些是通过Future等类实现。同时，在这个Executors框架里还提供了ForkJoin机制的实现类，用于工作窃取机制算法的实现。关于这个算法的原理，可以参考这个<a href="http://ifeve.com/fork-join-1/" target="_blank" rel="external">文档</a>。涉及到线程池，涉及到任务，自然就会牵扯到很多东西，比如任务队列，优先级，启动和中断等。这些都定义在Executors这个框架里。</p>
<h2>并发集合类</h2>

<p>J.U.C提供了非常丰富的线程安全的集合类。比如队列，Map,List等数据结构。其中生产实践中用的最多的恐怕是ConcurrentHashMap了。这个类型的Map的详细介绍后面会有。它是一个线程安全的HashMap，但是性能比直接用HashTable或者同步化包装的HashMap高很多。原因需要看这个类的实现才能理解。根据不同的适用场景，提供了非常丰富的集合类供程序员适用。</p>
<h2>原子信号量工具类</h2>

<p>锁，信号量等在Java代码层面实现了。而且J.U.C提供的Lock类更加灵活，据说性能已经开始超过synchonized等关键字了。同时提供了一些信号量用于实现一些比如流控或者自定义锁等功能。</p>
<h2>原子基本类</h2>

<p>对于int,long，double等一些基本类，提供了一些对应的原子类的实现。这些类的线程安全保证是通过无锁化的CAS操作实现的。详细的后面的文章也会介绍。</p>
<p>同时还有一些比如TimeUnit等工具类。</p>
<h2>总结</h2>

<p>J.U.C给Java程序员实现并发编程带来了极大的便利，因为并发编程本来就是一项比较复杂难以测试的事情，因此虽然J.U.C已经最大程度上简化了程序员的工作，但还是需要程序员对并发编程的理论非常熟悉，经历过很多次实践才能用好并发编程带来性能效率上的提升。</p>
<p><a href="http://wantedonline.cn/2016/09/08/20160908-1/">专题目录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面几篇基本说的是并发理论性的东西。除了很简单的介绍了一下synchonized和volatile两个关键字。从本篇开始，还是继续介绍一些理论性的东西。不过这些理论上的东西不同于前面。而是实实在在的工具类。&lt;/p&gt;
&lt;p&gt;J.U.C是java.util.concurrent.*的简写。从JDK 1.5开始，JDK开始提供了一个专门用于简化并发编程的工具包，这个工具包就是J.U.C。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="J.U.C" scheme="http://wantedonline.cn/tags/J-U-C/"/>
    
  </entry>
  
  <entry>
    <title>软件开发日常思考(二)</title>
    <link href="http://wantedonline.cn/2016/11/08/20161108/"/>
    <id>http://wantedonline.cn/2016/11/08/20161108/</id>
    <published>2016-11-08T14:07:00.000Z</published>
    <updated>2016-11-08T14:09:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续<a href="http://wantedonline.cn/2016/08/20/20160820-1/">上一篇</a>的话题。上一篇谈到了单元测试和团队代码规范问题.事实上到目前为止，我还没有碰到过一个团队对单元测试有过高的要求。我碰到的大部分团队可以说是对单元测试没有要求。这也和目前大部分开发团队碰到的现实情况是相符合的，开发的时间以及团队对代码的质量没有太多的要求。功能为王，实现功能就好，至于可维护性，可读性，可拓展性等等这些问题从来不考虑。这一篇我想谈一谈我对程序员代码质量的思考。</p>
<a id="more"></a>
<p>很感恩和很幸运，我毕业后第一家公司是华为。为什么这么说呢？在大学的时候，我接触的项目和学到的东西，基本都是书上的。读了很多关于代码质量，代码风格以及软件工程理论性的东西。而真正巩固和实践是从工作开始的。入职华为前以及入职后新员工时期，大部分是培训。这里我从华为学到的两个重要的东西就是下面这两点。</p>
<h2>以客户为中心</h2>

<p>所有新员工入职华为大队培训一定有一堂非常重要的课就是讲华为的企业文化–以客户为中心，以奋斗者为本。</p>
<p>作为一个研发人员，我们不可能接触到一线客户。当时我所在的大部门(2012实验室)是一个SBG(Service Business Group)，我们服务的对象是产品线的兄弟。我学到的第一个理念是我们的客户是我们的上一道工序。</p>
<p>严格来说，无论在什么时候，对待任何人以及对待任何事，如果能够真正以客户为中心，也就是以服务好上一道工序为起点，那么很多事情都会有一个比较好的结果。</p>
<p>这个和我想讲的软件开发有什么关系呢？</p>
<p>软件开发是一个团队合作的活动。如果团队比较小，可能一个人就负责一个模块甚至一个项目。如果团队比较大，我们很多时候需要写一些公共接口给其他人用。这时候就有一个沟通和合作的问题。</p>
<p>过去我的经验是，谁写的接口谁负责维护。因此，如果只为了省事图个简单，没有任何接口doc说明也没有约定一个编码规范，很有可能就要出问题。比如说接口返回数据问题。如果返回了错误数据或者空指针等就是接口编写者的问题。而不应该要求使用者去做参数校验来避免踩坑。这一点我认为就是一个客户为中心的问题。</p>
<p>当然，在这一点上，过去的两年多，我一直在努力。我也看到了自己从一个经常犯错误的新手慢慢成长为一个比较少的犯错误的老油条。在这条路上，我还有很多事情可以做。</p>
<h2>代码质量–程序员的尊严</h2>

<p>软件开发是一个非常复杂的团队合作活动。在这项活动里，我比较认同两个东西。</p>
<p>短板理论</p>
<p>项目成功或失败不是一个或两个比较牛掰的人能决定得了的。取决于团队的整体水平以及团队中的短板。如果一个团队有比较好的编码规范以及90%的人都有较强的软件工程思想和编码水平，那么剩下的10%的短板也会跟着团队逐渐成长，最终整个团队的作战能力都能提升上去。开发出来的代码质量一定不会太低。</p>
<p>破窗理论</p>
<p>如果项目从一开始就向坏的方向发展，比如代码混乱，隐藏了很多潜在的安全问题。最后发展到最后一定会越来越坏，最终可能在某个重要的时间点爆发，然后彻底蹦了。因此，从项目一开始就保持一种比较严格的要求我觉得是一个比较好的做法。</p>
<p>这两个东西和主题代码质量的关系。</p>
<p>很多的时候，如果我们不注重这两点，任有项目代码做布朗运动，可能最终导致的结果是很不可控的。也许我们目前的资源以及条件，是功能为主，不要考虑网络资源，内存资源，CPU资源，安全问题等。但是最终当出现问题的时候已经不可控了，只能推到重来了。这就是一个失败的项目。</p>
<p>因此，作为程序员，珍惜每一点内存，即便是一个Java程序员，即便我们有非常足够的内存可使用；珍视每一点性能提升，时间复杂度的下降，空间复杂度的下降；保持一套可读性，可维护性高的代码风格和命名规范是极其重要的。</p>
<p>我们的代码写完之后很有可能是其他人维护，这时候别人的体验就是代码质量的体现，就是程序员尊严的体现，</p>
<h2>总结</h2>

<p>软件开发是一项复杂的活动。是一项团队合作，团队整体作战能力要求非常高的活动。因此，有时候项目的成败从团队水平就决定了。有时候可能一年两年看不出来问题，但当真正出现问题的时候已经无力回天了。而最初那批创造原始代码的人可能已经不在这里了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续&lt;a href=&quot;http://wantedonline.cn/2016/08/20/20160820-1/&quot;&gt;上一篇&lt;/a&gt;的话题。上一篇谈到了单元测试和团队代码规范问题.事实上到目前为止，我还没有碰到过一个团队对单元测试有过高的要求。我碰到的大部分团队可以说是对单元测试没有要求。这也和目前大部分开发团队碰到的现实情况是相符合的，开发的时间以及团队对代码的质量没有太多的要求。功能为王，实现功能就好，至于可维护性，可读性，可拓展性等等这些问题从来不考虑。这一篇我想谈一谈我对程序员代码质量的思考。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发日常" scheme="http://wantedonline.cn/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="软件开发" scheme="http://wantedonline.cn/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="IT生涯" scheme="http://wantedonline.cn/tags/IT%E7%94%9F%E6%B6%AF/"/>
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>这个世界会好吗？</title>
    <link href="http://wantedonline.cn/2016/11/03/20161103-1/"/>
    <id>http://wantedonline.cn/2016/11/03/20161103-1/</id>
    <published>2016-11-03T13:13:32.000Z</published>
    <updated>2016-11-04T00:26:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>想来想去也想不出一个什么好的标题来概括我想要表达的东西。恰好音乐播放到李志的&lt;这个世界会好吗&gt;，就用这个标题好了。走入社会后，总是会遇到各种各样的人，还有各种各样的事儿。有些人，有些事甚至会让自己不断怀疑自己的三观是不是错了，严重的还会怀疑整个人生。因此借文字来吐槽发泄一下吧。发泄完之后依然需要笑对生活，笑对世界~纵使生活**我千百遍，我待生活如初恋~</p>
<a id="more"></a>
<p>吃亏是福。但不意味着凡事都要选择吃亏。当我把你当成值得信赖的朋友的话，我可以一直吃亏。但是我的朋友也从没有让我一直吃亏过。但是如果仅仅是普通人，就没有必要一直选择吃亏了。小事还好，大事更加不想让自己吃亏。本分最重要，人都是自私的。总是想着占别人便宜的人最后一定占不到便宜。</p>
<p>耿直与真诚。和耿直的人交往会觉得说话做事效率特别高。我是个性子比较急躁的人。也觉得是一个比较耿直的人。很多事情直接说比委婉的说或者遮遮掩掩的说给人的感觉更愉快。至于真诚，人与人的交往如果都缺少了真诚，自然没有什么意思了。你对我真诚，我对你也真诚~</p>
<p>自我与换位思考。以前我是一个很自我的人，把自己当初世界的中心。走入社会后，自然会发现行不通。没有谁一定要围着谁转。也没有谁离不开谁。常常换位思考，自然能够理解别人，也自然能够被别人理解。</p>
<p>这个世界多点真诚，少点套路，多点关怀，多点爱，多好~~~</p>
<p>又快到了双十一了，请给我们这些单身狗多点关怀多点真诚。汪~汪~</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=30967310&auto=1&height=66"></iframe>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想来想去也想不出一个什么好的标题来概括我想要表达的东西。恰好音乐播放到李志的&amp;lt;这个世界会好吗&amp;gt;，就用这个标题好了。走入社会后，总是会遇到各种各样的人，还有各种各样的事儿。有些人，有些事甚至会让自己不断怀疑自己的三观是不是错了，严重的还会怀疑整个人生。因此借文字来吐槽发泄一下吧。发泄完之后依然需要笑对生活，笑对世界~纵使生活**我千百遍，我待生活如初恋~&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://wantedonline.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://wantedonline.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>分享一个Java IO方面的好东西</title>
    <link href="http://wantedonline.cn/2016/11/02/20161102-1/"/>
    <id>http://wantedonline.cn/2016/11/02/20161102-1/</id>
    <published>2016-11-02T12:09:50.000Z</published>
    <updated>2016-11-02T12:11:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在研究NIO的时候找到一个好东西，并发大师Doug Lea关于NIO方面的PPT文档。非常清晰明了~分享出来，自己需要的时候也可以看看 ^V^</p>
<a id="more"></a>
<p><a href="http://o9z6i1a1s.bkt.clouddn.com/nio.pdf" target="_blank" rel="external">Scalable IO in Java</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在研究NIO的时候找到一个好东西，并发大师Doug Lea关于NIO方面的PPT文档。非常清晰明了~分享出来，自己需要的时候也可以看看 ^V^&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://wantedonline.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="JavaIO" scheme="http://wantedonline.cn/tags/JavaIO/"/>
    
      <category term="Doug Lea" scheme="http://wantedonline.cn/tags/Doug-Lea/"/>
    
      <category term="分享" scheme="http://wantedonline.cn/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>理解Java内存模型(JMM)</title>
    <link href="http://wantedonline.cn/2016/10/29/20161029-1/"/>
    <id>http://wantedonline.cn/2016/10/29/20161029-1/</id>
    <published>2016-10-29T07:43:57.000Z</published>
    <updated>2016-10-29T07:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>当对并发编程的学习从初级阶段进入到高级阶段的过程中，对Java内存模型(JMM)的理解我认为是一个重要的分水岭。只有真正理解了JMM，才可能对并发中的线程、同步、线程通信以及后续并发编程高级技巧以及性能优化等问题有所理解。本文将总结我对JMM的一些理解。当然如果需要真正深入理解透彻JMM，还是需要读一读参考文献中的链接。</p>
 <a id="more"></a>
 <h2>1 什么是Java内存模型</h2>

<p> Java内存模型(JMM)不是Java语言所特有的。事实上像C#,Go等也有所谓的内存模型。这几门语言的内存模型总的来说要目标是一致的，但是可能语言之间的一些细节是有所差别的。<strong>Java内存模型要解决的一个问题是多线程中线程私有内存和主内存之间的数据一致性以及数据通信问题,这里需要重点说明的是这里主内存不是堆内存，这里的主内存是个抽象概念，并不对应JVM或者操作系统某块内存。</strong>事实上，不仅仅是JVM存在这个问题，在多处理器多寄存器架构中，也一定存在这个问题。考虑这样一种场景：多CPU，多寄存器通过总线共享主内存。如果在多线程环境下，CPU1中线程甲对数据A进行了修改操作，这时候CPU2中线程乙需要读取数据A。数据A分别在CPU1和CPU2的寄存器中存在副本。如果没有一种机制来保证数据通信，就一定会有数据一致性问题。JVM中，线程的一些数据是存在线程栈帧中的，多线程环境下，如何保证某些需要共享的数据的一致性和通信问题就需要一种机制来保证。因此才有了Java内存模型，对Java内存模型的定义以及一些规范是在JSR-133。</p>
 <h2>2 Java内存模型中几个重要概念</h2>

<p> Java内存模型中比较重要的也就是下面的三个概念了。这几个概念的最直观体现就是对synchonized,volatile,final,static等一些关键字的合理使用所带来的效果了。</p>
 <h3>重排序</h3>

<p> 关于重排序在上一篇文章中也有所提到。重排序有三个层次，分别是编译器的重排序，操作系统的重排序以及CPU指令级别的重排序。之所以会有重排序，是因为我们的编译器，操作系统，CPU已经很智能化了，它能够在不影响语义的情况下对某些指令进行优化以及调整顺序，以此来达到性能优化，减少一些不必要的指令执行的目的。但是在多线程环境下，重排序会导致数据一致性问题。因此才需要一些必要的保证手段来防止这三个层次的重排序。比如synchonized，volatile等。</p>
 <h3>内存屏障</h3>

<p> 内存屏障这个概念事实上以及是指令级别了。它规定了某些操作的先后顺序以及可见性问题。比如多处理环境下，对某些指令的执行必须要先于其他指令，可能就需要一个loadload指令等等。内存屏障的种类也有很多，比如loadload，loadstore，storestore等。不同的屏障功能不一样，适用场景也不一样。这一点对上层程序员是透明的。因此我觉得了解即可。</p>
 <h3>Happen-Before</h3>

<p> Happen-Before是JMM所定义的一些规则。这些规则保证了一些操作的顺序问题。这些顺序是有JVM来保证，并且保证不会被编译器或CPU等重排序所打破。Happen-Before也是定义的一个顺序问题。但是和内存屏障相比，它不再是指令级别，而是一个概念级别。或者一个原则问题。因此，有的书上也直接把这个叫做Happen-Before原则。具体的Happen-Before原则有这儿几条：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happen-before与该线程的后续操作</li>
<li>监视器锁规则：对一个监视器锁的解锁，happen-before于随后对这个监视器锁的加锁</li>
<li>volatile变量规则:对一个volatile域的写，happen-before于任意后续对这个volatile域的读</li>
<li>传递性：如果A happen-before B，B happen-before C，那么A happen-before C</li>
<li>Thread.start()的调用happen-before于启动线程里面的动作</li>
<li><p>Thread中的所有动作都happen-before于其他线程从Thread.join中成功返回</p>
<h2>3 Java内存模型对并发编程的意义</h2>

<p>JSR-133还定义了final，static等关键字的一些详细含义。因此如果要理解JMM，势必是要读一读JSR-133的。理解JMM，对于并发编程的最大意义我认为是在于对synchonized，volatile，fianl,static等关键字的合理运用，编写性能更好的并发程序来。</p>
<h3>参考文献</h3>

<ol>
<li><a href="https://jcp.org/en/jsr/detail?id=133" target="_blank" rel="external">JSR-133</a></li>
<li><a href="http://www.cs.umd.edu/%7Epugh/java/memoryModel/" target="_blank" rel="external">Java Memory Model</a></li>
</ol>
</li>
</ul>
<p><a href="http://wantedonline.cn/2016/09/08/20160908-1/">专题目录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当对并发编程的学习从初级阶段进入到高级阶段的过程中，对Java内存模型(JMM)的理解我认为是一个重要的分水岭。只有真正理解了JMM，才可能对并发中的线程、同步、线程通信以及后续并发编程高级技巧以及性能优化等问题有所理解。本文将总结我对JMM的一些理解。当然如果需要真正深入理解透彻JMM，还是需要读一读参考文献中的链接。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发编程" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="JMM" scheme="http://wantedonline.cn/tags/JMM/"/>
    
      <category term="Java内存模型" scheme="http://wantedonline.cn/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解原子性与可见性</title>
    <link href="http://wantedonline.cn/2016/10/21/20161021-1/"/>
    <id>http://wantedonline.cn/2016/10/21/20161021-1/</id>
    <published>2016-10-21T11:24:36.000Z</published>
    <updated>2016-10-21T13:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在并发编程的世界里，有两个非常重要的关键字，分别是synchronized和volatile. 一句话概括这两个关键字的作用的话就是synchronized保证了原子性，volatile保证了可见性。本文将深入分析原子性和可见性。</p>
<a id="more"></a>
<h2>原子性</h2>

<p>所谓原子性就是指操作不可分解，不会出现一半成功，一半失败的情况。我们都知道事务具有ACID属性，其中的A就是原子性。事务中的原子性也是说一个完整的事务中定义的全部操作步骤要么全部成功，要么全部不成功，不可分解。和我们这里的原子性定义是一样的。在并发编程中，我们在临界区的某些操作，必须具有原子性。因为我们无法控制线程的切换，所以就有可能发生线程执行到某个中间位置，因为时间片或者等待资源的情况发了上下文切换，切入到另外一个线程，这时候就破坏了数据的一致性。因此，我们必须保证临界区中这些操作的原子性。</p>
<h3>保证原子性的手段</h3>

<p>保证原子性的手段之一就是加锁。所谓锁，我们可以这么理解，当我们某个线程获取了锁，就代表他获得了一个特殊通行证，并且这个通行证一定是唯一的。在它归还这个通行证之前，其他线程是没办法进入到锁区域的。自然其他线程也就无法看到锁区域中数据的状态，也不能修改其状态。因此，只要我们的线程没有释放锁，其他线程是无法进入到锁区域的。直到我们成功释放了锁，我们的操作都是原子性的，不会被其他线程所干扰。</p>
<p>加锁的第一种方式是synchronized，这是Java提供的一个关键字，这个关键字的含义就是内置锁或者监视器锁。当我们的线程进入到了synchronized区域时，自动会获取锁，当退出这个区域是自动释放锁。如果我们使用javap打印一下一个synchronized修饰的代码块，我们会发现，有个叫<strong>enter monitor</strong>和<strong>exit monitor</strong>的两条指令，它们所包围的指令就是使用synchronized修饰的区域。</p>
<p>在J.U.C里，提供了更加灵活的加锁机制，就是Lock类，这是从Java代码层面提供的锁机制。这套机制比synchronized更加灵活，而且从JDK 1.6之后，这套锁机制的性能比synchronized更好了。这里面将锁划分的更细，可以有互斥锁(写锁)和共享锁(读锁)。获取锁和释放锁的操作都是可控的了，因此更加灵活，但是带来的使用复杂性也更加高了，如果我们获取了锁忘记释放锁或者释放锁失败将有可能会造成死锁等。</p>
<p>当我们看过J.U.C实现锁的方式(基于AQS)，我们自己也可以实现锁。如果使用Semaphore类的话，自己实现锁就更加简单了。</p>
<p>当然，保证原子性的手段并不是只有加锁这一种。事实上，锁机制对指令执行性能是有影响的。因此，如果不是有必要，我们不要随便加锁，而且加锁的区域尽量保证最小化，不要将没有必要加锁的代码放到锁区域中来。</p>
<p>原子性的另外一种方式是无锁化。这个看起来比较矛盾，其实是不矛盾的。无锁化是通过CAS(Compare and set)来实现的。J.U.C中提供了一些原子类，它保证原子性的方式就是CAS。后续我们分析J.U.C的原子类时将详细讲解CAS操作。</p>
<p>两种实现原子性的方式并不是可以互相替代的，而是他们在特定的场景具有特定的使用方式。加锁一般是代码块。而无锁化则是一些需要原子化的变量，通过CAS比使用加锁在变量层面性能更高。</p>
<h2>可见性</h2>

<p>所谓可见性是指我们希望对于某些状态我们进行了修改，希望其他线程能够感知到。这里就有线程通信的意思在里面了。考虑这样一种场景，变量x是两个线程A,B都可以看到的，线程A，B都保存了一份副本在彼此的栈帧里，当线程A修改了x时，如果没有一种机制去通信告知线程B，线程B仍然使用的是旧的x值。因此可见性就是要保证线程B能及时感知到x的状态变化。同样在CPU层面，也有这种场景，比如多核多寄存器。同样有变量的缓存以及修改需要通知其他CPU或寄存器变量的修改。当然这个层面不是JVM来保证了。</p>
<h3>保证可见性的手段</h3>

<p>保证可见性的第一种方法是直接使用锁，从效果上是可以的。但是前文说过，锁的方式对性能影响比较大。因此Java提供了另外一个关键字叫做volatile。这个关键字就是用来保证可见性的，它还有一个别称叫“轻量级锁”。</p>
<p>volatile为什么可以保证可见性呢? 这里可以从JMM找到原理。在下一篇讲解JMM时我们将详细分析synchronized和volatile两个关键字的原理。</p>
<h2>总结</h2>

<p>原子性和可见性是并发编程里两个非常重要的基础概念，只有深入理解了这两个概念，我们才能用好锁，用好可见性。才能编写出性能优越，线程安全的代码来。</p>
<p><a href="http://wantedonline.cn/2016/09/08/20160908-1/">专题目录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在并发编程的世界里，有两个非常重要的关键字，分别是synchronized和volatile. 一句话概括这两个关键字的作用的话就是synchronized保证了原子性，volatile保证了可见性。本文将深入分析原子性和可见性。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发编程" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="原子性" scheme="http://wantedonline.cn/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    
      <category term="可见性" scheme="http://wantedonline.cn/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>多线程带来的线程安全和线程通信问题</title>
    <link href="http://wantedonline.cn/2016/10/20/20161020-1/"/>
    <id>http://wantedonline.cn/2016/10/20/20161020-1/</id>
    <published>2016-10-20T09:29:07.000Z</published>
    <updated>2016-10-20T09:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>前文多次说过，多线程会带来线程安全问题以及线程与线程之间需要进行通信。在本文中，我想说说我理解的线程安全以及线程通信问题。当然，依然保持我博客的特点，很多东西仅仅点到为止，不做非常深入的分析。原因在于我自认为我离专家还有一定的距离，因此对于这些知识不敢以专家自居。仅仅分享我的理解，起到一个提纲挈领的作用。读者如果想要就某个点深入下去，还是需要一定的时间钻研的。 </p>
<a id="more"></a>
<h2>临界区</h2>

<p>只要是涉及到多线程，就一定涉及到临界区。前文说过，线程与进程的重要区别是线程共享临界区。临界区就是多个线程共享的一块内存。可以这样说，线程安全和线程通信的基础就是临界区。因此，只要是多线程编程，一定要时刻考虑临界区的数据变化。</p>
<h2>线程安全的本质</h2>

<p>在《Java并发编程实战》这本著作中对线程安全的定义大概是这样的(大概意思，非原文)，多线程的数据表现和单线程的数据表现是一样的话我们认为这个是线程安全的。我认为线程安全有这么几种情况。</p>
<h3>1 指令线程安全</h3>

<p>指令线程安全这个术语是本人原创(如有雷同，纯属意外)。对于<strong>a++</strong>类似的语句，我们都知道，JVM会编译成三条指令。因此如果在多线程环境下，因为线程上下文切换等就可能造成线程安全问题最终导致数据不一致。这种情况的办法一般只有使用原子锁或一些线程安全机制了(比如CAS)。指令线程安全还有一种情况是指令的重排序。</p>
<p><strong>重排序</strong></p>
<p>重排序是指CPU或者操作系统或者编译器在考虑性能的情况下对某些彼此关系不是很大的指令进行了优化和调整执行顺序。这里需要说明的是如果两条指令有非常明显的逻辑顺序，颠倒的话会影响语义的话是不会进行重排序的。重排序有三个层次，分别是CPU基本的重排序，操作系统执行时的重排序以及Java编译器的重排序。如果不考虑原子性或者可见性，在多线程环境下因为指令重排序是会导致线程安全问题的。因此针对这些，Java才定义了一个JMM(Java Memory Model Java内存模型)。关于JMM，这里不再展开，后面相关专题再涉及。</p>
<h3>2 共享数据线程安全</h3>

<p>所谓共享数据是指临界区的数据。在多线程环境下，这些数据事实上是暴露给各个线程的。各个线程都有权对其进行操作。因此这里自然就产生了线程安全问题。同样，共享数据只能通过加锁或者私有化(著名的ThreadLocal可以理解为干这事)或者直接让其不可变(final,权限控制)来实现线程安全，有句话说最好的线程安全就是让其不可变。</p>
<h2>线程通信的本质</h2>

<p>在保证线程安全的情况下，多线程之间需要进行通信的。这里的通信不是指发消息这种通信。我们可以把线程通信理解为多线程之间线程之间的协调。而协调的一些机制就是通过发送指令或者一种消息给JVM或操作系统来实现协调的。</p>
<h3>线程通信的手段</h3>

<p>Java里实现线程通信的方法有很多。最常见的有Object类的wait和notify系列。Thread里的sleep和Join等。同时在J.U.C里，提供了很多方式来实现线程通信，比如闭锁(CountDownLatch)，栅栏(CyclicBarrier)，条件类(Condition)等。同时，线程还提供了中断机制等，我们自己也可以控制一个线程的执行。需要说明的是因为消息安全(比如丢失消息)问题导致的死锁等，JDK已经废弃了Thread的stop等方法。</p>
<h2>总结</h2>

<p>本文从大逻辑点到了多线程带来的线程安全问题和线程之间通信的方法。很多东西如果研究下去又可以单独写一篇文章了。在后面会对一些比较重要的地方再做说明。</p>
<p><a href="http://wantedonline.cn/2016/09/08/20160908-1/">专题目录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文多次说过，多线程会带来线程安全问题以及线程与线程之间需要进行通信。在本文中，我想说说我理解的线程安全以及线程通信问题。当然，依然保持我博客的特点，很多东西仅仅点到为止，不做非常深入的分析。原因在于我自认为我离专家还有一定的距离，因此对于这些知识不敢以专家自居。仅仅分享我的理解，起到一个提纲挈领的作用。读者如果想要就某个点深入下去，还是需要一定的时间钻研的。 &lt;/p&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="多线程通信" scheme="http://wantedonline.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
      <category term="线程安全" scheme="http://wantedonline.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程的基本手段</title>
    <link href="http://wantedonline.cn/2016/10/18/20161018-1/"/>
    <id>http://wantedonline.cn/2016/10/18/20161018-1/</id>
    <published>2016-10-18T15:25:18.000Z</published>
    <updated>2016-10-18T12:49:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>实现并发的一个关键或者说核心手段就是使用多线程。线程就是轻量级的进程。它和进程的区别在于是否共享临界区或者说共享数据内存。我们一般把可以分解的任务使用多线程来实现。所谓可以分解的任务就是可以并行化的任务。比如从1加到100，我们可以先两两相加，求得的和再两两相加。这里两两相加都一样的，只是输入的加数不一样而已，显然是可以并行化的。本文将介绍Java中实现并发的几种方法以及两个重要的关键字的用法。</p>
<a id="more"></a>
<h2>继承Thread类</h2>

<p>初学Java的人学到多线程介绍的方法一定是继承<strong>Thread</strong>类，然后覆写其中的<strong>run</strong>方法。启动线程的时候再调用该Thread类的start方法。</p>
<p>但是Java只支持单继承，如果要既要实现线程，又要继承其他类的话就需要使用接口了。因此才有了<strong>Runnable</strong>接口。</p>
<h2>实现Runnable接口</h2>

<p>所谓接口，就是一个约定，一个规范。Runnable接口约定了我们如果要抽象出一个任务来实现多线程，只要实现run方法接口。然后把这个Runnable子类放到Thread作为参数去调用即可。</p>
<p>查看Thread源码或Runnable的run方法签名即可知道，这两种方式执行完都是没有返回值的。假如我们有一个任务需要将返回值返回出来怎么办？一种方式是通过传参，并且这个参数是引用参数。但是这种方式有点C语言味道。在Java里，更加直观的方式显然是通过返回值。怎么办呢？</p>
<h2>实现Callable接口</h2>

<p>在J.U.C(java.util.concurrent)包里，从J.D.K 1.5开始就提供了一个叫做<strong>Callable</strong>接口的类。这个接口有一个方法叫做<strong>call</strong>，在使用前需要指定返回值V，该方法就可以返回一个V类型的对象。</p>
<p>除了有返回值，这个接口和<strong>Runnable</strong>接口的功能一模一样。但是用法稍微有些不同。显然，不能像Runnable一样放到Thread里。这个接口是J.U.C提供的，自然在J.U.C里有相应的类来执行Callable子类。</p>
<p>这就是Executors框架。</p>
<p>Executors框架最常见的功能就是提供了4中类型的线程池。抽象线程池(AbstractExecutorService)提供了一个submit方法和newTaskFor方法。submit方法就是将一个Callable类作为参数提交到线程池，当线程池执行完之后会返回一个Future对象将返回值带出来。newTaskFor是一个装饰器方法，返回一个RunableFuture对象，这个对象就是一个包装的任务。可以用于线程池的工作窃取队列等地方。详细的线程池以及使用在后面用单独的文章来说明。</p>
<h2>线程的本质</h2>

<p>关于线程的形象描述。我只服这篇<a href="https://segmentfault.com/a/1190000004694556" target="_blank" rel="external">文章</a>。</p>
<p>这里阐述线程的本质，我打算从Java中Thread类的源码角度来阐述。</p>
<p>首先，看看javadoc关于线程的一些描述。</p>
<blockquote class="blockquote-center"><p>A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently. </p>
</blockquote>
<p>从这里我们可以看出，Java中的线程是虚拟机层面的线程。是由虚拟机来保证并发的。那么它和操作系统层面提供的线程是否是一一对应？这点我没有看过JVM的源码，因此无法说出准确答案。但是从Thread源码来看,虚拟机的线程和操作系统是有关系的。因为在Thread类中引用了一些native方法，只是这些native方法源码以及实现我目前还无法得知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static native void registerNatives();</div></pre></td></tr></table></figure>
<p>一个线程的一些基本属性有优先级，线程名(可以不指定)等。这些属性在初始化一个线程的时候，可以通过构造函数来设置。</p>
<h3>线程的一些基本概念</h3>


<h4>1 守护线程</h4>

<p>所谓守护线程是指一些优先级比较低(通常情况下),在后台执行的一些线程。比如我们的程序入口main函数所在的线程，JVM的垃圾回收线程等。守护线程的特点就是它要等其他所有非守护线程执行完成，JVM虚拟机打算退出的时候它在结束运行。守护线程的作用就是用于一些后台执行的任务，一般来说，他们的优先级不是很高。不然其他普通线程都没有时间片去执行了。</p>
<h4>2 线程组</h4>

<p>ThreadGroup就是将一些功能相近的线程或者有父子关系的线程放到一个集合里。这个集合就是ThreadGroup，它内部就是一个数组。同时也可以将ThreadGroup放进去。这样相互联系的一些线程之间的拓扑关系就可以表达出来。使用线程组的好处是我们可以一次设置一组线程的属性，比如优先级，名字，是否是守护线程等。同时还可以一次控制一组线程(线程组的暂停唤醒方法因为安全问题已经不建议使用了)。</p>
<h4>3 线程优先级</h4>

<p>这个概念应该很好理解。Java里将线程优先级定义为 1-10，同时定义了三个常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public final static int MIN_PRIORITY = 1;</div><div class="line"></div><div class="line">public final static int NORM_PRIORITY = 5;</div><div class="line"></div><div class="line">public final static int MAX_PRIORITY = 10;</div></pre></td></tr></table></figure>
<p>一般我们就用这三种级别来设定线程优先级即可。优先级越高，就越优先执行。</p>
<h3>线程的生命周期</h3>

<p>前面说过，启动一个线程调用Thread的start方法。线程从启动开始到线程执行完毕被操作系统回收，是有一系列的生命周期状态转换的。在Java里，这些状态定义在Thread内部的一个枚举State里。这5个状态分别是    NEW,RUNNABLE,BLOCKED,WAITTING,TIMED_WAITING。关于状态的互相转换以及如何观察线程状态可以另开一篇文章来说明了。这里不再详述，总之和操作系统课上关于进程的状态转换有一点点类似。</p>
<h3>线程的通信</h3>

<p>线程最重要的一个话题就是线程之间的通信。因为线程之间彼此共享内存，因此必然存在一些线程安全问题和线程通信问题。线程中的wait,join,notify,sleep等方法都是为线程通信而产生的。具体作用可以在文档以及后续博文中找到。</p>
<h3>static,final等对线程安全的意义</h3>

<p>关于static，final这两个关键字的一些用法是每个资深Javaer必须掌握的。static对于线程安全的意义更多的体现在修饰一个变量上。当一个变量是static变量时意味着这个变量是个类变量，被全部线程所共享。因此必然存在线程安全问题。而final修饰一个变量则是不可变的意思。修饰引用指引用关系不可变。因此，在多线程里，可以使用static和final来实现依一些数据共享和线程安全的问题。</p>
<h3>总结展望</h3>

<p>本文很简单的介绍了Java中实现并发的几种方式。同时概括性地点到了线程的一些基本概念和线程通信和安全问题。要说清楚这些问题不是这么一篇文章能够说清楚的。这里我感到自己语言总结和学识的精通程度还没有达到专家水准。因此有些问题尽管我知道在生产实践中应该怎么用以及会出现什么问题，但是要介绍给读者却有些困难。希望后面有时间能够详细阐释清楚每一个问题。</p>
<p><a href="http://wantedonline.cn/2016/09/08/20160908-1/">专题目录</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现并发的一个关键或者说核心手段就是使用多线程。线程就是轻量级的进程。它和进程的区别在于是否共享临界区或者说共享数据内存。我们一般把可以分解的任务使用多线程来实现。所谓可以分解的任务就是可以并行化的任务。比如从1加到100，我们可以先两两相加，求得的和再两两相加。这里两两相加都一样的，只是输入的加数不一样而已，显然是可以并行化的。本文将介绍Java中实现并发的几种方法以及两个重要的关键字的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解" scheme="http://wantedonline.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="并发编程" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://wantedonline.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程" scheme="http://wantedonline.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
