{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"f3918796671a57f7039721f6be679a939cf0e1d2","modified":1468680745000},{"_id":"source/.nojekyll","hash":"339134163e185b2d40a90071f51f0868d265bc58","modified":1478218644000},{"_id":"source/.DS_Store","hash":"4450d8bacf55bc4a4f4274ecb36624020bbf188e","modified":1478944460000},{"_id":"source/CNAME","hash":"9de5ff4b58e99f10976749a3427b51685aea56f5","modified":1478192137000},{"_id":"themes/next/.gitignore","hash":"efec790f5b7a0256763e1cc08f12c4f0aff509f6","modified":1468680745000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1468680745000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1468680745000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1468680745000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1468680745000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1468680745000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1468680745000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1468680745000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1468680745000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1468680745000},{"_id":"themes/next/_config.yml","hash":"0d92017737e85a309bfd02ef8c260decd218e406","modified":1478264510000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1468680745000},{"_id":"source/_posts/20160804-1.md","hash":"91f17c953b830a7ae6ba1f688addf62173179034","modified":1470583574000},{"_id":"source/_posts/.DS_Store","hash":"fa0d4b3799ab82805ada1881520269cd1cd0539f","modified":1478185300000},{"_id":"source/_posts/20160820-1.md","hash":"27bd561fcf45083e0d34e0dc42f28c713269c4ed","modified":1471707714000},{"_id":"source/_posts/20160807-1.md","hash":"0253c3f07f9f0396241c904bdab0c3b0c666041d","modified":1470584050000},{"_id":"source/_posts/20160826-1.md","hash":"afc00eb600243d8bd9acc3bd5e1d9f8bc428d7ca","modified":1474372688000},{"_id":"source/_posts/20160908-1.md","hash":"4a63a1acaebfbca6162fd747e4046a43aac38519","modified":1478941805000},{"_id":"source/_posts/20160908-2.md","hash":"a9620e650b30ac3d7fd15d587827ef86c34ea9e3","modified":1474372688000},{"_id":"source/_posts/20160920-1.md","hash":"3d708124f177b14ce08770ad510b2ff8dd355cbf","modified":1475822695000},{"_id":"source/_posts/20161021-1.md","hash":"d3731e5af0d14eef98b3ed9773abcc6f0d426bd1","modified":1477058214000},{"_id":"source/_posts/20161018-1.md","hash":"0629abb8ecef189d1d99f3cb1e98e6ec03672d27","modified":1476794941000},{"_id":"source/_posts/20161020-1.md","hash":"9c0c2577a320b28b3ce7cc483e97f23dbc9733cf","modified":1476956367000},{"_id":"source/_posts/20161102-1.md","hash":"006af383145c896a6dc20a67e95241463e61f2e3","modified":1478088701000},{"_id":"source/_posts/20161103-1.md","hash":"9d3e0fb5caf107b155dcc78842893c4135a62537","modified":1478219193000},{"_id":"source/_posts/20161029-1.md","hash":"83c7bc3da30fa4c189fc7bee1bd26de27733a53d","modified":1477727132000},{"_id":"source/_posts/20161108.md","hash":"50b61ac2bd7e9b1caf54a52470a760ca50bba4ec","modified":1478614147000},{"_id":"source/_posts/20161112.md","hash":"5ff8c2fac3e7693807b85fbd28f017b139e1bf48","modified":1478942087000},{"_id":"source/_posts/20161112-2.md","hash":"53d8b717e920b3adfe1b72484e653b7f95d64c18","modified":1478946076000},{"_id":"source/_posts/20161128.md","hash":"aaa08e598a44cb0091b2edd213b6ab7dd05141a2","modified":1480343249000},{"_id":"source/_posts/base_linkedlist_data_structure20160706.md","hash":"d9075fc35782119e799f4c5bf0a59af3d387c753","modified":1468680745000},{"_id":"source/_posts/good_start20160706.md","hash":"7b58141d2eae382dd122ef42491019eb7baefdfc","modified":1468680745000},{"_id":"source/_posts/java-new-anas-20160708.md","hash":"6f1707e45c6341ff45258dd1da40d2cf128ac9ea","modified":1468680745000},{"_id":"source/_posts/jvm-arch-anasi20160707.md","hash":"f7f280840ec142e09cbcb3a88f3cee0d0d84ced7","modified":1468680745000},{"_id":"source/_posts/jvm-gc-desc.md","hash":"1ed295be6fa2d31f6832bc57ae138218832ad4a7","modified":1468680745000},{"_id":"source/_posts/weekend-article-1.md","hash":"0aea85df29f74a4b2b973e05a22f9ceb410350cf","modified":1470583574000},{"_id":"source/about/index.md","hash":"c51f5293490a4b7b26ed957d1d18b88998c29639","modified":1481031273000},{"_id":"source/_posts/what-is-life-meaning.md","hash":"376a37c8a4b9df2f1f1d1af58a0e80d1f682e69e","modified":1480343220000},{"_id":"source/archives/index.md","hash":"24b11f8abfecaa1814fd737bb7e6c09c426f6142","modified":1468680745000},{"_id":"source/categories/index.md","hash":"f82389cad1d361acccff8981019d3b206005580e","modified":1468680745000},{"_id":"source/tags/index.md","hash":"a66faf9a7306f20e454ff6359fbce5a093a2cfd1","modified":1468680745000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1468680745000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1468680745000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1468680745000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1468680745000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1468680745000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1468680745000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1468680745000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1468680745000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1468680745000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1468680745000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1468680745000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1468680745000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1468680745000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1468680745000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1468680745000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1468680745000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1468680745000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1468680745000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1468680745000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1468680745000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1468680745000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1468680745000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468680745000},{"_id":"source/_posts/jvm-arch-anasi20160707/1.png","hash":"f4f6be8e8d07d72442865b6b301e1c5e0fdfa88a","modified":1468680745000},{"_id":"source/_posts/jvm-arch-anasi20160707/stack.png","hash":"ef07e9fcf2677919d14edb648536e6396fee2ed0","modified":1468680745000},{"_id":"source/_posts/jvm-arch-anasi20160707/methodarea.png","hash":"a53850d0e3264b0d54b0ad0f67004bb85326014e","modified":1468680745000},{"_id":"source/_posts/jvm-arch-anasi20160707/dm.png","hash":"5f23f7a9872badae62ce7a4ed9515801d8b87201","modified":1468680745000},{"_id":"source/_posts/jvm-arch-anasi20160707/heap.png","hash":"a068659aefd684ba36084cb3b0d512b3172356b2","modified":1468680745000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1468680745000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1468680745000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1468680745000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1468680745000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b883289054ee54a374caad5d4883591beb94bd8b","modified":1468680745000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"82a9bc2ba60ce68419128ff60624bd74b15dfb78","modified":1468680745000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1468680745000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"0ce71d8322ea7dea82d9371fa2fe13949aa870e3","modified":1468680745000},{"_id":"themes/next/layout/_partials/head.swig","hash":"f83b1c55bedd2c1a3eb734c72c6997795a4e5f99","modified":1468680745000},{"_id":"themes/next/layout/_partials/header.swig","hash":"963a765dc00e6ac43cfc53ffaf5725eb854cf95e","modified":1468680745000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1468680745000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1468680745000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1468680745000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1468680745000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1468680745000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1468680745000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1468680745000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1468680745000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1468680745000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1468680745000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1468680745000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1468680745000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1468680745000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1468680745000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1468680745000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1468680745000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1468680745000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1468680745000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1468680745000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1468680745000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1468680745000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1468680745000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1468680745000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468680745000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468680745000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468680745000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468680745000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468680745000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468680745000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1468680745000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1468680745000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1468680745000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1468680745000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1468680745000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1468680745000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1468680745000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1468680745000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1468680745000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1468680745000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"069bb17fb1db3bc7c85c88efa3ed94ab6becbe2c","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1468680745000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1468680745000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1468680745000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1468680745000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1468680745000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1468680745000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1468680745000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1468680745000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1468680745000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1468680745000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1468680745000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1468680745000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1468680745000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1468680745000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1468680745000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1468680745000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1468680745000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1468680745000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1468680745000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1468680745000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1468680745000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1468680745000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1468680745000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1468680745000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1468680745000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1468680745000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1468680745000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1468680745000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1468680745000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1468680745000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"8c7af79407d223486fba72b8150fe045a553bf70","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1468680745000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1468680745000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1468680745000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1468680745000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1468680745000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1468680745000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1468680745000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1468680745000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1468680745000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1468680745000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1468680745000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1468680745000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1468680745000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1468680745000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1468680745000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1468680745000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1468680745000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1468680745000},{"_id":"public/atom.xml","hash":"72b894bec5a6e46d31f8e09a522b10b0bf57ae22","modified":1481032550426},{"_id":"public/404.html","hash":"eb2169bc946757d695b2d6714b2c055bc5a442b1","modified":1481032550465},{"_id":"public/about/index.html","hash":"b6bf241a03f1964db4a9ccddae216145d5accac4","modified":1481032550465},{"_id":"public/tags/index.html","hash":"f8841b6931b7dd067f6c088b9d70ac7ff064f5ea","modified":1481032550465},{"_id":"public/categories/index.html","hash":"783a40873e78654e0537061e0646c1561f827c38","modified":1481032550465},{"_id":"public/categories/深入理解/page/2/index.html","hash":"63970daf1a084e391085f8e0d7bb37cf8b008f68","modified":1481032550465},{"_id":"public/categories/软件开发日常/index.html","hash":"887793890fdd5e9e041207742018e97d02eebd2f","modified":1481032550465},{"_id":"public/categories/工具/index.html","hash":"9f6f3fb29b0c8f0acfebc90a3dd25eb38cb6118c","modified":1481032550465},{"_id":"public/categories/基础技术/index.html","hash":"2877ac68c17a4793898648e9a1f81bf0131f52c2","modified":1481032550465},{"_id":"public/archives/page/3/index.html","hash":"7e663e0148e297faa54664333b565e3ca7857f9c","modified":1481032550465},{"_id":"public/archives/2016/page/3/index.html","hash":"9d1819e3789bdbc77214b0226a5b2622fb411c70","modified":1481032550465},{"_id":"public/archives/2016/08/index.html","hash":"62488c09389edb256aea6abdc357dc58fd260b05","modified":1481032550465},{"_id":"public/archives/2016/09/index.html","hash":"90990cfa35dc9c02021f751973293170351022c8","modified":1481032550465},{"_id":"public/archives/2016/10/index.html","hash":"f5728273b69792aa4eeeb7d0f8254e35988bad37","modified":1481032550465},{"_id":"public/tags/模式设计/index.html","hash":"7a578aeb64c781fbf1a87ad50e2621bed357d165","modified":1481032550465},{"_id":"public/tags/高并发/index.html","hash":"ed3ca3eff61dbc3f535661f894df2899b495e658","modified":1481032550465},{"_id":"public/tags/分布式/index.html","hash":"c2540c0c3a258b5c5e5f864825f9b6add7edaf4f","modified":1481032550465},{"_id":"public/tags/周末随笔/index.html","hash":"c1dca570e5ef8a0b5ea6b6661c87f7e99b5cad75","modified":1481032550465},{"_id":"public/tags/软件开发/index.html","hash":"e467899deadab87375125383dbedbafe942dbedb","modified":1481032550465},{"_id":"public/tags/IT生涯/index.html","hash":"690951dc8003a759233959b0b5dec9bd100a6f92","modified":1481032550465},{"_id":"public/tags/生活/index.html","hash":"7f4abac9ac414260b5beea990bd4de3994e5fc25","modified":1481032550465},{"_id":"public/tags/孤独/index.html","hash":"30a41c156cb3357879a3ad712daae66a1ede9e9c","modified":1481032550465},{"_id":"public/tags/小诗/index.html","hash":"bb7950ce933881e89f693d288f61d7d7ebf69ee3","modified":1481032550465},{"_id":"public/tags/工具/index.html","hash":"9dad54240f206d006d53a6f83ef6b77184c85b55","modified":1481032550465},{"_id":"public/tags/生产效率/index.html","hash":"2ca901985133674784699fe6c5ac05cc3786019d","modified":1481032550465},{"_id":"public/tags/并发编程/index.html","hash":"d40d4b9aa3e783d4df4da004305ef641eac642cb","modified":1481032550465},{"_id":"public/tags/深入理解/index.html","hash":"42c3326106d67fd7e31f47c9aab8bc24b3bb5d3e","modified":1481032550466},{"_id":"public/tags/并发/index.html","hash":"8bb6ede5f659455e11df6f5df3821a06bef0a19d","modified":1481032550466},{"_id":"public/tags/并发专题/index.html","hash":"213df3396d54bd74c7e586e9929264f78223650f","modified":1481032550466},{"_id":"public/tags/博客更新/index.html","hash":"96b4f46240c005ab274869c6508e448103d0e6f5","modified":1481032550466},{"_id":"public/tags/原子性/index.html","hash":"aa26357acc163d4b9d10ed980867af7de817065c","modified":1481032550466},{"_id":"public/tags/可见性/index.html","hash":"014ce2801ddabf938dccec12b58e4dc4c060bcef","modified":1481032550466},{"_id":"public/tags/线程/index.html","hash":"22467c1ee9e4b26847413901e7eefe2337e9f772","modified":1481032550466},{"_id":"public/tags/多线程通信/index.html","hash":"dd3e24d85be8cf7dd68156f7763f720038b4d70d","modified":1481032550466},{"_id":"public/tags/线程安全/index.html","hash":"18ba189bfcaf4ffc6087fb1b87e59c7d5271058b","modified":1481032550466},{"_id":"public/tags/JavaIO/index.html","hash":"ba977cacf2c9134a2a125c5d344400d63f16814d","modified":1481032550466},{"_id":"public/tags/Doug-Lea/index.html","hash":"ff14a7f260bad17376daa8f15bec7a0208ba2358","modified":1481032550466},{"_id":"public/tags/分享/index.html","hash":"0bdf640c83178cd3d872de081dccfa6091ffc3ae","modified":1481032550466},{"_id":"public/tags/JMM/index.html","hash":"0bdf3f196141884bb966b16a3abcdd6e3d3e7c3b","modified":1481032550466},{"_id":"public/tags/Java内存模型/index.html","hash":"10977c057cc5cef033e3fcdf91ad684529ccb391","modified":1481032550466},{"_id":"public/tags/J-U-C/index.html","hash":"b241f42c32d83f20d659c4a444fbbfd5decb58fa","modified":1481032550466},{"_id":"public/tags/摄影/index.html","hash":"284717e02094a0ee6b7e90d4361c7b8260a71a31","modified":1481032550466},{"_id":"public/tags/人生思考/index.html","hash":"de1f812074fdb06ff95f8a4f5a932e9923670b06","modified":1481032550466},{"_id":"public/tags/学历/index.html","hash":"b4f4905abc4ef500d8271937ade7a185d9dec679","modified":1481032550466},{"_id":"public/tags/杂谈/index.html","hash":"91994ec9121a551d9d6dc118ba8fb7d01f3f4ae3","modified":1481032550466},{"_id":"public/tags/数据结构/index.html","hash":"caf1c245a9d41a99eb3420ba59b0a2ac08539fff","modified":1481032550466},{"_id":"public/tags/心情/index.html","hash":"02effb3c8e78533363e498ac58d93f740cf8c16d","modified":1481032550466},{"_id":"public/tags/JVM/index.html","hash":"9401f81caedfa63bcbbcfe713e8720d7557cfb65","modified":1481032550466},{"_id":"public/tags/类加载机制/index.html","hash":"5f6ccbafb5b710cd24e0f9ac137eb5b5128bc02e","modified":1481032550466},{"_id":"public/tags/架构分析/index.html","hash":"9dee3ec1f7169b638ea6da9fccd728c352960625","modified":1481032550466},{"_id":"public/tags/内存溢出/index.html","hash":"670fe0c85a349164c3752354007a2b10ea6220e1","modified":1481032550467},{"_id":"public/tags/垃圾回收/index.html","hash":"8eb932aaa73a66d3bd197b87b95aad5935a5f00b","modified":1481032550467},{"_id":"public/archives/index.html","hash":"43246832b4f4380b50a06ebe1d8ba1803a43b10d","modified":1481032550467},{"_id":"public/2016/11/28/20161128/index.html","hash":"1c32896ffdaa92657b01e6de3153447fddd47319","modified":1481032550467},{"_id":"public/2016/11/12/20161112-2/index.html","hash":"8a38c1230ae7792a9c14e0545b720deb2acfb887","modified":1481032550467},{"_id":"public/2016/11/12/20161112/index.html","hash":"3874826af3b2d6b1182659c7c8474871e3589e60","modified":1481032550467},{"_id":"public/2016/11/08/20161108/index.html","hash":"97b26306448be146ae160fea83ecfd9f04946251","modified":1481032550467},{"_id":"public/2016/11/03/20161103-1/index.html","hash":"94830a67c5e83325481ba606b660c21d9ca9c174","modified":1481032550467},{"_id":"public/2016/11/02/20161102-1/index.html","hash":"44b5c19b64a5b44c9f69be98aafabf5277e9af90","modified":1481032550467},{"_id":"public/2016/10/29/20161029-1/index.html","hash":"f10fe104434070dd487255aad75902b3a290fee3","modified":1481032550467},{"_id":"public/2016/10/21/20161021-1/index.html","hash":"4a1085a99669b0567e09f93c1e5f41bda1e4a230","modified":1481032550467},{"_id":"public/2016/10/20/20161020-1/index.html","hash":"04cdabe338e0d22aa2db94108e7ba32239669891","modified":1481032550467},{"_id":"public/2016/10/18/20161018-1/index.html","hash":"094c06676bc01ed73d0b33545c7c9d1f77dbf2b0","modified":1481032550467},{"_id":"public/2016/09/20/20160920-1/index.html","hash":"3ff144b56bab8c6a306f4970ee45b89611538899","modified":1481032550467},{"_id":"public/2016/09/08/20160908-2/index.html","hash":"6fae6ab4eae539b6da394019e7bea2e835cbd3e4","modified":1481032550467},{"_id":"public/2016/09/08/20160908-1/index.html","hash":"d9f34a45978c1b74e73b3168227c1ac63d7df0a4","modified":1481032550467},{"_id":"public/2016/08/24/20160826-1/index.html","hash":"c16ac8d666e26704df2fb569ee558016a648a2a5","modified":1481032550467},{"_id":"public/2016/08/20/20160820-1/index.html","hash":"e6314e4f156f69b50d5fb56d394a0213950eedae","modified":1481032550467},{"_id":"public/2016/08/07/20160807-1/index.html","hash":"94d50fe7fa2a6c6255a48a1ce7b85ed7639178f3","modified":1481032550467},{"_id":"public/2016/08/04/20160804-1/index.html","hash":"5fa19daf152f86e9041c40c2e69f1bc5facfc627","modified":1481032550467},{"_id":"public/2016/07/23/weekend-article-1/index.html","hash":"02860822b22dfbd36b3c553084c744219585d021","modified":1481032550467},{"_id":"public/2016/07/16/what-is-life-meaning/index.html","hash":"aad564d28d2c01515416b32a95922edaf28998de","modified":1481032550467},{"_id":"public/2016/07/12/jvm-gc-desc/index.html","hash":"33cd3d3f9f0747629c6df78e20efeebc7c82ac72","modified":1481032550467},{"_id":"public/2016/07/08/java-new-anas-20160708/index.html","hash":"c3221e9e44b04429355882af180aa03d8a627dfc","modified":1481032550467},{"_id":"public/2016/07/07/jvm-arch-anasi20160707/index.html","hash":"197696fed97590ee387c0c909b1b738963d52cb5","modified":1481032550467},{"_id":"public/2016/07/06/base_linkedlist_data_structure20160706/index.html","hash":"0191d26768fa360123cd82316b93fb1c25ed7660","modified":1481032550467},{"_id":"public/2016/07/06/good_start20160706/index.html","hash":"6892901a8832054bfc246836fefff6c8e0b39bb6","modified":1481032550468},{"_id":"public/categories/深入理解/index.html","hash":"4012f17a49c9cfcd9bcde93c0be36e5a31f530d1","modified":1481032550468},{"_id":"public/categories/随笔/index.html","hash":"4a217f4e8beaeea808223c66ee8e1a4ac7b5661d","modified":1481032550468},{"_id":"public/archives/page/2/index.html","hash":"f11ca7f81657d47b2e5b0d0262fd1579ae9670c8","modified":1481032550468},{"_id":"public/archives/2016/index.html","hash":"d5676a743510292edd0f71e95118ee177d9c7b80","modified":1481032550468},{"_id":"public/archives/2016/page/2/index.html","hash":"838de6fcb5c9f617ca372e02be58fa63db720115","modified":1481032550468},{"_id":"public/archives/2016/07/index.html","hash":"cac6835f5cbf76914fcaa6623b16f3fb5f561418","modified":1481032550468},{"_id":"public/archives/2016/11/index.html","hash":"e77d9406b46170307845ade85c5d7d6b9e976c12","modified":1481032550468},{"_id":"public/tags/随笔/index.html","hash":"ddc795211924c8b964039a68464e808328bb1991","modified":1481032550468},{"_id":"public/index.html","hash":"3167b8c3ee62157c3339a1681065b61b1de037a8","modified":1481032550468},{"_id":"public/page/2/index.html","hash":"ac734ee9ecb4a376597e313b3675206c37a5120a","modified":1481032550468},{"_id":"public/page/3/index.html","hash":"e39232e6ecbd8ee39921e0ad9a4e31e7184d90df","modified":1481032550468},{"_id":"public/CNAME","hash":"9de5ff4b58e99f10976749a3427b51685aea56f5","modified":1481032550500},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1481032550500},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1481032550500},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1481032550501},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1481032550501},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1481032550501},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1481032550501},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1481032550501},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1481032550501},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1481032550501},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1481032550501},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1481032550501},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1481032550501},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1481032550501},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1481032550501},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1481032550501},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1481032550501},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1481032550501},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1481032550502},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1481032550502},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1481032550502},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1481032550502},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1481032550502},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1481032550502},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1481032550502},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1481032551346},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1481032551355},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1481032551363},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1481032551375},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1481032551375},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1481032551375},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1481032551375},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1481032551375},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1481032551375},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1481032551376},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1481032551376},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1481032551376},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1481032551376},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1481032551376},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1481032551376},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1481032551376},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1481032551376},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1481032551376},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1481032551376},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1481032551376},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1481032551378},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1481032551378},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1481032551378},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1481032551378},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1481032551378},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1481032551378},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1481032551378},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1481032551379},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1481032551379},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1481032551379},{"_id":"public/css/main.css","hash":"7fc240aff84965b48eb45c1d278f6646f83ecd57","modified":1481032551379},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1481032551379},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1481032551379},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1481032551379},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1481032551379},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1481032551379},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1481032551379},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1481032551379},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1481032551379},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1481032551379},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1481032551379},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1481032551387}],"Category":[{"name":"深入理解","_id":"ciwdkjf3100061atiimjiiy5c"},{"name":"软件开发日常","_id":"ciwdkjf3d000b1atit6j3z2f0"},{"name":"随笔","_id":"ciwdkjf3h000g1atixmbulq7z"},{"name":"工具","_id":"ciwdkjf3l000m1atinsvebwhz"},{"name":"基础技术","_id":"ciwdkjf4b001i1atimq34gyig"}],"Data":[],"Page":[{"_content":"CTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"http://wantedonline.cn\"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n\n","source":"404.html","raw":"CTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"http://wantedonline.cn\"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n\n","date":"2016-07-16T15:10:03.000Z","updated":"2016-07-16T14:52:25.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ciwdkjf1800001ati80tkpz2k","content":"CTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"http://wantedonline.cn\" homepagename=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n\n","excerpt":"","more":"CTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"http://wantedonline.cn\"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n\n"},{"title":"about","date":"2016-07-06T07:20:20.000Z","type":"about","comments":0,"_content":"<h3>wantedonline.cn</h3>\n\n网络--开放，自由，个性的表达\n\nwantedonline这个名词的原始由来是我的大学线性代数老师的邮箱前缀--teacherwantedonline.一个很有个性很有思想的老师。\n\nwantedonline,可以理解为分享，开源，也可以理解为多愁善感和孤独。\n\n在这里，我可以开源代码，交流知识和技术；也可以分享心情，写写感悟~\n\n\n<h3>关于LouisWang</h3>\n\n真名王诚，90后，2014年毕业于川大，软件攻(cheng)城(xu)狮(yuan)一枚。专注Java后端，探索JVM，Java并发，大型分布式网站和架构，偶尔写点python~\n\n喜欢旅行，徒步和摄影(擅长乱拍)，喜欢各种新鲜事物~\n\n![me](http://o9z6i1a1s.bkt.clouddn.com/IMG_0598.jpg)\n\n<h3>联系我</h3>\n\n邮箱：<a href=\"mailto:wantedonline@outlook.com\">wantedonline@outlook.com</a>\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-07-06 15:20:20\ntype: \"about\"\ncomments: false\n---\n<h3>wantedonline.cn</h3>\n\n网络--开放，自由，个性的表达\n\nwantedonline这个名词的原始由来是我的大学线性代数老师的邮箱前缀--teacherwantedonline.一个很有个性很有思想的老师。\n\nwantedonline,可以理解为分享，开源，也可以理解为多愁善感和孤独。\n\n在这里，我可以开源代码，交流知识和技术；也可以分享心情，写写感悟~\n\n\n<h3>关于LouisWang</h3>\n\n真名王诚，90后，2014年毕业于川大，软件攻(cheng)城(xu)狮(yuan)一枚。专注Java后端，探索JVM，Java并发，大型分布式网站和架构，偶尔写点python~\n\n喜欢旅行，徒步和摄影(擅长乱拍)，喜欢各种新鲜事物~\n\n![me](http://o9z6i1a1s.bkt.clouddn.com/IMG_0598.jpg)\n\n<h3>联系我</h3>\n\n邮箱：<a href=\"mailto:wantedonline@outlook.com\">wantedonline@outlook.com</a>\n","updated":"2016-12-06T13:34:33.000Z","path":"about/index.html","layout":"page","_id":"ciwdkjf2v00021atihb643xel","content":"<h3>wantedonline.cn</h3>\n\n<p>网络–开放，自由，个性的表达</p>\n<p>wantedonline这个名词的原始由来是我的大学线性代数老师的邮箱前缀–teacherwantedonline.一个很有个性很有思想的老师。</p>\n<p>wantedonline,可以理解为分享，开源，也可以理解为多愁善感和孤独。</p>\n<p>在这里，我可以开源代码，交流知识和技术；也可以分享心情，写写感悟~</p>\n<h3>关于LouisWang</h3>\n\n<p>真名王诚，90后，2014年毕业于川大，软件攻(cheng)城(xu)狮(yuan)一枚。专注Java后端，探索JVM，Java并发，大型分布式网站和架构，偶尔写点python~</p>\n<p>喜欢旅行，徒步和摄影(擅长乱拍)，喜欢各种新鲜事物~</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/IMG_0598.jpg\" alt=\"me\"></p>\n<h3>联系我</h3>\n\n<p>邮箱：<a href=\"mailto:wantedonline@outlook.com\" target=\"_blank\" rel=\"external\">wantedonline@outlook.com</a></p>\n","excerpt":"","more":"<h3>wantedonline.cn</h3>\n\n<p>网络–开放，自由，个性的表达</p>\n<p>wantedonline这个名词的原始由来是我的大学线性代数老师的邮箱前缀–teacherwantedonline.一个很有个性很有思想的老师。</p>\n<p>wantedonline,可以理解为分享，开源，也可以理解为多愁善感和孤独。</p>\n<p>在这里，我可以开源代码，交流知识和技术；也可以分享心情，写写感悟~</p>\n<h3>关于LouisWang</h3>\n\n<p>真名王诚，90后，2014年毕业于川大，软件攻(cheng)城(xu)狮(yuan)一枚。专注Java后端，探索JVM，Java并发，大型分布式网站和架构，偶尔写点python~</p>\n<p>喜欢旅行，徒步和摄影(擅长乱拍)，喜欢各种新鲜事物~</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/IMG_0598.jpg\" alt=\"me\"></p>\n<h3>联系我</h3>\n\n<p>邮箱：<a href=\"mailto:wantedonline@outlook.com\">wantedonline@outlook.com</a></p>\n"},{"title":"archives","date":"2016-07-06T07:21:37.000Z","type":"archives","comments":0,"_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2016-07-06 15:21:37\ntype: \"archives\"\ncomments: false\n---\n","updated":"2016-07-16T14:52:25.000Z","path":"archives/index.html","layout":"page","_id":"ciwdkjf2y00041ati0he75z4m","content":"","excerpt":"","more":""},{"title":"标签","date":"2016-07-06T07:18:10.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2016-07-06 15:18:10\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-07-16T14:52:25.000Z","path":"tags/index.html","layout":"page","_id":"ciwdkjf9t00521atisnv6uupa","content":"","excerpt":"","more":""},{"title":"categories","date":"2016-07-06T07:53:02.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-07-06 15:53:02\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-07-16T14:52:25.000Z","path":"categories/index.html","layout":"page","_id":"ciwdkjf9v00531ati3yn7z0fd","content":"","excerpt":"","more":""}],"Post":[{"title":"微型秒杀模型的几点思考","date":"2016-08-04T12:25:10.000Z","_content":"最近工作上做了几个抢票的活动。其中有一部分抢票活动非常火爆，用户访问量非常大。任何一个系统，只要涉及到高并发，分布式就会变得复杂起来。本文是我对这类问题的一些思考和总结。后面有时间还将分享关于流控模型的一些思考，敬请期待。\n<!--more-->\n\n<h2>一 几点解释以及场景分析</h2>\n\n<h3>1.1 关于微型</h3>\n\n微型并不是说并发量比较小或者逻辑比较简单。微型的意思是指库存比较小。而库存就是指我们要抢的东西的总量。当库存比较大的时候，架构和逻辑复杂度也会有相应的变化。\n\n<h3>1.2 场景分析</h3>\n\n我们有100个宝贝，这些宝贝非常抢手，很多人都想得到。但很显然，最终真正得到宝贝的人只有100个。如果出现了超过100个人购买成功了就是超卖，最终超卖的部分只能通过协商解决了。但是从发起购买到购买成功的过程中会有一个支付的过程。必须支付成功才能购买成功。因此如果库存的增减不恰当可能会出现假卖的情况。也就是有可能很多人同一时间购买，但大家都没有付款成功。后面的人来买的话提示没有库存了，事实上这些宝贝还没有卖出去，最终导致想要买宝贝的人没能买到。整个购买模型如下图所示：\n\n![](http://o9z6i1a1s.bkt.clouddn.com/2016080401.png)\n\n这里的关键在于会异步调用第三方支付网站完成支付，在这个过程中，库存应该怎样减？在哪个步骤减？如何处理支付问题等很多问题会影响商品购买流程。\n\n<h3>1.3 一种假设</h3>\n\n如果我们的网站架构师单实例单库，很多问题会非常简单。我们可以通过加锁，限流，串行化等手段解决。但是这样的网站架构显然不满足高并发，分布式的要求，不能承受较大的点击量。因此，我们的秒杀模型都是基于多实例，分布式，Redis缓存，MySQL分表分库等架构。能够承受较大的并发。\n\n<h2>二 几种秒杀模型分析</h2>\n\n<h3>2.1 在支付前扣减库存</h3>\n\n为了防止超卖，我们可以在跳转到第三方支付进行支付之前扣减库存，这样可以有效防止商品因为超卖而导致的退款流程。但是很显然，这样会带来假卖的问题。假如一下子非常多的用户涌进来，他们占完了全部库存，但是迟迟不付款或者支付失败。导致后面的用户点击购买的时候提示没有库存而无法购买。一种稍微好点的办法是在支付成功时统计一下购买成功的总数，用总库存减去购买成功数得到剩余库存做一次修正。这样可以修正某些场景，但是如果有恶意用户，提交很多不支付的订单将库存消耗完(占着茅坑不拉屎),就会导致假卖问题。\n\n<h3>2.2 在支付成功后减库存</h3>\n\n为了防止2.1模型的假卖问题，我们将扣减库存问题放在支付成功后。这样可以解决假卖问题，但是会带来超卖问题。设想这样一种场景：大量用户点击购买，已经跳转到第三方支付网站进行支付，因为我们还没有获得支付结果，支付网关不会回调我们的支付完成逻辑，因此不会扣减库存。这样可以让无限的用户进入支付环节。最终如果这些用户全部支付成功显然会导致大量超卖的情况。\n\n<h3>2.3 排队模型</h3>\n\n联系到现实生活的场景，这样的问题最好的办法就是引入排队机制。排在前面的人可以成功购买，后面的人如果没有库存自然无法购买。大家按照时间顺序先后来，如果中间有人放弃，自然有后面的人顶替。这样自然保证了公平，公正。而且也不会出现超卖假卖问题。\n\n这个思路是对的，关键是如何实现的问题。\n\n<h2> 三 实现排队模型</h2>\n\n排队模型里有一个关键问题，就是锁票超时机制。比如我们买电影票，飞机票。都有一个锁票支付机制。超时之后如果没有完成支付则自动释放当前锁定的票资源，重新进入票池给别人购买。这样可以解决占着茅坑不拉屎的问题。\n\n<h3>3.1 单实例模型</h3>\n\n假如是单实例模型，我们可以将发起的请求全部放入一个数组，这个数组的长度就是宝贝数量(微型的意义在于宝贝数量较少，可以保证这里不会占用太多的空间)。启动一个线程，专门处理那些超时或者中途放弃的用户，以便让新用户能及时进入排队购买。但是假如这个线程挂掉或阻塞了，同样会导致假卖的问题。\n\n因此较好的办法就是设置自动超时的缓存，对于超时的用户自动清除，以便让后来的用户可以进入支付环节。这个缓存可以自己实现，也可以使用Guava。\n\n<h3>3.2 多实例分布式模型</h3>\n\n显然对于多实例分布式模型设置本地缓存是行不通的。多实例分布式的话可以借助Redis缓存。但是Redis缓存的超时都是以key为基础的。使用哪种缓存结构可以实现我们的需求？\n\n想来想去只有结合两种模式。Hash和String。使用String存放单个的用户，代表排队位。谁先支付完成谁就买到票。使用Hash统计排队人数。每次加入的时候，先遍历Hash，将因为超时失效的String用户剔除掉，这样就自然释放了资源。\n\n类似于这样：任何一个用户进来必须先获得一张入场券，这个入场券的有效时长是设定的超时时间。如果在这个时间内完成了支付，则购买成功。如果没有支付，则超时后下一名购买者进来的时候自动剔除，同时获得这张券。当一个用户购买成功后，释放这张券。每个用户进来的时候，都要保证当前发放的入场券总量不超过库存剩余总量。当发放的券总量等于库存剩余的时候，后面的人自然提示暂时没有空余票，稍后再试。\n\n这样我们就避免了另外开启线程来清除超时释放库存，也有效地在支付前控制了假卖，在很大几率上避免了超卖。但是存在一个问题，因为每个用户进来我们都要循环遍历一遍缓存，清理超时用户。因此库存不宜过大，否则循环耗时太长，用户体验不太好。\n\n<h2>四 总结和拓展</h2>\n\n对于秒杀模型，可能出现的问题就是假卖和超卖问题。而解决这个问题的办法就是排队和超时机制。如果我们的库存非常大(这样就不需要秒杀了)，在最后库存余量不是很大的情况下如果出现高并发没有排队和超时机制同样会出现超卖和假卖问题。为了保险起见，其实在运营手段上也应该采取一些办法，比如本来总共1000件商品，我只买980件，剩余20件用于补给超卖部分。考虑到用户体验和退款等，宁愿少卖也不多卖。当然这些应该根据具体的业务需求来决定。\n\n假如是库存非常大的情况，我们也可以考虑化大为小。在分布式环境下，将其平均分配，每台实例上卖一部分就将库存消化了。也可以引入大型排队系统和超时回调机制。当超时时自动触发一些业务流程。当然这些实现需要我们自己写很多代码，不能依赖Redis等缓存超时机制了。\n\n","source":"_posts/20160804-1.md","raw":"---\ntitle: '微型秒杀模型的几点思考'\ndate: 2016-08-04 20:25:10\ntags:\n - 模式设计\n - 高并发\n - 分布式\ncategories: 深入理解\n---\n最近工作上做了几个抢票的活动。其中有一部分抢票活动非常火爆，用户访问量非常大。任何一个系统，只要涉及到高并发，分布式就会变得复杂起来。本文是我对这类问题的一些思考和总结。后面有时间还将分享关于流控模型的一些思考，敬请期待。\n<!--more-->\n\n<h2>一 几点解释以及场景分析</h2>\n\n<h3>1.1 关于微型</h3>\n\n微型并不是说并发量比较小或者逻辑比较简单。微型的意思是指库存比较小。而库存就是指我们要抢的东西的总量。当库存比较大的时候，架构和逻辑复杂度也会有相应的变化。\n\n<h3>1.2 场景分析</h3>\n\n我们有100个宝贝，这些宝贝非常抢手，很多人都想得到。但很显然，最终真正得到宝贝的人只有100个。如果出现了超过100个人购买成功了就是超卖，最终超卖的部分只能通过协商解决了。但是从发起购买到购买成功的过程中会有一个支付的过程。必须支付成功才能购买成功。因此如果库存的增减不恰当可能会出现假卖的情况。也就是有可能很多人同一时间购买，但大家都没有付款成功。后面的人来买的话提示没有库存了，事实上这些宝贝还没有卖出去，最终导致想要买宝贝的人没能买到。整个购买模型如下图所示：\n\n![](http://o9z6i1a1s.bkt.clouddn.com/2016080401.png)\n\n这里的关键在于会异步调用第三方支付网站完成支付，在这个过程中，库存应该怎样减？在哪个步骤减？如何处理支付问题等很多问题会影响商品购买流程。\n\n<h3>1.3 一种假设</h3>\n\n如果我们的网站架构师单实例单库，很多问题会非常简单。我们可以通过加锁，限流，串行化等手段解决。但是这样的网站架构显然不满足高并发，分布式的要求，不能承受较大的点击量。因此，我们的秒杀模型都是基于多实例，分布式，Redis缓存，MySQL分表分库等架构。能够承受较大的并发。\n\n<h2>二 几种秒杀模型分析</h2>\n\n<h3>2.1 在支付前扣减库存</h3>\n\n为了防止超卖，我们可以在跳转到第三方支付进行支付之前扣减库存，这样可以有效防止商品因为超卖而导致的退款流程。但是很显然，这样会带来假卖的问题。假如一下子非常多的用户涌进来，他们占完了全部库存，但是迟迟不付款或者支付失败。导致后面的用户点击购买的时候提示没有库存而无法购买。一种稍微好点的办法是在支付成功时统计一下购买成功的总数，用总库存减去购买成功数得到剩余库存做一次修正。这样可以修正某些场景，但是如果有恶意用户，提交很多不支付的订单将库存消耗完(占着茅坑不拉屎),就会导致假卖问题。\n\n<h3>2.2 在支付成功后减库存</h3>\n\n为了防止2.1模型的假卖问题，我们将扣减库存问题放在支付成功后。这样可以解决假卖问题，但是会带来超卖问题。设想这样一种场景：大量用户点击购买，已经跳转到第三方支付网站进行支付，因为我们还没有获得支付结果，支付网关不会回调我们的支付完成逻辑，因此不会扣减库存。这样可以让无限的用户进入支付环节。最终如果这些用户全部支付成功显然会导致大量超卖的情况。\n\n<h3>2.3 排队模型</h3>\n\n联系到现实生活的场景，这样的问题最好的办法就是引入排队机制。排在前面的人可以成功购买，后面的人如果没有库存自然无法购买。大家按照时间顺序先后来，如果中间有人放弃，自然有后面的人顶替。这样自然保证了公平，公正。而且也不会出现超卖假卖问题。\n\n这个思路是对的，关键是如何实现的问题。\n\n<h2> 三 实现排队模型</h2>\n\n排队模型里有一个关键问题，就是锁票超时机制。比如我们买电影票，飞机票。都有一个锁票支付机制。超时之后如果没有完成支付则自动释放当前锁定的票资源，重新进入票池给别人购买。这样可以解决占着茅坑不拉屎的问题。\n\n<h3>3.1 单实例模型</h3>\n\n假如是单实例模型，我们可以将发起的请求全部放入一个数组，这个数组的长度就是宝贝数量(微型的意义在于宝贝数量较少，可以保证这里不会占用太多的空间)。启动一个线程，专门处理那些超时或者中途放弃的用户，以便让新用户能及时进入排队购买。但是假如这个线程挂掉或阻塞了，同样会导致假卖的问题。\n\n因此较好的办法就是设置自动超时的缓存，对于超时的用户自动清除，以便让后来的用户可以进入支付环节。这个缓存可以自己实现，也可以使用Guava。\n\n<h3>3.2 多实例分布式模型</h3>\n\n显然对于多实例分布式模型设置本地缓存是行不通的。多实例分布式的话可以借助Redis缓存。但是Redis缓存的超时都是以key为基础的。使用哪种缓存结构可以实现我们的需求？\n\n想来想去只有结合两种模式。Hash和String。使用String存放单个的用户，代表排队位。谁先支付完成谁就买到票。使用Hash统计排队人数。每次加入的时候，先遍历Hash，将因为超时失效的String用户剔除掉，这样就自然释放了资源。\n\n类似于这样：任何一个用户进来必须先获得一张入场券，这个入场券的有效时长是设定的超时时间。如果在这个时间内完成了支付，则购买成功。如果没有支付，则超时后下一名购买者进来的时候自动剔除，同时获得这张券。当一个用户购买成功后，释放这张券。每个用户进来的时候，都要保证当前发放的入场券总量不超过库存剩余总量。当发放的券总量等于库存剩余的时候，后面的人自然提示暂时没有空余票，稍后再试。\n\n这样我们就避免了另外开启线程来清除超时释放库存，也有效地在支付前控制了假卖，在很大几率上避免了超卖。但是存在一个问题，因为每个用户进来我们都要循环遍历一遍缓存，清理超时用户。因此库存不宜过大，否则循环耗时太长，用户体验不太好。\n\n<h2>四 总结和拓展</h2>\n\n对于秒杀模型，可能出现的问题就是假卖和超卖问题。而解决这个问题的办法就是排队和超时机制。如果我们的库存非常大(这样就不需要秒杀了)，在最后库存余量不是很大的情况下如果出现高并发没有排队和超时机制同样会出现超卖和假卖问题。为了保险起见，其实在运营手段上也应该采取一些办法，比如本来总共1000件商品，我只买980件，剩余20件用于补给超卖部分。考虑到用户体验和退款等，宁愿少卖也不多卖。当然这些应该根据具体的业务需求来决定。\n\n假如是库存非常大的情况，我们也可以考虑化大为小。在分布式环境下，将其平均分配，每台实例上卖一部分就将库存消化了。也可以引入大型排队系统和超时回调机制。当超时时自动触发一些业务流程。当然这些实现需要我们自己写很多代码，不能依赖Redis等缓存超时机制了。\n\n","slug":"20160804-1","published":1,"updated":"2016-08-07T15:26:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf2p00011atilmnwap7b","content":"<p>最近工作上做了几个抢票的活动。其中有一部分抢票活动非常火爆，用户访问量非常大。任何一个系统，只要涉及到高并发，分布式就会变得复杂起来。本文是我对这类问题的一些思考和总结。后面有时间还将分享关于流控模型的一些思考，敬请期待。<br><a id=\"more\"></a></p>\n<h2>一 几点解释以及场景分析</h2>\n\n<h3>1.1 关于微型</h3>\n\n<p>微型并不是说并发量比较小或者逻辑比较简单。微型的意思是指库存比较小。而库存就是指我们要抢的东西的总量。当库存比较大的时候，架构和逻辑复杂度也会有相应的变化。</p>\n<h3>1.2 场景分析</h3>\n\n<p>我们有100个宝贝，这些宝贝非常抢手，很多人都想得到。但很显然，最终真正得到宝贝的人只有100个。如果出现了超过100个人购买成功了就是超卖，最终超卖的部分只能通过协商解决了。但是从发起购买到购买成功的过程中会有一个支付的过程。必须支付成功才能购买成功。因此如果库存的增减不恰当可能会出现假卖的情况。也就是有可能很多人同一时间购买，但大家都没有付款成功。后面的人来买的话提示没有库存了，事实上这些宝贝还没有卖出去，最终导致想要买宝贝的人没能买到。整个购买模型如下图所示：</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016080401.png\" alt=\"\"></p>\n<p>这里的关键在于会异步调用第三方支付网站完成支付，在这个过程中，库存应该怎样减？在哪个步骤减？如何处理支付问题等很多问题会影响商品购买流程。</p>\n<h3>1.3 一种假设</h3>\n\n<p>如果我们的网站架构师单实例单库，很多问题会非常简单。我们可以通过加锁，限流，串行化等手段解决。但是这样的网站架构显然不满足高并发，分布式的要求，不能承受较大的点击量。因此，我们的秒杀模型都是基于多实例，分布式，Redis缓存，MySQL分表分库等架构。能够承受较大的并发。</p>\n<h2>二 几种秒杀模型分析</h2>\n\n<h3>2.1 在支付前扣减库存</h3>\n\n<p>为了防止超卖，我们可以在跳转到第三方支付进行支付之前扣减库存，这样可以有效防止商品因为超卖而导致的退款流程。但是很显然，这样会带来假卖的问题。假如一下子非常多的用户涌进来，他们占完了全部库存，但是迟迟不付款或者支付失败。导致后面的用户点击购买的时候提示没有库存而无法购买。一种稍微好点的办法是在支付成功时统计一下购买成功的总数，用总库存减去购买成功数得到剩余库存做一次修正。这样可以修正某些场景，但是如果有恶意用户，提交很多不支付的订单将库存消耗完(占着茅坑不拉屎),就会导致假卖问题。</p>\n<h3>2.2 在支付成功后减库存</h3>\n\n<p>为了防止2.1模型的假卖问题，我们将扣减库存问题放在支付成功后。这样可以解决假卖问题，但是会带来超卖问题。设想这样一种场景：大量用户点击购买，已经跳转到第三方支付网站进行支付，因为我们还没有获得支付结果，支付网关不会回调我们的支付完成逻辑，因此不会扣减库存。这样可以让无限的用户进入支付环节。最终如果这些用户全部支付成功显然会导致大量超卖的情况。</p>\n<h3>2.3 排队模型</h3>\n\n<p>联系到现实生活的场景，这样的问题最好的办法就是引入排队机制。排在前面的人可以成功购买，后面的人如果没有库存自然无法购买。大家按照时间顺序先后来，如果中间有人放弃，自然有后面的人顶替。这样自然保证了公平，公正。而且也不会出现超卖假卖问题。</p>\n<p>这个思路是对的，关键是如何实现的问题。</p>\n<h2> 三 实现排队模型</h2>\n\n<p>排队模型里有一个关键问题，就是锁票超时机制。比如我们买电影票，飞机票。都有一个锁票支付机制。超时之后如果没有完成支付则自动释放当前锁定的票资源，重新进入票池给别人购买。这样可以解决占着茅坑不拉屎的问题。</p>\n<h3>3.1 单实例模型</h3>\n\n<p>假如是单实例模型，我们可以将发起的请求全部放入一个数组，这个数组的长度就是宝贝数量(微型的意义在于宝贝数量较少，可以保证这里不会占用太多的空间)。启动一个线程，专门处理那些超时或者中途放弃的用户，以便让新用户能及时进入排队购买。但是假如这个线程挂掉或阻塞了，同样会导致假卖的问题。</p>\n<p>因此较好的办法就是设置自动超时的缓存，对于超时的用户自动清除，以便让后来的用户可以进入支付环节。这个缓存可以自己实现，也可以使用Guava。</p>\n<h3>3.2 多实例分布式模型</h3>\n\n<p>显然对于多实例分布式模型设置本地缓存是行不通的。多实例分布式的话可以借助Redis缓存。但是Redis缓存的超时都是以key为基础的。使用哪种缓存结构可以实现我们的需求？</p>\n<p>想来想去只有结合两种模式。Hash和String。使用String存放单个的用户，代表排队位。谁先支付完成谁就买到票。使用Hash统计排队人数。每次加入的时候，先遍历Hash，将因为超时失效的String用户剔除掉，这样就自然释放了资源。</p>\n<p>类似于这样：任何一个用户进来必须先获得一张入场券，这个入场券的有效时长是设定的超时时间。如果在这个时间内完成了支付，则购买成功。如果没有支付，则超时后下一名购买者进来的时候自动剔除，同时获得这张券。当一个用户购买成功后，释放这张券。每个用户进来的时候，都要保证当前发放的入场券总量不超过库存剩余总量。当发放的券总量等于库存剩余的时候，后面的人自然提示暂时没有空余票，稍后再试。</p>\n<p>这样我们就避免了另外开启线程来清除超时释放库存，也有效地在支付前控制了假卖，在很大几率上避免了超卖。但是存在一个问题，因为每个用户进来我们都要循环遍历一遍缓存，清理超时用户。因此库存不宜过大，否则循环耗时太长，用户体验不太好。</p>\n<h2>四 总结和拓展</h2>\n\n<p>对于秒杀模型，可能出现的问题就是假卖和超卖问题。而解决这个问题的办法就是排队和超时机制。如果我们的库存非常大(这样就不需要秒杀了)，在最后库存余量不是很大的情况下如果出现高并发没有排队和超时机制同样会出现超卖和假卖问题。为了保险起见，其实在运营手段上也应该采取一些办法，比如本来总共1000件商品，我只买980件，剩余20件用于补给超卖部分。考虑到用户体验和退款等，宁愿少卖也不多卖。当然这些应该根据具体的业务需求来决定。</p>\n<p>假如是库存非常大的情况，我们也可以考虑化大为小。在分布式环境下，将其平均分配，每台实例上卖一部分就将库存消化了。也可以引入大型排队系统和超时回调机制。当超时时自动触发一些业务流程。当然这些实现需要我们自己写很多代码，不能依赖Redis等缓存超时机制了。</p>\n","excerpt":"<p>最近工作上做了几个抢票的活动。其中有一部分抢票活动非常火爆，用户访问量非常大。任何一个系统，只要涉及到高并发，分布式就会变得复杂起来。本文是我对这类问题的一些思考和总结。后面有时间还将分享关于流控模型的一些思考，敬请期待。<br>","more":"</p>\n<h2>一 几点解释以及场景分析</h2>\n\n<h3>1.1 关于微型</h3>\n\n<p>微型并不是说并发量比较小或者逻辑比较简单。微型的意思是指库存比较小。而库存就是指我们要抢的东西的总量。当库存比较大的时候，架构和逻辑复杂度也会有相应的变化。</p>\n<h3>1.2 场景分析</h3>\n\n<p>我们有100个宝贝，这些宝贝非常抢手，很多人都想得到。但很显然，最终真正得到宝贝的人只有100个。如果出现了超过100个人购买成功了就是超卖，最终超卖的部分只能通过协商解决了。但是从发起购买到购买成功的过程中会有一个支付的过程。必须支付成功才能购买成功。因此如果库存的增减不恰当可能会出现假卖的情况。也就是有可能很多人同一时间购买，但大家都没有付款成功。后面的人来买的话提示没有库存了，事实上这些宝贝还没有卖出去，最终导致想要买宝贝的人没能买到。整个购买模型如下图所示：</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016080401.png\" alt=\"\"></p>\n<p>这里的关键在于会异步调用第三方支付网站完成支付，在这个过程中，库存应该怎样减？在哪个步骤减？如何处理支付问题等很多问题会影响商品购买流程。</p>\n<h3>1.3 一种假设</h3>\n\n<p>如果我们的网站架构师单实例单库，很多问题会非常简单。我们可以通过加锁，限流，串行化等手段解决。但是这样的网站架构显然不满足高并发，分布式的要求，不能承受较大的点击量。因此，我们的秒杀模型都是基于多实例，分布式，Redis缓存，MySQL分表分库等架构。能够承受较大的并发。</p>\n<h2>二 几种秒杀模型分析</h2>\n\n<h3>2.1 在支付前扣减库存</h3>\n\n<p>为了防止超卖，我们可以在跳转到第三方支付进行支付之前扣减库存，这样可以有效防止商品因为超卖而导致的退款流程。但是很显然，这样会带来假卖的问题。假如一下子非常多的用户涌进来，他们占完了全部库存，但是迟迟不付款或者支付失败。导致后面的用户点击购买的时候提示没有库存而无法购买。一种稍微好点的办法是在支付成功时统计一下购买成功的总数，用总库存减去购买成功数得到剩余库存做一次修正。这样可以修正某些场景，但是如果有恶意用户，提交很多不支付的订单将库存消耗完(占着茅坑不拉屎),就会导致假卖问题。</p>\n<h3>2.2 在支付成功后减库存</h3>\n\n<p>为了防止2.1模型的假卖问题，我们将扣减库存问题放在支付成功后。这样可以解决假卖问题，但是会带来超卖问题。设想这样一种场景：大量用户点击购买，已经跳转到第三方支付网站进行支付，因为我们还没有获得支付结果，支付网关不会回调我们的支付完成逻辑，因此不会扣减库存。这样可以让无限的用户进入支付环节。最终如果这些用户全部支付成功显然会导致大量超卖的情况。</p>\n<h3>2.3 排队模型</h3>\n\n<p>联系到现实生活的场景，这样的问题最好的办法就是引入排队机制。排在前面的人可以成功购买，后面的人如果没有库存自然无法购买。大家按照时间顺序先后来，如果中间有人放弃，自然有后面的人顶替。这样自然保证了公平，公正。而且也不会出现超卖假卖问题。</p>\n<p>这个思路是对的，关键是如何实现的问题。</p>\n<h2> 三 实现排队模型</h2>\n\n<p>排队模型里有一个关键问题，就是锁票超时机制。比如我们买电影票，飞机票。都有一个锁票支付机制。超时之后如果没有完成支付则自动释放当前锁定的票资源，重新进入票池给别人购买。这样可以解决占着茅坑不拉屎的问题。</p>\n<h3>3.1 单实例模型</h3>\n\n<p>假如是单实例模型，我们可以将发起的请求全部放入一个数组，这个数组的长度就是宝贝数量(微型的意义在于宝贝数量较少，可以保证这里不会占用太多的空间)。启动一个线程，专门处理那些超时或者中途放弃的用户，以便让新用户能及时进入排队购买。但是假如这个线程挂掉或阻塞了，同样会导致假卖的问题。</p>\n<p>因此较好的办法就是设置自动超时的缓存，对于超时的用户自动清除，以便让后来的用户可以进入支付环节。这个缓存可以自己实现，也可以使用Guava。</p>\n<h3>3.2 多实例分布式模型</h3>\n\n<p>显然对于多实例分布式模型设置本地缓存是行不通的。多实例分布式的话可以借助Redis缓存。但是Redis缓存的超时都是以key为基础的。使用哪种缓存结构可以实现我们的需求？</p>\n<p>想来想去只有结合两种模式。Hash和String。使用String存放单个的用户，代表排队位。谁先支付完成谁就买到票。使用Hash统计排队人数。每次加入的时候，先遍历Hash，将因为超时失效的String用户剔除掉，这样就自然释放了资源。</p>\n<p>类似于这样：任何一个用户进来必须先获得一张入场券，这个入场券的有效时长是设定的超时时间。如果在这个时间内完成了支付，则购买成功。如果没有支付，则超时后下一名购买者进来的时候自动剔除，同时获得这张券。当一个用户购买成功后，释放这张券。每个用户进来的时候，都要保证当前发放的入场券总量不超过库存剩余总量。当发放的券总量等于库存剩余的时候，后面的人自然提示暂时没有空余票，稍后再试。</p>\n<p>这样我们就避免了另外开启线程来清除超时释放库存，也有效地在支付前控制了假卖，在很大几率上避免了超卖。但是存在一个问题，因为每个用户进来我们都要循环遍历一遍缓存，清理超时用户。因此库存不宜过大，否则循环耗时太长，用户体验不太好。</p>\n<h2>四 总结和拓展</h2>\n\n<p>对于秒杀模型，可能出现的问题就是假卖和超卖问题。而解决这个问题的办法就是排队和超时机制。如果我们的库存非常大(这样就不需要秒杀了)，在最后库存余量不是很大的情况下如果出现高并发没有排队和超时机制同样会出现超卖和假卖问题。为了保险起见，其实在运营手段上也应该采取一些办法，比如本来总共1000件商品，我只买980件，剩余20件用于补给超卖部分。考虑到用户体验和退款等，宁愿少卖也不多卖。当然这些应该根据具体的业务需求来决定。</p>\n<p>假如是库存非常大的情况，我们也可以考虑化大为小。在分布式环境下，将其平均分配，每台实例上卖一部分就将库存消化了。也可以引入大型排队系统和超时回调机制。当超时时自动触发一些业务流程。当然这些实现需要我们自己写很多代码，不能依赖Redis等缓存超时机制了。</p>"},{"title":"软件开发日常思考","date":"2016-08-20T14:36:04.000Z","_content":"\n如果不算大学，我从事软件行业已经两年多了。这两年，我从一个制度流程非常完善的大公司跳到一个刚成立不久的小互联网公司(脑子没有进水，仅仅是为了追求初心而已)。本文将总结我这两年在软件开发中一些体会。\n\n<!--more-->\n\n<h2>流程很重要</h2>\n\n私下和前同事交流，发现大家最大的感受就是流程很重要。以前在老东家的时候，大家都痛恨老东家冗长的流程。出来了，没有流程了，才发现一团糟。给我们的工作带来的是混乱和效率低下。什么是流程？流程就是对某到工序的流程的抽象描述。任何一个人，只要按照这个流程走，就不会出错，效率和沟通也非常有效。一旦没有了流程，大家就按照自己的风格和喜好来做事。然后就有了各种低效的沟通和无穷尽的错误。\n\n日常办公有OA系统，有各种电子流。同样，软件开发从需求定义到交付维护，也可以有完整标准的流程。不管团队大小，其实都适用。有了流程，大家就有了标准。知道下一步应该怎样做。沟通自然也就高效了。\n\n<h2>需求应该是可控的</h2>\n\n程序员最大的痛苦就是需求一日三变。刚写完的代码还没有保存，产品经理就告诉你，需求变了；刚发布上线，还没有用三天，又告诉你需求变了。在这不断变化的需求中，我们的代码也变得千疮百孔，一个月之后，程序员自己都很难明白有些地方为啥要这样写了。\n\n如果团队碰上这样的产品，也就陷入了无限循环的更改和加班中了。一个不成熟的想法不应该作为需求交付给开发人员。这是对开发者最大的不尊重。项目管理者也应该拒绝这样的需求。\n\n<h2>TDD会成倍提高效率</h2>\n\nTDD，测试驱动开发。尊崇但愿测试。讲究测试覆盖率。理论上来说，我们发布的代码都应该测试覆盖率达到100%，开发者提交给测试的代码但愿测试用例应该覆盖了全部代码。但是现实是，我们抛弃了单元测试。理由往往只有一个，没有时间写单元测试。\n\n开发的时间被一压再压，上线之后就是无限的与bug作斗争。整个项目没有一个专门的test包来写一个单元测试用例。这样的代码质量可想而知。\n\n放弃了单元测试，等于放弃了质量。势必就会陷入加班的死循环中。\n\n<h2>代码规范很重要</h2>\n\n有多少团队会遵循一套统一的属于自己的编程规范？代码规范应该作为团队成员必须遵循的军规。每个新成员加入时都应该培训代码规范。在开发过程中也应该强制遵循代码规范。这样的代码才能交给维护团队去维护。\n\n\n","source":"_posts/20160820-1.md","raw":"---\ntitle: '软件开发日常思考'\ndate: 2016-08-20 22:36:04\ntags: \n - 周末随笔\n - 软件开发\n - IT生涯\ncategories: 软件开发日常\n---\n\n如果不算大学，我从事软件行业已经两年多了。这两年，我从一个制度流程非常完善的大公司跳到一个刚成立不久的小互联网公司(脑子没有进水，仅仅是为了追求初心而已)。本文将总结我这两年在软件开发中一些体会。\n\n<!--more-->\n\n<h2>流程很重要</h2>\n\n私下和前同事交流，发现大家最大的感受就是流程很重要。以前在老东家的时候，大家都痛恨老东家冗长的流程。出来了，没有流程了，才发现一团糟。给我们的工作带来的是混乱和效率低下。什么是流程？流程就是对某到工序的流程的抽象描述。任何一个人，只要按照这个流程走，就不会出错，效率和沟通也非常有效。一旦没有了流程，大家就按照自己的风格和喜好来做事。然后就有了各种低效的沟通和无穷尽的错误。\n\n日常办公有OA系统，有各种电子流。同样，软件开发从需求定义到交付维护，也可以有完整标准的流程。不管团队大小，其实都适用。有了流程，大家就有了标准。知道下一步应该怎样做。沟通自然也就高效了。\n\n<h2>需求应该是可控的</h2>\n\n程序员最大的痛苦就是需求一日三变。刚写完的代码还没有保存，产品经理就告诉你，需求变了；刚发布上线，还没有用三天，又告诉你需求变了。在这不断变化的需求中，我们的代码也变得千疮百孔，一个月之后，程序员自己都很难明白有些地方为啥要这样写了。\n\n如果团队碰上这样的产品，也就陷入了无限循环的更改和加班中了。一个不成熟的想法不应该作为需求交付给开发人员。这是对开发者最大的不尊重。项目管理者也应该拒绝这样的需求。\n\n<h2>TDD会成倍提高效率</h2>\n\nTDD，测试驱动开发。尊崇但愿测试。讲究测试覆盖率。理论上来说，我们发布的代码都应该测试覆盖率达到100%，开发者提交给测试的代码但愿测试用例应该覆盖了全部代码。但是现实是，我们抛弃了单元测试。理由往往只有一个，没有时间写单元测试。\n\n开发的时间被一压再压，上线之后就是无限的与bug作斗争。整个项目没有一个专门的test包来写一个单元测试用例。这样的代码质量可想而知。\n\n放弃了单元测试，等于放弃了质量。势必就会陷入加班的死循环中。\n\n<h2>代码规范很重要</h2>\n\n有多少团队会遵循一套统一的属于自己的编程规范？代码规范应该作为团队成员必须遵循的军规。每个新成员加入时都应该培训代码规范。在开发过程中也应该强制遵循代码规范。这样的代码才能交给维护团队去维护。\n\n\n","slug":"20160820-1","published":1,"updated":"2016-08-20T15:41:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf2w00031atiy8qxo52h","content":"<p>如果不算大学，我从事软件行业已经两年多了。这两年，我从一个制度流程非常完善的大公司跳到一个刚成立不久的小互联网公司(脑子没有进水，仅仅是为了追求初心而已)。本文将总结我这两年在软件开发中一些体会。</p>\n<a id=\"more\"></a>\n<h2>流程很重要</h2>\n\n<p>私下和前同事交流，发现大家最大的感受就是流程很重要。以前在老东家的时候，大家都痛恨老东家冗长的流程。出来了，没有流程了，才发现一团糟。给我们的工作带来的是混乱和效率低下。什么是流程？流程就是对某到工序的流程的抽象描述。任何一个人，只要按照这个流程走，就不会出错，效率和沟通也非常有效。一旦没有了流程，大家就按照自己的风格和喜好来做事。然后就有了各种低效的沟通和无穷尽的错误。</p>\n<p>日常办公有OA系统，有各种电子流。同样，软件开发从需求定义到交付维护，也可以有完整标准的流程。不管团队大小，其实都适用。有了流程，大家就有了标准。知道下一步应该怎样做。沟通自然也就高效了。</p>\n<h2>需求应该是可控的</h2>\n\n<p>程序员最大的痛苦就是需求一日三变。刚写完的代码还没有保存，产品经理就告诉你，需求变了；刚发布上线，还没有用三天，又告诉你需求变了。在这不断变化的需求中，我们的代码也变得千疮百孔，一个月之后，程序员自己都很难明白有些地方为啥要这样写了。</p>\n<p>如果团队碰上这样的产品，也就陷入了无限循环的更改和加班中了。一个不成熟的想法不应该作为需求交付给开发人员。这是对开发者最大的不尊重。项目管理者也应该拒绝这样的需求。</p>\n<h2>TDD会成倍提高效率</h2>\n\n<p>TDD，测试驱动开发。尊崇但愿测试。讲究测试覆盖率。理论上来说，我们发布的代码都应该测试覆盖率达到100%，开发者提交给测试的代码但愿测试用例应该覆盖了全部代码。但是现实是，我们抛弃了单元测试。理由往往只有一个，没有时间写单元测试。</p>\n<p>开发的时间被一压再压，上线之后就是无限的与bug作斗争。整个项目没有一个专门的test包来写一个单元测试用例。这样的代码质量可想而知。</p>\n<p>放弃了单元测试，等于放弃了质量。势必就会陷入加班的死循环中。</p>\n<h2>代码规范很重要</h2>\n\n<p>有多少团队会遵循一套统一的属于自己的编程规范？代码规范应该作为团队成员必须遵循的军规。每个新成员加入时都应该培训代码规范。在开发过程中也应该强制遵循代码规范。这样的代码才能交给维护团队去维护。</p>\n","excerpt":"<p>如果不算大学，我从事软件行业已经两年多了。这两年，我从一个制度流程非常完善的大公司跳到一个刚成立不久的小互联网公司(脑子没有进水，仅仅是为了追求初心而已)。本文将总结我这两年在软件开发中一些体会。</p>","more":"<h2>流程很重要</h2>\n\n<p>私下和前同事交流，发现大家最大的感受就是流程很重要。以前在老东家的时候，大家都痛恨老东家冗长的流程。出来了，没有流程了，才发现一团糟。给我们的工作带来的是混乱和效率低下。什么是流程？流程就是对某到工序的流程的抽象描述。任何一个人，只要按照这个流程走，就不会出错，效率和沟通也非常有效。一旦没有了流程，大家就按照自己的风格和喜好来做事。然后就有了各种低效的沟通和无穷尽的错误。</p>\n<p>日常办公有OA系统，有各种电子流。同样，软件开发从需求定义到交付维护，也可以有完整标准的流程。不管团队大小，其实都适用。有了流程，大家就有了标准。知道下一步应该怎样做。沟通自然也就高效了。</p>\n<h2>需求应该是可控的</h2>\n\n<p>程序员最大的痛苦就是需求一日三变。刚写完的代码还没有保存，产品经理就告诉你，需求变了；刚发布上线，还没有用三天，又告诉你需求变了。在这不断变化的需求中，我们的代码也变得千疮百孔，一个月之后，程序员自己都很难明白有些地方为啥要这样写了。</p>\n<p>如果团队碰上这样的产品，也就陷入了无限循环的更改和加班中了。一个不成熟的想法不应该作为需求交付给开发人员。这是对开发者最大的不尊重。项目管理者也应该拒绝这样的需求。</p>\n<h2>TDD会成倍提高效率</h2>\n\n<p>TDD，测试驱动开发。尊崇但愿测试。讲究测试覆盖率。理论上来说，我们发布的代码都应该测试覆盖率达到100%，开发者提交给测试的代码但愿测试用例应该覆盖了全部代码。但是现实是，我们抛弃了单元测试。理由往往只有一个，没有时间写单元测试。</p>\n<p>开发的时间被一压再压，上线之后就是无限的与bug作斗争。整个项目没有一个专门的test包来写一个单元测试用例。这样的代码质量可想而知。</p>\n<p>放弃了单元测试，等于放弃了质量。势必就会陷入加班的死循环中。</p>\n<h2>代码规范很重要</h2>\n\n<p>有多少团队会遵循一套统一的属于自己的编程规范？代码规范应该作为团队成员必须遵循的军规。每个新成员加入时都应该培训代码规范。在开发过程中也应该强制遵循代码规范。这样的代码才能交给维护团队去维护。</p>"},{"title":"忧愁的香烟","date":"2016-08-07T15:28:06.000Z","_content":"\n今晚(2016-08-07)夜跑结束，一种孤独和忧愁涌上心头。便买来香烟一个人坐在草地上思考了人生……\n\n<!--more-->\n\n我点燃一根香烟\n一个人静静地坐在草地上\n\n偶尔有路人带着疲惫和忧愁从我身边目视前方走过\n我不知道他们在忧愁什么\n就像他们不知道我在忧愁什么一样\n\n不远处三位大妈\n正在谈论着彼此儿女的婚姻\n她们不理解儿女的一些事儿\n我也不理解所谓的爱情和婚姻\n\n我静静地坐在草地上\n抽了一根又一根的香烟\n今夜，我愿就这样沉睡下去\n带着我的香烟和忧愁\n永远地沉睡下去\n\n","source":"_posts/20160807-1.md","raw":"---\ntitle: '忧愁的香烟'\ndate: 2016-08-07 23:28:06\ntags:\n - 生活\n - 孤独\n - 随笔\n - 小诗\ncategories: 随笔\n---\n\n今晚(2016-08-07)夜跑结束，一种孤独和忧愁涌上心头。便买来香烟一个人坐在草地上思考了人生……\n\n<!--more-->\n\n我点燃一根香烟\n一个人静静地坐在草地上\n\n偶尔有路人带着疲惫和忧愁从我身边目视前方走过\n我不知道他们在忧愁什么\n就像他们不知道我在忧愁什么一样\n\n不远处三位大妈\n正在谈论着彼此儿女的婚姻\n她们不理解儿女的一些事儿\n我也不理解所谓的爱情和婚姻\n\n我静静地坐在草地上\n抽了一根又一根的香烟\n今夜，我愿就这样沉睡下去\n带着我的香烟和忧愁\n永远地沉睡下去\n\n","slug":"20160807-1","published":1,"updated":"2016-08-07T15:34:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3200071ati0c3z5pxs","content":"<p>今晚(2016-08-07)夜跑结束，一种孤独和忧愁涌上心头。便买来香烟一个人坐在草地上思考了人生……</p>\n<a id=\"more\"></a>\n<p>我点燃一根香烟<br>一个人静静地坐在草地上</p>\n<p>偶尔有路人带着疲惫和忧愁从我身边目视前方走过<br>我不知道他们在忧愁什么<br>就像他们不知道我在忧愁什么一样</p>\n<p>不远处三位大妈<br>正在谈论着彼此儿女的婚姻<br>她们不理解儿女的一些事儿<br>我也不理解所谓的爱情和婚姻</p>\n<p>我静静地坐在草地上<br>抽了一根又一根的香烟<br>今夜，我愿就这样沉睡下去<br>带着我的香烟和忧愁<br>永远地沉睡下去</p>\n","excerpt":"<p>今晚(2016-08-07)夜跑结束，一种孤独和忧愁涌上心头。便买来香烟一个人坐在草地上思考了人生……</p>","more":"<p>我点燃一根香烟<br>一个人静静地坐在草地上</p>\n<p>偶尔有路人带着疲惫和忧愁从我身边目视前方走过<br>我不知道他们在忧愁什么<br>就像他们不知道我在忧愁什么一样</p>\n<p>不远处三位大妈<br>正在谈论着彼此儿女的婚姻<br>她们不理解儿女的一些事儿<br>我也不理解所谓的爱情和婚姻</p>\n<p>我静静地坐在草地上<br>抽了一根又一根的香烟<br>今夜，我愿就这样沉睡下去<br>带着我的香烟和忧愁<br>永远地沉睡下去</p>"},{"title":"亲自动手做的工具(一)","date":"2016-08-24T09:46:29.000Z","_content":"结合工作需要，做了一个为Javaer Web开发者提供的自动化PO文件生成工具，同时支持生成docx格式的数据字典\n\n<!--more-->\n\n<h2>工具用途</h2>\n\n在Java Web开发过程中，我们总要手动去生成一些PO类(Persistent Object),这些类一般映射到数据库中的一张表。这些代码简单，模式化程度高。因此做了这个工具来简化开发者的工作。\n\n本工具为一个maven 工程，使用非常简单，效率极高。\n\n<h2>目前支持</h2>\n\n \n- 批量生成所配置的数据库的全部表；\n- 自定义类后缀\n- 自定义生成类路径\n- 根据数据库表字段注释生成java文件字段注释\n- 自定义排除特定表的生成类\n\n<h2>后续可能支持特性</h2>\n\n- 自定义生成特定表的生成类\n- 更加智能化和易用化\n\n<h2>约束</h2>\n\n要生成开发者友好的文件，建议数据库表名，字段名采用驼峰命名法。命名合符Java规范。\n\n<h2>使用方法</h2>\n\nStep 1 down下本工程，导入Maven工程：\n![](http://o9z6i1a1s.bkt.clouddn.com/2016082401.png)\n\n导入成功后，工程目录如下：\n![](http://o9z6i1a1s.bkt.clouddn.com/2016082402.png)\n\n*注意： 如果要生成docx格式的数据字典，需要依赖POI，直接使用maven导入poi依赖会报错，因此采用本地导入，建了一个lib目录，已经将依赖包放到lib目录，在pom配置文件中配置好了本地依赖*\n\nStep2 根据自己的需求，修改配置文件，配置文件在工程根目录下，文件名字是 **datasource.properties**\n![](http://o9z6i1a1s.bkt.clouddn.com/2014082403.png)\n**配置说明**\n\n- mysqlDriver 目前仅支持mysql，因此这里可以不用变(后续可能会支持多种数据库)\n- globalUserName 如果你有很多数据库要生成，并且这些数据库的用户名一样，可以配置这个变量\n- globalPassword 同上，这里是配置统一的密码\n- url_jdbc_your_db_name 单独配置某个数据库的链接url，注意，url_这个前缀必须统一\n- username_your_db_name 单独配置某个数据库的用户名，这里前缀必须有，如果全部数据库都用一个用户名，这里可以缺省不配\n- password_your_db_name 同上，配置密码，如果全局密码一致，可以缺省\n- exclude_your_db_name 跳过生成PO的表,使用英文状态下的逗号分隔 前缀固定 databaseName必须是所连接的数据库真实名称\n- po_package 你要生成的PO文件包名，使用标准的包，用 . 分隔，生成的PO文件会直接放到这下面，方便直接拖入你的工程\n- po_suffix 生成的PO文件后缀，默认是xxxPO.java，可以自定义\n- serialize 是否需要序列化，默认是false，如果该选项为true，则自动实现序列化接口\n\n*可以一次配置多个数据库，只要按照格式注意前缀和数据库名，如果连接失败会报错*\n\n配置完之后，找到入口Main.java, 按下F11 运行工程即可。如果需要生成数据字段，则将入参配置为true\n![](http://o9z6i1a1s.bkt.clouddn.com/2016082404.png)\n\n如果没有任何输出就结束了工程就是好结果。\n\n如果有输出，根据输出排错\n\n<h2>正确生成的结果</h2>\n\n生成的部分文件\n![](http://o9z6i1a1s.bkt.clouddn.com/2016082405.png)\n文件内容\n![](http://o9z6i1a1s.bkt.clouddn.com/2014082406.png)\n生成的数据字典样式\n![](http://o9z6i1a1s.bkt.clouddn.com/2016082407.png)\n\n<h2>关键源码说明：</h2>\n\nMain.java 启动类\n\nDataBaseEntity.java 业务类，具体的生产逻辑都在这里\n\nutils包中\n\nConfigParser.java 配置文件解析类，校验配置有效性也在这里完成\n\nConnectionHelper.java Mysql 链接获取以及操作类\n\n<h2>致谢</h2>\n\n生成PO文件的逻辑是在同事的基础上修改完成，修改引用了同事(仇老板)的parse(我修改为了parseTable)，自动生成字段，get，set方法，文件输出等逻辑，在此表示感谢~~~\n\n<h2>获取项目</h2>\n\n[GitHub地址](https://github.com/34benma/PORobot)\n\n\n","source":"_posts/20160826-1.md","raw":"---\ntitle: '亲自动手做的工具(一)'\ndate: 2016-08-24 17:46:29\ntags: \n - 工具\n - 生产效率\ncategories: 工具\n---\n结合工作需要，做了一个为Javaer Web开发者提供的自动化PO文件生成工具，同时支持生成docx格式的数据字典\n\n<!--more-->\n\n<h2>工具用途</h2>\n\n在Java Web开发过程中，我们总要手动去生成一些PO类(Persistent Object),这些类一般映射到数据库中的一张表。这些代码简单，模式化程度高。因此做了这个工具来简化开发者的工作。\n\n本工具为一个maven 工程，使用非常简单，效率极高。\n\n<h2>目前支持</h2>\n\n \n- 批量生成所配置的数据库的全部表；\n- 自定义类后缀\n- 自定义生成类路径\n- 根据数据库表字段注释生成java文件字段注释\n- 自定义排除特定表的生成类\n\n<h2>后续可能支持特性</h2>\n\n- 自定义生成特定表的生成类\n- 更加智能化和易用化\n\n<h2>约束</h2>\n\n要生成开发者友好的文件，建议数据库表名，字段名采用驼峰命名法。命名合符Java规范。\n\n<h2>使用方法</h2>\n\nStep 1 down下本工程，导入Maven工程：\n![](http://o9z6i1a1s.bkt.clouddn.com/2016082401.png)\n\n导入成功后，工程目录如下：\n![](http://o9z6i1a1s.bkt.clouddn.com/2016082402.png)\n\n*注意： 如果要生成docx格式的数据字典，需要依赖POI，直接使用maven导入poi依赖会报错，因此采用本地导入，建了一个lib目录，已经将依赖包放到lib目录，在pom配置文件中配置好了本地依赖*\n\nStep2 根据自己的需求，修改配置文件，配置文件在工程根目录下，文件名字是 **datasource.properties**\n![](http://o9z6i1a1s.bkt.clouddn.com/2014082403.png)\n**配置说明**\n\n- mysqlDriver 目前仅支持mysql，因此这里可以不用变(后续可能会支持多种数据库)\n- globalUserName 如果你有很多数据库要生成，并且这些数据库的用户名一样，可以配置这个变量\n- globalPassword 同上，这里是配置统一的密码\n- url_jdbc_your_db_name 单独配置某个数据库的链接url，注意，url_这个前缀必须统一\n- username_your_db_name 单独配置某个数据库的用户名，这里前缀必须有，如果全部数据库都用一个用户名，这里可以缺省不配\n- password_your_db_name 同上，配置密码，如果全局密码一致，可以缺省\n- exclude_your_db_name 跳过生成PO的表,使用英文状态下的逗号分隔 前缀固定 databaseName必须是所连接的数据库真实名称\n- po_package 你要生成的PO文件包名，使用标准的包，用 . 分隔，生成的PO文件会直接放到这下面，方便直接拖入你的工程\n- po_suffix 生成的PO文件后缀，默认是xxxPO.java，可以自定义\n- serialize 是否需要序列化，默认是false，如果该选项为true，则自动实现序列化接口\n\n*可以一次配置多个数据库，只要按照格式注意前缀和数据库名，如果连接失败会报错*\n\n配置完之后，找到入口Main.java, 按下F11 运行工程即可。如果需要生成数据字段，则将入参配置为true\n![](http://o9z6i1a1s.bkt.clouddn.com/2016082404.png)\n\n如果没有任何输出就结束了工程就是好结果。\n\n如果有输出，根据输出排错\n\n<h2>正确生成的结果</h2>\n\n生成的部分文件\n![](http://o9z6i1a1s.bkt.clouddn.com/2016082405.png)\n文件内容\n![](http://o9z6i1a1s.bkt.clouddn.com/2014082406.png)\n生成的数据字典样式\n![](http://o9z6i1a1s.bkt.clouddn.com/2016082407.png)\n\n<h2>关键源码说明：</h2>\n\nMain.java 启动类\n\nDataBaseEntity.java 业务类，具体的生产逻辑都在这里\n\nutils包中\n\nConfigParser.java 配置文件解析类，校验配置有效性也在这里完成\n\nConnectionHelper.java Mysql 链接获取以及操作类\n\n<h2>致谢</h2>\n\n生成PO文件的逻辑是在同事的基础上修改完成，修改引用了同事(仇老板)的parse(我修改为了parseTable)，自动生成字段，get，set方法，文件输出等逻辑，在此表示感谢~~~\n\n<h2>获取项目</h2>\n\n[GitHub地址](https://github.com/34benma/PORobot)\n\n\n","slug":"20160826-1","published":1,"updated":"2016-09-20T11:58:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3400081aticnaj4r4j","content":"<p>结合工作需要，做了一个为Javaer Web开发者提供的自动化PO文件生成工具，同时支持生成docx格式的数据字典</p>\n<a id=\"more\"></a>\n<h2>工具用途</h2>\n\n<p>在Java Web开发过程中，我们总要手动去生成一些PO类(Persistent Object),这些类一般映射到数据库中的一张表。这些代码简单，模式化程度高。因此做了这个工具来简化开发者的工作。</p>\n<p>本工具为一个maven 工程，使用非常简单，效率极高。</p>\n<h2>目前支持</h2>\n\n\n<ul>\n<li>批量生成所配置的数据库的全部表；</li>\n<li>自定义类后缀</li>\n<li>自定义生成类路径</li>\n<li>根据数据库表字段注释生成java文件字段注释</li>\n<li>自定义排除特定表的生成类</li>\n</ul>\n<h2>后续可能支持特性</h2>\n\n<ul>\n<li>自定义生成特定表的生成类</li>\n<li>更加智能化和易用化</li>\n</ul>\n<h2>约束</h2>\n\n<p>要生成开发者友好的文件，建议数据库表名，字段名采用驼峰命名法。命名合符Java规范。</p>\n<h2>使用方法</h2>\n\n<p>Step 1 down下本工程，导入Maven工程：<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016082401.png\" alt=\"\"></p>\n<p>导入成功后，工程目录如下：<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016082402.png\" alt=\"\"></p>\n<p><em>注意： 如果要生成docx格式的数据字典，需要依赖POI，直接使用maven导入poi依赖会报错，因此采用本地导入，建了一个lib目录，已经将依赖包放到lib目录，在pom配置文件中配置好了本地依赖</em></p>\n<p>Step2 根据自己的需求，修改配置文件，配置文件在工程根目录下，文件名字是 <strong>datasource.properties</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2014082403.png\" alt=\"\"><br><strong>配置说明</strong></p>\n<ul>\n<li>mysqlDriver 目前仅支持mysql，因此这里可以不用变(后续可能会支持多种数据库)</li>\n<li>globalUserName 如果你有很多数据库要生成，并且这些数据库的用户名一样，可以配置这个变量</li>\n<li>globalPassword 同上，这里是配置统一的密码</li>\n<li>url_jdbc_your_db<em>name 单独配置某个数据库的链接url，注意，url</em>这个前缀必须统一</li>\n<li>username_your_db_name 单独配置某个数据库的用户名，这里前缀必须有，如果全部数据库都用一个用户名，这里可以缺省不配</li>\n<li>password_your_db_name 同上，配置密码，如果全局密码一致，可以缺省</li>\n<li>exclude_your_db_name 跳过生成PO的表,使用英文状态下的逗号分隔 前缀固定 databaseName必须是所连接的数据库真实名称</li>\n<li>po_package 你要生成的PO文件包名，使用标准的包，用 . 分隔，生成的PO文件会直接放到这下面，方便直接拖入你的工程</li>\n<li>po_suffix 生成的PO文件后缀，默认是xxxPO.java，可以自定义</li>\n<li>serialize 是否需要序列化，默认是false，如果该选项为true，则自动实现序列化接口</li>\n</ul>\n<p><em>可以一次配置多个数据库，只要按照格式注意前缀和数据库名，如果连接失败会报错</em></p>\n<p>配置完之后，找到入口Main.java, 按下F11 运行工程即可。如果需要生成数据字段，则将入参配置为true<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016082404.png\" alt=\"\"></p>\n<p>如果没有任何输出就结束了工程就是好结果。</p>\n<p>如果有输出，根据输出排错</p>\n<h2>正确生成的结果</h2>\n\n<p>生成的部分文件<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016082405.png\" alt=\"\"><br>文件内容<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2014082406.png\" alt=\"\"><br>生成的数据字典样式<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016082407.png\" alt=\"\"></p>\n<h2>关键源码说明：</h2>\n\n<p>Main.java 启动类</p>\n<p>DataBaseEntity.java 业务类，具体的生产逻辑都在这里</p>\n<p>utils包中</p>\n<p>ConfigParser.java 配置文件解析类，校验配置有效性也在这里完成</p>\n<p>ConnectionHelper.java Mysql 链接获取以及操作类</p>\n<h2>致谢</h2>\n\n<p>生成PO文件的逻辑是在同事的基础上修改完成，修改引用了同事(仇老板)的parse(我修改为了parseTable)，自动生成字段，get，set方法，文件输出等逻辑，在此表示感谢~~~</p>\n<h2>获取项目</h2>\n\n<p><a href=\"https://github.com/34benma/PORobot\" target=\"_blank\" rel=\"external\">GitHub地址</a></p>\n","excerpt":"<p>结合工作需要，做了一个为Javaer Web开发者提供的自动化PO文件生成工具，同时支持生成docx格式的数据字典</p>","more":"<h2>工具用途</h2>\n\n<p>在Java Web开发过程中，我们总要手动去生成一些PO类(Persistent Object),这些类一般映射到数据库中的一张表。这些代码简单，模式化程度高。因此做了这个工具来简化开发者的工作。</p>\n<p>本工具为一个maven 工程，使用非常简单，效率极高。</p>\n<h2>目前支持</h2>\n\n\n<ul>\n<li>批量生成所配置的数据库的全部表；</li>\n<li>自定义类后缀</li>\n<li>自定义生成类路径</li>\n<li>根据数据库表字段注释生成java文件字段注释</li>\n<li>自定义排除特定表的生成类</li>\n</ul>\n<h2>后续可能支持特性</h2>\n\n<ul>\n<li>自定义生成特定表的生成类</li>\n<li>更加智能化和易用化</li>\n</ul>\n<h2>约束</h2>\n\n<p>要生成开发者友好的文件，建议数据库表名，字段名采用驼峰命名法。命名合符Java规范。</p>\n<h2>使用方法</h2>\n\n<p>Step 1 down下本工程，导入Maven工程：<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016082401.png\" alt=\"\"></p>\n<p>导入成功后，工程目录如下：<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016082402.png\" alt=\"\"></p>\n<p><em>注意： 如果要生成docx格式的数据字典，需要依赖POI，直接使用maven导入poi依赖会报错，因此采用本地导入，建了一个lib目录，已经将依赖包放到lib目录，在pom配置文件中配置好了本地依赖</em></p>\n<p>Step2 根据自己的需求，修改配置文件，配置文件在工程根目录下，文件名字是 <strong>datasource.properties</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2014082403.png\" alt=\"\"><br><strong>配置说明</strong></p>\n<ul>\n<li>mysqlDriver 目前仅支持mysql，因此这里可以不用变(后续可能会支持多种数据库)</li>\n<li>globalUserName 如果你有很多数据库要生成，并且这些数据库的用户名一样，可以配置这个变量</li>\n<li>globalPassword 同上，这里是配置统一的密码</li>\n<li>url_jdbc_your_db<em>name 单独配置某个数据库的链接url，注意，url</em>这个前缀必须统一</li>\n<li>username_your_db_name 单独配置某个数据库的用户名，这里前缀必须有，如果全部数据库都用一个用户名，这里可以缺省不配</li>\n<li>password_your_db_name 同上，配置密码，如果全局密码一致，可以缺省</li>\n<li>exclude_your_db_name 跳过生成PO的表,使用英文状态下的逗号分隔 前缀固定 databaseName必须是所连接的数据库真实名称</li>\n<li>po_package 你要生成的PO文件包名，使用标准的包，用 . 分隔，生成的PO文件会直接放到这下面，方便直接拖入你的工程</li>\n<li>po_suffix 生成的PO文件后缀，默认是xxxPO.java，可以自定义</li>\n<li>serialize 是否需要序列化，默认是false，如果该选项为true，则自动实现序列化接口</li>\n</ul>\n<p><em>可以一次配置多个数据库，只要按照格式注意前缀和数据库名，如果连接失败会报错</em></p>\n<p>配置完之后，找到入口Main.java, 按下F11 运行工程即可。如果需要生成数据字段，则将入参配置为true<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016082404.png\" alt=\"\"></p>\n<p>如果没有任何输出就结束了工程就是好结果。</p>\n<p>如果有输出，根据输出排错</p>\n<h2>正确生成的结果</h2>\n\n<p>生成的部分文件<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016082405.png\" alt=\"\"><br>文件内容<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2014082406.png\" alt=\"\"><br>生成的数据字典样式<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2016082407.png\" alt=\"\"></p>\n<h2>关键源码说明：</h2>\n\n<p>Main.java 启动类</p>\n<p>DataBaseEntity.java 业务类，具体的生产逻辑都在这里</p>\n<p>utils包中</p>\n<p>ConfigParser.java 配置文件解析类，校验配置有效性也在这里完成</p>\n<p>ConnectionHelper.java Mysql 链接获取以及操作类</p>\n<h2>致谢</h2>\n\n<p>生成PO文件的逻辑是在同事的基础上修改完成，修改引用了同事(仇老板)的parse(我修改为了parseTable)，自动生成字段，get，set方法，文件输出等逻辑，在此表示感谢~~~</p>\n<h2>获取项目</h2>\n\n<p><a href=\"https://github.com/34benma/PORobot\">GitHub地址</a></p>"},{"title":"并发编程专题开篇","date":"2016-09-08T04:31:16.000Z","_content":"自认为还算是一个技术爱好者(软件相关)。不管是在学校还是在工作岗位上，都一直保持买书，看书的这样一个优良习惯。除了保持内心沉(zhuang)静(bi)，更重要的是我能系统深入学到很多东西。\n\n但是自从患上拖延症和懒癌之后，我学到的很多东西都藏在肚子里，最后烂在肚子里了，也就白学了。因此，我决定，未来4个月好好总结和回顾过去学到的东西，并且以专题的形式总结和分享出来(尽最大努力酿酒，巷子深浅与否看造化了)。\n\n9月和10月(2016)我想总结和分享的专题是Java编程里最具有挑战性的一个----并发编程。\n<!--more-->\n根据我对并发编程的理解，我将深入浅出，由表入里，步步为营将并发编程分成这样12篇文章来讲解。当然，这远远不是并发编程的全部。很多知识点我也只能说一个思路或者大概样貌，不可能面面俱到。下面是我暂时拟出的一个讲解框架:\n\n1. [并发编程概述](http://wantedonline.cn/2016/09/08/20160908-2/)\n<br/>这里主要说一下并发编程的由来，一些基本概念和术语。同时会从宏观(分布式)和微观(多线程)谈一下并发。最后，展望一下未来，说一下协程。\n\n2. [Java并发编程的基本手段](http://wantedonline.cn/2016/10/18/20161018-1/) \n<br/>实现Java多线程的手段以及基本用法(Thread,Runnable,Callable)，static,final等对线程安全的意义\n\n3. [多线程带来的线程安全和线程通信问题](http://wantedonline.cn/2016/10/20/20161020-1/)\n<br/>引出临界区，数据竞争以及线程通信模型,深入讲解线程通信的方法(分析ThreadLocal类)以及意义\n\n4. [深入理解原子性与可见性](http://wantedonline.cn/2016/10/21/20161021-1/)\n<br/>因为多线程通信问题，可能引发原子性和可见性等问题，从Java语言层面讲解原子性和可见性\n\n5. [理解Java内存模型(JMM)](http://wantedonline.cn/2016/10/29/20161029-1)\n<br/>继续深入，理解JMM\n\n6. [J.U.C概述](http://wantedonline.cn/2016/11/12/20161112)\n<br/>JDK并发工具包介绍,从该包的结构以及功能上做一个概述，为后面的分解铺垫思路\n\n7. 深入J.U.C中的锁\n<br/> 深入分析Java语言层面提供的锁机制以及实现原理，对比分析synchronized的异同和优劣\n\n8. 深入J.U.C中Executor框架\n<br/> 深入分析Java中线程池，比较分析4中线程池的异同以及用法\n\n9. 深入J.U.C中并发容器类\n<br/> 简单分析各个容器类的作用和用法，重点分析ConcurrentHashMap\n\n10. 深入J.U.C中原子类\n<br /> 简单分析各种原子类的用法以及作用，重点分析CAS操作的实现以及底层机制\n\n11. 深入J.U.C中并发工具类\n<br/> 简单分析各个工具类的用法以及作用，重点分析CountDownLatch和CyclicBarrier\n\n12. 并发编程总结\n<br /> 总结这个专题的意义以及不足，说一下并发的测试思路\n\n这个思路从简单到复杂，基本是按照并发编程学习的思路来的。当然，各个章节也很独立。可以作为单独的复习或学习参考。希望这个专题能给自己和他人带来知识上的梳理与巩固。\nGood Luck to you and me!\n","source":"_posts/20160908-1.md","raw":"---\ntitle: '并发编程专题开篇'\ndate: 2016-09-08 12:31:16\ntags: \n - 并发编程\n - 深入理解\n - 并发\ncategories: 深入理解\n---\n自认为还算是一个技术爱好者(软件相关)。不管是在学校还是在工作岗位上，都一直保持买书，看书的这样一个优良习惯。除了保持内心沉(zhuang)静(bi)，更重要的是我能系统深入学到很多东西。\n\n但是自从患上拖延症和懒癌之后，我学到的很多东西都藏在肚子里，最后烂在肚子里了，也就白学了。因此，我决定，未来4个月好好总结和回顾过去学到的东西，并且以专题的形式总结和分享出来(尽最大努力酿酒，巷子深浅与否看造化了)。\n\n9月和10月(2016)我想总结和分享的专题是Java编程里最具有挑战性的一个----并发编程。\n<!--more-->\n根据我对并发编程的理解，我将深入浅出，由表入里，步步为营将并发编程分成这样12篇文章来讲解。当然，这远远不是并发编程的全部。很多知识点我也只能说一个思路或者大概样貌，不可能面面俱到。下面是我暂时拟出的一个讲解框架:\n\n1. [并发编程概述](http://wantedonline.cn/2016/09/08/20160908-2/)\n<br/>这里主要说一下并发编程的由来，一些基本概念和术语。同时会从宏观(分布式)和微观(多线程)谈一下并发。最后，展望一下未来，说一下协程。\n\n2. [Java并发编程的基本手段](http://wantedonline.cn/2016/10/18/20161018-1/) \n<br/>实现Java多线程的手段以及基本用法(Thread,Runnable,Callable)，static,final等对线程安全的意义\n\n3. [多线程带来的线程安全和线程通信问题](http://wantedonline.cn/2016/10/20/20161020-1/)\n<br/>引出临界区，数据竞争以及线程通信模型,深入讲解线程通信的方法(分析ThreadLocal类)以及意义\n\n4. [深入理解原子性与可见性](http://wantedonline.cn/2016/10/21/20161021-1/)\n<br/>因为多线程通信问题，可能引发原子性和可见性等问题，从Java语言层面讲解原子性和可见性\n\n5. [理解Java内存模型(JMM)](http://wantedonline.cn/2016/10/29/20161029-1)\n<br/>继续深入，理解JMM\n\n6. [J.U.C概述](http://wantedonline.cn/2016/11/12/20161112)\n<br/>JDK并发工具包介绍,从该包的结构以及功能上做一个概述，为后面的分解铺垫思路\n\n7. 深入J.U.C中的锁\n<br/> 深入分析Java语言层面提供的锁机制以及实现原理，对比分析synchronized的异同和优劣\n\n8. 深入J.U.C中Executor框架\n<br/> 深入分析Java中线程池，比较分析4中线程池的异同以及用法\n\n9. 深入J.U.C中并发容器类\n<br/> 简单分析各个容器类的作用和用法，重点分析ConcurrentHashMap\n\n10. 深入J.U.C中原子类\n<br /> 简单分析各种原子类的用法以及作用，重点分析CAS操作的实现以及底层机制\n\n11. 深入J.U.C中并发工具类\n<br/> 简单分析各个工具类的用法以及作用，重点分析CountDownLatch和CyclicBarrier\n\n12. 并发编程总结\n<br /> 总结这个专题的意义以及不足，说一下并发的测试思路\n\n这个思路从简单到复杂，基本是按照并发编程学习的思路来的。当然，各个章节也很独立。可以作为单独的复习或学习参考。希望这个专题能给自己和他人带来知识上的梳理与巩固。\nGood Luck to you and me!\n","slug":"20160908-1","published":1,"updated":"2016-11-12T09:10:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3c000a1atihbwcn249","content":"<p>自认为还算是一个技术爱好者(软件相关)。不管是在学校还是在工作岗位上，都一直保持买书，看书的这样一个优良习惯。除了保持内心沉(zhuang)静(bi)，更重要的是我能系统深入学到很多东西。</p>\n<p>但是自从患上拖延症和懒癌之后，我学到的很多东西都藏在肚子里，最后烂在肚子里了，也就白学了。因此，我决定，未来4个月好好总结和回顾过去学到的东西，并且以专题的形式总结和分享出来(尽最大努力酿酒，巷子深浅与否看造化了)。</p>\n<p>9月和10月(2016)我想总结和分享的专题是Java编程里最具有挑战性的一个—-并发编程。<br><a id=\"more\"></a><br>根据我对并发编程的理解，我将深入浅出，由表入里，步步为营将并发编程分成这样12篇文章来讲解。当然，这远远不是并发编程的全部。很多知识点我也只能说一个思路或者大概样貌，不可能面面俱到。下面是我暂时拟出的一个讲解框架:</p>\n<ol>\n<li><p><a href=\"http://wantedonline.cn/2016/09/08/20160908-2/\">并发编程概述</a><br><br>这里主要说一下并发编程的由来，一些基本概念和术语。同时会从宏观(分布式)和微观(多线程)谈一下并发。最后，展望一下未来，说一下协程。</p>\n</li>\n<li><p><a href=\"http://wantedonline.cn/2016/10/18/20161018-1/\">Java并发编程的基本手段</a><br><br>实现Java多线程的手段以及基本用法(Thread,Runnable,Callable)，static,final等对线程安全的意义</p>\n</li>\n<li><p><a href=\"http://wantedonline.cn/2016/10/20/20161020-1/\">多线程带来的线程安全和线程通信问题</a><br><br>引出临界区，数据竞争以及线程通信模型,深入讲解线程通信的方法(分析ThreadLocal类)以及意义</p>\n</li>\n<li><p><a href=\"http://wantedonline.cn/2016/10/21/20161021-1/\">深入理解原子性与可见性</a><br><br>因为多线程通信问题，可能引发原子性和可见性等问题，从Java语言层面讲解原子性和可见性</p>\n</li>\n<li><p><a href=\"http://wantedonline.cn/2016/10/29/20161029-1\">理解Java内存模型(JMM)</a><br><br>继续深入，理解JMM</p>\n</li>\n<li><p><a href=\"http://wantedonline.cn/2016/11/12/20161112\">J.U.C概述</a><br><br>JDK并发工具包介绍,从该包的结构以及功能上做一个概述，为后面的分解铺垫思路</p>\n</li>\n<li><p>深入J.U.C中的锁<br><br> 深入分析Java语言层面提供的锁机制以及实现原理，对比分析synchronized的异同和优劣</p>\n</li>\n<li><p>深入J.U.C中Executor框架<br><br> 深入分析Java中线程池，比较分析4中线程池的异同以及用法</p>\n</li>\n<li><p>深入J.U.C中并发容器类<br><br> 简单分析各个容器类的作用和用法，重点分析ConcurrentHashMap</p>\n</li>\n<li><p>深入J.U.C中原子类<br><br> 简单分析各种原子类的用法以及作用，重点分析CAS操作的实现以及底层机制</p>\n</li>\n<li><p>深入J.U.C中并发工具类<br><br> 简单分析各个工具类的用法以及作用，重点分析CountDownLatch和CyclicBarrier</p>\n</li>\n<li><p>并发编程总结<br><br> 总结这个专题的意义以及不足，说一下并发的测试思路</p>\n</li>\n</ol>\n<p>这个思路从简单到复杂，基本是按照并发编程学习的思路来的。当然，各个章节也很独立。可以作为单独的复习或学习参考。希望这个专题能给自己和他人带来知识上的梳理与巩固。<br>Good Luck to you and me!</p>\n","excerpt":"<p>自认为还算是一个技术爱好者(软件相关)。不管是在学校还是在工作岗位上，都一直保持买书，看书的这样一个优良习惯。除了保持内心沉(zhuang)静(bi)，更重要的是我能系统深入学到很多东西。</p>\n<p>但是自从患上拖延症和懒癌之后，我学到的很多东西都藏在肚子里，最后烂在肚子里了，也就白学了。因此，我决定，未来4个月好好总结和回顾过去学到的东西，并且以专题的形式总结和分享出来(尽最大努力酿酒，巷子深浅与否看造化了)。</p>\n<p>9月和10月(2016)我想总结和分享的专题是Java编程里最具有挑战性的一个—-并发编程。<br>","more":"<br>根据我对并发编程的理解，我将深入浅出，由表入里，步步为营将并发编程分成这样12篇文章来讲解。当然，这远远不是并发编程的全部。很多知识点我也只能说一个思路或者大概样貌，不可能面面俱到。下面是我暂时拟出的一个讲解框架:</p>\n<ol>\n<li><p><a href=\"http://wantedonline.cn/2016/09/08/20160908-2/\">并发编程概述</a><br><br/>这里主要说一下并发编程的由来，一些基本概念和术语。同时会从宏观(分布式)和微观(多线程)谈一下并发。最后，展望一下未来，说一下协程。</p>\n</li>\n<li><p><a href=\"http://wantedonline.cn/2016/10/18/20161018-1/\">Java并发编程的基本手段</a><br><br/>实现Java多线程的手段以及基本用法(Thread,Runnable,Callable)，static,final等对线程安全的意义</p>\n</li>\n<li><p><a href=\"http://wantedonline.cn/2016/10/20/20161020-1/\">多线程带来的线程安全和线程通信问题</a><br><br/>引出临界区，数据竞争以及线程通信模型,深入讲解线程通信的方法(分析ThreadLocal类)以及意义</p>\n</li>\n<li><p><a href=\"http://wantedonline.cn/2016/10/21/20161021-1/\">深入理解原子性与可见性</a><br><br/>因为多线程通信问题，可能引发原子性和可见性等问题，从Java语言层面讲解原子性和可见性</p>\n</li>\n<li><p><a href=\"http://wantedonline.cn/2016/10/29/20161029-1\">理解Java内存模型(JMM)</a><br><br/>继续深入，理解JMM</p>\n</li>\n<li><p><a href=\"http://wantedonline.cn/2016/11/12/20161112\">J.U.C概述</a><br><br/>JDK并发工具包介绍,从该包的结构以及功能上做一个概述，为后面的分解铺垫思路</p>\n</li>\n<li><p>深入J.U.C中的锁<br><br/> 深入分析Java语言层面提供的锁机制以及实现原理，对比分析synchronized的异同和优劣</p>\n</li>\n<li><p>深入J.U.C中Executor框架<br><br/> 深入分析Java中线程池，比较分析4中线程池的异同以及用法</p>\n</li>\n<li><p>深入J.U.C中并发容器类<br><br/> 简单分析各个容器类的作用和用法，重点分析ConcurrentHashMap</p>\n</li>\n<li><p>深入J.U.C中原子类<br><br /> 简单分析各种原子类的用法以及作用，重点分析CAS操作的实现以及底层机制</p>\n</li>\n<li><p>深入J.U.C中并发工具类<br><br/> 简单分析各个工具类的用法以及作用，重点分析CountDownLatch和CyclicBarrier</p>\n</li>\n<li><p>并发编程总结<br><br /> 总结这个专题的意义以及不足，说一下并发的测试思路</p>\n</li>\n</ol>\n<p>这个思路从简单到复杂，基本是按照并发编程学习的思路来的。当然，各个章节也很独立。可以作为单独的复习或学习参考。希望这个专题能给自己和他人带来知识上的梳理与巩固。<br>Good Luck to you and me!</p>"},{"title":"并发编程概述","date":"2016-09-08T08:26:31.000Z","_content":"并发编程(Concurrency Programming)，从字面意思来看，自然让人联想到两个或多个的意思。并发编程的出现是计算机硬件，操作系统进步的结果，也是计算机科学追求更快速度，更高效率解决问题的结果。\n\n<!--more-->\n\n<h2>在并发出现之前</h2>\n在并发出现之前，程序的执行自然就都是串行了。那时计算机CPU都是单核的，内存也非常小。需要利用计算机解决的问题也远没有现在这样复杂。因此将程序串行化自然能够解决很多问题。\n\n随着计算机软件和硬件的发展，不仅一台计算机可以有多个CPU，一个CPU还可以有多核。内存变得越来越大，速度也变得越来越快了。为了充分利用这些资源，同时为了提高计算效率和应对更大的计算量，自然而然出现了并发。\n\n<h2>并发的基本概念</h2>\n\n**并发和并行**\n\n和并发这个概念有一字之差的就是并行。虽然只有一字之差，事实上这两个概念有很大的不同。并发是多个线程做同一件事情，并行是多个进程做不同的事情。这些进程可能一点关系也没有。举个例子，求N个数之和，我们可以将这N个数分成M分，用M个线程去分别求和，最后再由一个线程合并求和。这就是并发。一个程序做的事情是求N个数之和，不管这个程序是一个线程完成还是多个线程完成。另一个程序做的事情是求N个数的乘积，也不管这个程序是一个线程完成还是多个线程完成。这两个线程在各自的内存区域共同受一个CPU调度，而且这两个程序还是同时进行。那这就是并行。\n\n由并发牵扯到的一个最重要的概念就是**线程**(Thread)，并发的手段就是多线程。因此并发编程也可以叫做多线程编程。如果没有多线程的编程绝对不能叫做并发编程。\n\n那线程又是什么？**线程**可以理解为小粒度的进程，和进程的区别在于线程之间共享内存，进程之间独立内存。关于线程的形象完整表述我认为这篇[文章](https://segmentfault.com/a/1190000004694556)写的非常好。\n\n总结来说，并发是彼此之间有联系，可以共享数据。并行是彼此之间没有多少联系，做着不同的事情不会共享数据。\n\n**串行和并行**\n\n串行的反义词应该是并行。串行可以理解为一次只做一个事情，充分发挥愚公移山的精神。从微观层面来看，CPU的指令执行必定都是串行的，一个时钟周期内，单个CPU的单个核内不可能同时执行两条指令。并行的话上面说过，是多个进程做不同的事情。从微观上来看，一个多核CPU或者多个CPU在同一个时钟周期内，执行不同的指令可以认为是并行。\n\n**单核和多核**\n\n前面说过，随着计算机硬件的发展，逐渐出现了多核甚至多个CPU(宏观上我们可以把多核和多CPU等同)，这样并发编程就自然而然出现了。事实上，这种说明严格来说，是不符合历史的。我们不能说多核就一定是并发，单核就一定只能是串行。单核也可以并发，多核自然绝对可以串行。在多CPU(或者说多核)出现之前，是有并发的。只不过这时候的并发从指令的微观层面来看，它是串行化的。一个CPU时钟周期内，一定只有一个线程在运行。因此，这个时候，多线程编程的性能和效率不一定比串行编程要高。当然，并行比串行自然效率要高。举个例子，某个程序是CPU密集计算，某个时刻正在CPU计算，另一个程序是IO密集的，同一时刻可以调度它去进行IO计算而不影响CPU密集计算的程序，这样自然就提高了效率。\n\n单核可以并发，也可以并行，多核的场景下进行并发编程比单核效率要高很多。这里有一个阿姆达尔定律来说明这个事情。关于[阿姆达尔定律](http://ifeve.com/amdahls-law/)，我觉得这篇文章说的比较清楚。\n\n<h2>并发编程的影响</h2>\n\n很显然，并发编程带来的最大影响是提高了计算效率，充分利用了计算资源(并行也是为了充分利用计算资源)。但同时并发编程也带来了一个巨大的影响，那就是使得编写并发程序变得困难起来。编写正确的程序就已经比较难了，编写正确的并行程序就是难上加难。\n\n编写并发程序为什么更加困难？原因在于并发程序需要处理线程调度，数据共享问题。因为数据共享带来的线程安全问题。同时，多线程就意味着需要额外的调度逻辑，这多出来的调度会带来线程的上下文切换等损耗。因此多线程不是高性能的良方。恰当地使用多线程，小心翼翼地编写并发程序才是对策。有时候，我们甚至不能忽略线程切换带来的性能下降，更加不能容忍多线程带来的线程安全导致错误的计算结果问题。\n\n<h2>还可以提高计算效率吗</h2>\n\n很显然，多线程不是高性能的最好办法。可以这样说，多线程的目的在于充分利用计算机硬件资源和软件资源，使其不断处于忙碌状态从而提高生产效率。而高性能的解决办法有时候需要从更加宏观的地方入手。\n\n**分布式架构**\n\n目前，互联网里分布式架构应该比较流行。因为解决高并发，大流量问题很多时候就是分布式。现在比较流行的**微服务**也可以理解为更小粒度的SOA。计算机科学里还是现实生活中，我们解决大问题的思路就是拆分。将大问题拆分成小问题，将大模块拆分成小模块。然后利用多实例，多服务来解决。因此，从宏观层面来看，分布式和并发的思想上有某种契合。都是化大为小，各个击破。\n\n**协程**\n\n多线程必然带来线程切换的问题。线程切换就会消耗额外的计算资源。因此计算机科学里又有了一种**协程**的说法。可以这样认为，线程是小粒度的进程，而协程可以理解为小粒度的线程。协程不需要上下文切换，在方法调用里调用其他的方法不需要切换资源。这里的关键在于利用了CPU的中断。因此避免了线程切换带来的资源消耗。未来，Java必将支持协程。而目前Python已经支持协程了。关于协程的说明，可以参考这篇[文章](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000)\n\n协程出现后，将来的并发编程并发编程将变得更加简单还是更加复杂了呢？可以肯定的是，协程出现后，并发编程带来的效率提升又会上一个台阶。\n\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n\n","source":"_posts/20160908-2.md","raw":"---\ntitle: '并发编程概述'\ndate: 2016-09-08 16:26:31\ntags: \n - 并发编程\n - 并发\n - 并发专题\ncategories: 深入理解\n---\n并发编程(Concurrency Programming)，从字面意思来看，自然让人联想到两个或多个的意思。并发编程的出现是计算机硬件，操作系统进步的结果，也是计算机科学追求更快速度，更高效率解决问题的结果。\n\n<!--more-->\n\n<h2>在并发出现之前</h2>\n在并发出现之前，程序的执行自然就都是串行了。那时计算机CPU都是单核的，内存也非常小。需要利用计算机解决的问题也远没有现在这样复杂。因此将程序串行化自然能够解决很多问题。\n\n随着计算机软件和硬件的发展，不仅一台计算机可以有多个CPU，一个CPU还可以有多核。内存变得越来越大，速度也变得越来越快了。为了充分利用这些资源，同时为了提高计算效率和应对更大的计算量，自然而然出现了并发。\n\n<h2>并发的基本概念</h2>\n\n**并发和并行**\n\n和并发这个概念有一字之差的就是并行。虽然只有一字之差，事实上这两个概念有很大的不同。并发是多个线程做同一件事情，并行是多个进程做不同的事情。这些进程可能一点关系也没有。举个例子，求N个数之和，我们可以将这N个数分成M分，用M个线程去分别求和，最后再由一个线程合并求和。这就是并发。一个程序做的事情是求N个数之和，不管这个程序是一个线程完成还是多个线程完成。另一个程序做的事情是求N个数的乘积，也不管这个程序是一个线程完成还是多个线程完成。这两个线程在各自的内存区域共同受一个CPU调度，而且这两个程序还是同时进行。那这就是并行。\n\n由并发牵扯到的一个最重要的概念就是**线程**(Thread)，并发的手段就是多线程。因此并发编程也可以叫做多线程编程。如果没有多线程的编程绝对不能叫做并发编程。\n\n那线程又是什么？**线程**可以理解为小粒度的进程，和进程的区别在于线程之间共享内存，进程之间独立内存。关于线程的形象完整表述我认为这篇[文章](https://segmentfault.com/a/1190000004694556)写的非常好。\n\n总结来说，并发是彼此之间有联系，可以共享数据。并行是彼此之间没有多少联系，做着不同的事情不会共享数据。\n\n**串行和并行**\n\n串行的反义词应该是并行。串行可以理解为一次只做一个事情，充分发挥愚公移山的精神。从微观层面来看，CPU的指令执行必定都是串行的，一个时钟周期内，单个CPU的单个核内不可能同时执行两条指令。并行的话上面说过，是多个进程做不同的事情。从微观上来看，一个多核CPU或者多个CPU在同一个时钟周期内，执行不同的指令可以认为是并行。\n\n**单核和多核**\n\n前面说过，随着计算机硬件的发展，逐渐出现了多核甚至多个CPU(宏观上我们可以把多核和多CPU等同)，这样并发编程就自然而然出现了。事实上，这种说明严格来说，是不符合历史的。我们不能说多核就一定是并发，单核就一定只能是串行。单核也可以并发，多核自然绝对可以串行。在多CPU(或者说多核)出现之前，是有并发的。只不过这时候的并发从指令的微观层面来看，它是串行化的。一个CPU时钟周期内，一定只有一个线程在运行。因此，这个时候，多线程编程的性能和效率不一定比串行编程要高。当然，并行比串行自然效率要高。举个例子，某个程序是CPU密集计算，某个时刻正在CPU计算，另一个程序是IO密集的，同一时刻可以调度它去进行IO计算而不影响CPU密集计算的程序，这样自然就提高了效率。\n\n单核可以并发，也可以并行，多核的场景下进行并发编程比单核效率要高很多。这里有一个阿姆达尔定律来说明这个事情。关于[阿姆达尔定律](http://ifeve.com/amdahls-law/)，我觉得这篇文章说的比较清楚。\n\n<h2>并发编程的影响</h2>\n\n很显然，并发编程带来的最大影响是提高了计算效率，充分利用了计算资源(并行也是为了充分利用计算资源)。但同时并发编程也带来了一个巨大的影响，那就是使得编写并发程序变得困难起来。编写正确的程序就已经比较难了，编写正确的并行程序就是难上加难。\n\n编写并发程序为什么更加困难？原因在于并发程序需要处理线程调度，数据共享问题。因为数据共享带来的线程安全问题。同时，多线程就意味着需要额外的调度逻辑，这多出来的调度会带来线程的上下文切换等损耗。因此多线程不是高性能的良方。恰当地使用多线程，小心翼翼地编写并发程序才是对策。有时候，我们甚至不能忽略线程切换带来的性能下降，更加不能容忍多线程带来的线程安全导致错误的计算结果问题。\n\n<h2>还可以提高计算效率吗</h2>\n\n很显然，多线程不是高性能的最好办法。可以这样说，多线程的目的在于充分利用计算机硬件资源和软件资源，使其不断处于忙碌状态从而提高生产效率。而高性能的解决办法有时候需要从更加宏观的地方入手。\n\n**分布式架构**\n\n目前，互联网里分布式架构应该比较流行。因为解决高并发，大流量问题很多时候就是分布式。现在比较流行的**微服务**也可以理解为更小粒度的SOA。计算机科学里还是现实生活中，我们解决大问题的思路就是拆分。将大问题拆分成小问题，将大模块拆分成小模块。然后利用多实例，多服务来解决。因此，从宏观层面来看，分布式和并发的思想上有某种契合。都是化大为小，各个击破。\n\n**协程**\n\n多线程必然带来线程切换的问题。线程切换就会消耗额外的计算资源。因此计算机科学里又有了一种**协程**的说法。可以这样认为，线程是小粒度的进程，而协程可以理解为小粒度的线程。协程不需要上下文切换，在方法调用里调用其他的方法不需要切换资源。这里的关键在于利用了CPU的中断。因此避免了线程切换带来的资源消耗。未来，Java必将支持协程。而目前Python已经支持协程了。关于协程的说明，可以参考这篇[文章](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000)\n\n协程出现后，将来的并发编程并发编程将变得更加简单还是更加复杂了呢？可以肯定的是，协程出现后，并发编程带来的效率提升又会上一个台阶。\n\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n\n","slug":"20160908-2","published":1,"updated":"2016-09-20T11:58:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3d000c1atiwc2w4hu4","content":"<p>并发编程(Concurrency Programming)，从字面意思来看，自然让人联想到两个或多个的意思。并发编程的出现是计算机硬件，操作系统进步的结果，也是计算机科学追求更快速度，更高效率解决问题的结果。</p>\n<a id=\"more\"></a>\n<h2>在并发出现之前</h2><br>在并发出现之前，程序的执行自然就都是串行了。那时计算机CPU都是单核的，内存也非常小。需要利用计算机解决的问题也远没有现在这样复杂。因此将程序串行化自然能够解决很多问题。<br><br>随着计算机软件和硬件的发展，不仅一台计算机可以有多个CPU，一个CPU还可以有多核。内存变得越来越大，速度也变得越来越快了。为了充分利用这些资源，同时为了提高计算效率和应对更大的计算量，自然而然出现了并发。<br><br><h2>并发的基本概念</h2>\n\n<p><strong>并发和并行</strong></p>\n<p>和并发这个概念有一字之差的就是并行。虽然只有一字之差，事实上这两个概念有很大的不同。并发是多个线程做同一件事情，并行是多个进程做不同的事情。这些进程可能一点关系也没有。举个例子，求N个数之和，我们可以将这N个数分成M分，用M个线程去分别求和，最后再由一个线程合并求和。这就是并发。一个程序做的事情是求N个数之和，不管这个程序是一个线程完成还是多个线程完成。另一个程序做的事情是求N个数的乘积，也不管这个程序是一个线程完成还是多个线程完成。这两个线程在各自的内存区域共同受一个CPU调度，而且这两个程序还是同时进行。那这就是并行。</p>\n<p>由并发牵扯到的一个最重要的概念就是<strong>线程</strong>(Thread)，并发的手段就是多线程。因此并发编程也可以叫做多线程编程。如果没有多线程的编程绝对不能叫做并发编程。</p>\n<p>那线程又是什么？<strong>线程</strong>可以理解为小粒度的进程，和进程的区别在于线程之间共享内存，进程之间独立内存。关于线程的形象完整表述我认为这篇<a href=\"https://segmentfault.com/a/1190000004694556\" target=\"_blank\" rel=\"external\">文章</a>写的非常好。</p>\n<p>总结来说，并发是彼此之间有联系，可以共享数据。并行是彼此之间没有多少联系，做着不同的事情不会共享数据。</p>\n<p><strong>串行和并行</strong></p>\n<p>串行的反义词应该是并行。串行可以理解为一次只做一个事情，充分发挥愚公移山的精神。从微观层面来看，CPU的指令执行必定都是串行的，一个时钟周期内，单个CPU的单个核内不可能同时执行两条指令。并行的话上面说过，是多个进程做不同的事情。从微观上来看，一个多核CPU或者多个CPU在同一个时钟周期内，执行不同的指令可以认为是并行。</p>\n<p><strong>单核和多核</strong></p>\n<p>前面说过，随着计算机硬件的发展，逐渐出现了多核甚至多个CPU(宏观上我们可以把多核和多CPU等同)，这样并发编程就自然而然出现了。事实上，这种说明严格来说，是不符合历史的。我们不能说多核就一定是并发，单核就一定只能是串行。单核也可以并发，多核自然绝对可以串行。在多CPU(或者说多核)出现之前，是有并发的。只不过这时候的并发从指令的微观层面来看，它是串行化的。一个CPU时钟周期内，一定只有一个线程在运行。因此，这个时候，多线程编程的性能和效率不一定比串行编程要高。当然，并行比串行自然效率要高。举个例子，某个程序是CPU密集计算，某个时刻正在CPU计算，另一个程序是IO密集的，同一时刻可以调度它去进行IO计算而不影响CPU密集计算的程序，这样自然就提高了效率。</p>\n<p>单核可以并发，也可以并行，多核的场景下进行并发编程比单核效率要高很多。这里有一个阿姆达尔定律来说明这个事情。关于<a href=\"http://ifeve.com/amdahls-law/\" target=\"_blank\" rel=\"external\">阿姆达尔定律</a>，我觉得这篇文章说的比较清楚。</p>\n<h2>并发编程的影响</h2>\n\n<p>很显然，并发编程带来的最大影响是提高了计算效率，充分利用了计算资源(并行也是为了充分利用计算资源)。但同时并发编程也带来了一个巨大的影响，那就是使得编写并发程序变得困难起来。编写正确的程序就已经比较难了，编写正确的并行程序就是难上加难。</p>\n<p>编写并发程序为什么更加困难？原因在于并发程序需要处理线程调度，数据共享问题。因为数据共享带来的线程安全问题。同时，多线程就意味着需要额外的调度逻辑，这多出来的调度会带来线程的上下文切换等损耗。因此多线程不是高性能的良方。恰当地使用多线程，小心翼翼地编写并发程序才是对策。有时候，我们甚至不能忽略线程切换带来的性能下降，更加不能容忍多线程带来的线程安全导致错误的计算结果问题。</p>\n<h2>还可以提高计算效率吗</h2>\n\n<p>很显然，多线程不是高性能的最好办法。可以这样说，多线程的目的在于充分利用计算机硬件资源和软件资源，使其不断处于忙碌状态从而提高生产效率。而高性能的解决办法有时候需要从更加宏观的地方入手。</p>\n<p><strong>分布式架构</strong></p>\n<p>目前，互联网里分布式架构应该比较流行。因为解决高并发，大流量问题很多时候就是分布式。现在比较流行的<strong>微服务</strong>也可以理解为更小粒度的SOA。计算机科学里还是现实生活中，我们解决大问题的思路就是拆分。将大问题拆分成小问题，将大模块拆分成小模块。然后利用多实例，多服务来解决。因此，从宏观层面来看，分布式和并发的思想上有某种契合。都是化大为小，各个击破。</p>\n<p><strong>协程</strong></p>\n<p>多线程必然带来线程切换的问题。线程切换就会消耗额外的计算资源。因此计算机科学里又有了一种<strong>协程</strong>的说法。可以这样认为，线程是小粒度的进程，而协程可以理解为小粒度的线程。协程不需要上下文切换，在方法调用里调用其他的方法不需要切换资源。这里的关键在于利用了CPU的中断。因此避免了线程切换带来的资源消耗。未来，Java必将支持协程。而目前Python已经支持协程了。关于协程的说明，可以参考这篇<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000\" target=\"_blank\" rel=\"external\">文章</a></p>\n<p>协程出现后，将来的并发编程并发编程将变得更加简单还是更加复杂了呢？可以肯定的是，协程出现后，并发编程带来的效率提升又会上一个台阶。</p>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>\n","excerpt":"<p>并发编程(Concurrency Programming)，从字面意思来看，自然让人联想到两个或多个的意思。并发编程的出现是计算机硬件，操作系统进步的结果，也是计算机科学追求更快速度，更高效率解决问题的结果。</p>","more":"<h2>在并发出现之前</h2><br>在并发出现之前，程序的执行自然就都是串行了。那时计算机CPU都是单核的，内存也非常小。需要利用计算机解决的问题也远没有现在这样复杂。因此将程序串行化自然能够解决很多问题。<br><br>随着计算机软件和硬件的发展，不仅一台计算机可以有多个CPU，一个CPU还可以有多核。内存变得越来越大，速度也变得越来越快了。为了充分利用这些资源，同时为了提高计算效率和应对更大的计算量，自然而然出现了并发。<br><br><h2>并发的基本概念</h2>\n\n<p><strong>并发和并行</strong></p>\n<p>和并发这个概念有一字之差的就是并行。虽然只有一字之差，事实上这两个概念有很大的不同。并发是多个线程做同一件事情，并行是多个进程做不同的事情。这些进程可能一点关系也没有。举个例子，求N个数之和，我们可以将这N个数分成M分，用M个线程去分别求和，最后再由一个线程合并求和。这就是并发。一个程序做的事情是求N个数之和，不管这个程序是一个线程完成还是多个线程完成。另一个程序做的事情是求N个数的乘积，也不管这个程序是一个线程完成还是多个线程完成。这两个线程在各自的内存区域共同受一个CPU调度，而且这两个程序还是同时进行。那这就是并行。</p>\n<p>由并发牵扯到的一个最重要的概念就是<strong>线程</strong>(Thread)，并发的手段就是多线程。因此并发编程也可以叫做多线程编程。如果没有多线程的编程绝对不能叫做并发编程。</p>\n<p>那线程又是什么？<strong>线程</strong>可以理解为小粒度的进程，和进程的区别在于线程之间共享内存，进程之间独立内存。关于线程的形象完整表述我认为这篇<a href=\"https://segmentfault.com/a/1190000004694556\">文章</a>写的非常好。</p>\n<p>总结来说，并发是彼此之间有联系，可以共享数据。并行是彼此之间没有多少联系，做着不同的事情不会共享数据。</p>\n<p><strong>串行和并行</strong></p>\n<p>串行的反义词应该是并行。串行可以理解为一次只做一个事情，充分发挥愚公移山的精神。从微观层面来看，CPU的指令执行必定都是串行的，一个时钟周期内，单个CPU的单个核内不可能同时执行两条指令。并行的话上面说过，是多个进程做不同的事情。从微观上来看，一个多核CPU或者多个CPU在同一个时钟周期内，执行不同的指令可以认为是并行。</p>\n<p><strong>单核和多核</strong></p>\n<p>前面说过，随着计算机硬件的发展，逐渐出现了多核甚至多个CPU(宏观上我们可以把多核和多CPU等同)，这样并发编程就自然而然出现了。事实上，这种说明严格来说，是不符合历史的。我们不能说多核就一定是并发，单核就一定只能是串行。单核也可以并发，多核自然绝对可以串行。在多CPU(或者说多核)出现之前，是有并发的。只不过这时候的并发从指令的微观层面来看，它是串行化的。一个CPU时钟周期内，一定只有一个线程在运行。因此，这个时候，多线程编程的性能和效率不一定比串行编程要高。当然，并行比串行自然效率要高。举个例子，某个程序是CPU密集计算，某个时刻正在CPU计算，另一个程序是IO密集的，同一时刻可以调度它去进行IO计算而不影响CPU密集计算的程序，这样自然就提高了效率。</p>\n<p>单核可以并发，也可以并行，多核的场景下进行并发编程比单核效率要高很多。这里有一个阿姆达尔定律来说明这个事情。关于<a href=\"http://ifeve.com/amdahls-law/\">阿姆达尔定律</a>，我觉得这篇文章说的比较清楚。</p>\n<h2>并发编程的影响</h2>\n\n<p>很显然，并发编程带来的最大影响是提高了计算效率，充分利用了计算资源(并行也是为了充分利用计算资源)。但同时并发编程也带来了一个巨大的影响，那就是使得编写并发程序变得困难起来。编写正确的程序就已经比较难了，编写正确的并行程序就是难上加难。</p>\n<p>编写并发程序为什么更加困难？原因在于并发程序需要处理线程调度，数据共享问题。因为数据共享带来的线程安全问题。同时，多线程就意味着需要额外的调度逻辑，这多出来的调度会带来线程的上下文切换等损耗。因此多线程不是高性能的良方。恰当地使用多线程，小心翼翼地编写并发程序才是对策。有时候，我们甚至不能忽略线程切换带来的性能下降，更加不能容忍多线程带来的线程安全导致错误的计算结果问题。</p>\n<h2>还可以提高计算效率吗</h2>\n\n<p>很显然，多线程不是高性能的最好办法。可以这样说，多线程的目的在于充分利用计算机硬件资源和软件资源，使其不断处于忙碌状态从而提高生产效率。而高性能的解决办法有时候需要从更加宏观的地方入手。</p>\n<p><strong>分布式架构</strong></p>\n<p>目前，互联网里分布式架构应该比较流行。因为解决高并发，大流量问题很多时候就是分布式。现在比较流行的<strong>微服务</strong>也可以理解为更小粒度的SOA。计算机科学里还是现实生活中，我们解决大问题的思路就是拆分。将大问题拆分成小问题，将大模块拆分成小模块。然后利用多实例，多服务来解决。因此，从宏观层面来看，分布式和并发的思想上有某种契合。都是化大为小，各个击破。</p>\n<p><strong>协程</strong></p>\n<p>多线程必然带来线程切换的问题。线程切换就会消耗额外的计算资源。因此计算机科学里又有了一种<strong>协程</strong>的说法。可以这样认为，线程是小粒度的进程，而协程可以理解为小粒度的线程。协程不需要上下文切换，在方法调用里调用其他的方法不需要切换资源。这里的关键在于利用了CPU的中断。因此避免了线程切换带来的资源消耗。未来，Java必将支持协程。而目前Python已经支持协程了。关于协程的说明，可以参考这篇<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000\">文章</a></p>\n<p>协程出现后，将来的并发编程并发编程将变得更加简单还是更加复杂了呢？可以肯定的是，协程出现后，并发编程带来的效率提升又会上一个台阶。</p>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>"},{"title":"博客更新说明(2016.09)","date":"2016-09-20T11:59:41.000Z","_content":"\n计划永远赶不上变化，原计划9月份更新5-6篇并发方面的文章，谁知工作生活发生了一些变化，让我有些猝不及防。 :(\n\n原计划9，10月完成的并发专题可能不能按时完成了。 :(\n\n我又拖欠作业了....\n<!--more-->\n","source":"_posts/20160920-1.md","raw":"---\ntitle: '博客更新说明(2016.09)'\ndate: 2016-09-20 19:59:41\ntags: \n - 随笔\n - 博客更新\ncategories: 随笔\n---\n\n计划永远赶不上变化，原计划9月份更新5-6篇并发方面的文章，谁知工作生活发生了一些变化，让我有些猝不及防。 :(\n\n原计划9，10月完成的并发专题可能不能按时完成了。 :(\n\n我又拖欠作业了....\n<!--more-->\n","slug":"20160920-1","published":1,"updated":"2016-10-07T06:44:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3f000e1ati43rvxy57","content":"<p>计划永远赶不上变化，原计划9月份更新5-6篇并发方面的文章，谁知工作生活发生了一些变化，让我有些猝不及防。 :(</p>\n<p>原计划9，10月完成的并发专题可能不能按时完成了。 :(</p>\n<p>我又拖欠作业了….<br><a id=\"more\"></a></p>\n","excerpt":"<p>计划永远赶不上变化，原计划9月份更新5-6篇并发方面的文章，谁知工作生活发生了一些变化，让我有些猝不及防。 :(</p>\n<p>原计划9，10月完成的并发专题可能不能按时完成了。 :(</p>\n<p>我又拖欠作业了….<br>","more":"</p>"},{"title":"深入理解原子性与可见性","date":"2016-10-21T11:24:36.000Z","_content":"在并发编程的世界里，有两个非常重要的关键字，分别是synchronized和volatile. 一句话概括这两个关键字的作用的话就是synchronized保证了原子性，volatile保证了可见性。本文将深入分析原子性和可见性。\n\n<!--more-->\n\n<h2>原子性</h2>\n\n所谓原子性就是指操作不可分解，不会出现一半成功，一半失败的情况。我们都知道事务具有ACID属性，其中的A就是原子性。事务中的原子性也是说一个完整的事务中定义的全部操作步骤要么全部成功，要么全部不成功，不可分解。和我们这里的原子性定义是一样的。在并发编程中，我们在临界区的某些操作，必须具有原子性。因为我们无法控制线程的切换，所以就有可能发生线程执行到某个中间位置，因为时间片或者等待资源的情况发了上下文切换，切入到另外一个线程，这时候就破坏了数据的一致性。因此，我们必须保证临界区中这些操作的原子性。\n\n<h3>保证原子性的手段</h3>\n\n保证原子性的手段之一就是加锁。所谓锁，我们可以这么理解，当我们某个线程获取了锁，就代表他获得了一个特殊通行证，并且这个通行证一定是唯一的。在它归还这个通行证之前，其他线程是没办法进入到锁区域的。自然其他线程也就无法看到锁区域中数据的状态，也不能修改其状态。因此，只要我们的线程没有释放锁，其他线程是无法进入到锁区域的。直到我们成功释放了锁，我们的操作都是原子性的，不会被其他线程所干扰。\n\n加锁的第一种方式是synchronized，这是Java提供的一个关键字，这个关键字的含义就是内置锁或者监视器锁。当我们的线程进入到了synchronized区域时，自动会获取锁，当退出这个区域是自动释放锁。如果我们使用javap打印一下一个synchronized修饰的代码块，我们会发现，有个叫**enter monitor**和**exit monitor**的两条指令，它们所包围的指令就是使用synchronized修饰的区域。\n\n在J.U.C里，提供了更加灵活的加锁机制，就是Lock类，这是从Java代码层面提供的锁机制。这套机制比synchronized更加灵活，而且从JDK 1.6之后，这套锁机制的性能比synchronized更好了。这里面将锁划分的更细，可以有互斥锁(写锁)和共享锁(读锁)。获取锁和释放锁的操作都是可控的了，因此更加灵活，但是带来的使用复杂性也更加高了，如果我们获取了锁忘记释放锁或者释放锁失败将有可能会造成死锁等。\n\n当我们看过J.U.C实现锁的方式(基于AQS)，我们自己也可以实现锁。如果使用Semaphore类的话，自己实现锁就更加简单了。\n\n当然，保证原子性的手段并不是只有加锁这一种。事实上，锁机制对指令执行性能是有影响的。因此，如果不是有必要，我们不要随便加锁，而且加锁的区域尽量保证最小化，不要将没有必要加锁的代码放到锁区域中来。\n\n原子性的另外一种方式是无锁化。这个看起来比较矛盾，其实是不矛盾的。无锁化是通过CAS(Compare and set)来实现的。J.U.C中提供了一些原子类，它保证原子性的方式就是CAS。后续我们分析J.U.C的原子类时将详细讲解CAS操作。\n\n两种实现原子性的方式并不是可以互相替代的，而是他们在特定的场景具有特定的使用方式。加锁一般是代码块。而无锁化则是一些需要原子化的变量，通过CAS比使用加锁在变量层面性能更高。\n\n<h2>可见性</h2>\n\n所谓可见性是指我们希望对于某些状态我们进行了修改，希望其他线程能够感知到。这里就有线程通信的意思在里面了。考虑这样一种场景，变量x是两个线程A,B都可以看到的，线程A，B都保存了一份副本在彼此的栈帧里，当线程A修改了x时，如果没有一种机制去通信告知线程B，线程B仍然使用的是旧的x值。因此可见性就是要保证线程B能及时感知到x的状态变化。同样在CPU层面，也有这种场景，比如多核多寄存器。同样有变量的缓存以及修改需要通知其他CPU或寄存器变量的修改。当然这个层面不是JVM来保证了。\n\n<h3>保证可见性的手段</h3>\n\n保证可见性的第一种方法是直接使用锁，从效果上是可以的。但是前文说过，锁的方式对性能影响比较大。因此Java提供了另外一个关键字叫做volatile。这个关键字就是用来保证可见性的，它还有一个别称叫“轻量级锁”。\n\nvolatile为什么可以保证可见性呢? 这里可以从JMM找到原理。在下一篇讲解JMM时我们将详细分析synchronized和volatile两个关键字的原理。\n\n<h2>总结</h2>\n\n原子性和可见性是并发编程里两个非常重要的基础概念，只有深入理解了这两个概念，我们才能用好锁，用好可见性。才能编写出性能优越，线程安全的代码来。\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n","source":"_posts/20161021-1.md","raw":"---\ntitle: '深入理解原子性与可见性'\ndate: 2016-10-21 19:24:36\ntags:\n - 并发编程\n - 原子性\n - 可见性\ncategories: 深入理解\n---\n在并发编程的世界里，有两个非常重要的关键字，分别是synchronized和volatile. 一句话概括这两个关键字的作用的话就是synchronized保证了原子性，volatile保证了可见性。本文将深入分析原子性和可见性。\n\n<!--more-->\n\n<h2>原子性</h2>\n\n所谓原子性就是指操作不可分解，不会出现一半成功，一半失败的情况。我们都知道事务具有ACID属性，其中的A就是原子性。事务中的原子性也是说一个完整的事务中定义的全部操作步骤要么全部成功，要么全部不成功，不可分解。和我们这里的原子性定义是一样的。在并发编程中，我们在临界区的某些操作，必须具有原子性。因为我们无法控制线程的切换，所以就有可能发生线程执行到某个中间位置，因为时间片或者等待资源的情况发了上下文切换，切入到另外一个线程，这时候就破坏了数据的一致性。因此，我们必须保证临界区中这些操作的原子性。\n\n<h3>保证原子性的手段</h3>\n\n保证原子性的手段之一就是加锁。所谓锁，我们可以这么理解，当我们某个线程获取了锁，就代表他获得了一个特殊通行证，并且这个通行证一定是唯一的。在它归还这个通行证之前，其他线程是没办法进入到锁区域的。自然其他线程也就无法看到锁区域中数据的状态，也不能修改其状态。因此，只要我们的线程没有释放锁，其他线程是无法进入到锁区域的。直到我们成功释放了锁，我们的操作都是原子性的，不会被其他线程所干扰。\n\n加锁的第一种方式是synchronized，这是Java提供的一个关键字，这个关键字的含义就是内置锁或者监视器锁。当我们的线程进入到了synchronized区域时，自动会获取锁，当退出这个区域是自动释放锁。如果我们使用javap打印一下一个synchronized修饰的代码块，我们会发现，有个叫**enter monitor**和**exit monitor**的两条指令，它们所包围的指令就是使用synchronized修饰的区域。\n\n在J.U.C里，提供了更加灵活的加锁机制，就是Lock类，这是从Java代码层面提供的锁机制。这套机制比synchronized更加灵活，而且从JDK 1.6之后，这套锁机制的性能比synchronized更好了。这里面将锁划分的更细，可以有互斥锁(写锁)和共享锁(读锁)。获取锁和释放锁的操作都是可控的了，因此更加灵活，但是带来的使用复杂性也更加高了，如果我们获取了锁忘记释放锁或者释放锁失败将有可能会造成死锁等。\n\n当我们看过J.U.C实现锁的方式(基于AQS)，我们自己也可以实现锁。如果使用Semaphore类的话，自己实现锁就更加简单了。\n\n当然，保证原子性的手段并不是只有加锁这一种。事实上，锁机制对指令执行性能是有影响的。因此，如果不是有必要，我们不要随便加锁，而且加锁的区域尽量保证最小化，不要将没有必要加锁的代码放到锁区域中来。\n\n原子性的另外一种方式是无锁化。这个看起来比较矛盾，其实是不矛盾的。无锁化是通过CAS(Compare and set)来实现的。J.U.C中提供了一些原子类，它保证原子性的方式就是CAS。后续我们分析J.U.C的原子类时将详细讲解CAS操作。\n\n两种实现原子性的方式并不是可以互相替代的，而是他们在特定的场景具有特定的使用方式。加锁一般是代码块。而无锁化则是一些需要原子化的变量，通过CAS比使用加锁在变量层面性能更高。\n\n<h2>可见性</h2>\n\n所谓可见性是指我们希望对于某些状态我们进行了修改，希望其他线程能够感知到。这里就有线程通信的意思在里面了。考虑这样一种场景，变量x是两个线程A,B都可以看到的，线程A，B都保存了一份副本在彼此的栈帧里，当线程A修改了x时，如果没有一种机制去通信告知线程B，线程B仍然使用的是旧的x值。因此可见性就是要保证线程B能及时感知到x的状态变化。同样在CPU层面，也有这种场景，比如多核多寄存器。同样有变量的缓存以及修改需要通知其他CPU或寄存器变量的修改。当然这个层面不是JVM来保证了。\n\n<h3>保证可见性的手段</h3>\n\n保证可见性的第一种方法是直接使用锁，从效果上是可以的。但是前文说过，锁的方式对性能影响比较大。因此Java提供了另外一个关键字叫做volatile。这个关键字就是用来保证可见性的，它还有一个别称叫“轻量级锁”。\n\nvolatile为什么可以保证可见性呢? 这里可以从JMM找到原理。在下一篇讲解JMM时我们将详细分析synchronized和volatile两个关键字的原理。\n\n<h2>总结</h2>\n\n原子性和可见性是并发编程里两个非常重要的基础概念，只有深入理解了这两个概念，我们才能用好锁，用好可见性。才能编写出性能优越，线程安全的代码来。\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n","slug":"20161021-1","published":1,"updated":"2016-10-21T13:56:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3i000i1ati4h4sbo9y","content":"<p>在并发编程的世界里，有两个非常重要的关键字，分别是synchronized和volatile. 一句话概括这两个关键字的作用的话就是synchronized保证了原子性，volatile保证了可见性。本文将深入分析原子性和可见性。</p>\n<a id=\"more\"></a>\n<h2>原子性</h2>\n\n<p>所谓原子性就是指操作不可分解，不会出现一半成功，一半失败的情况。我们都知道事务具有ACID属性，其中的A就是原子性。事务中的原子性也是说一个完整的事务中定义的全部操作步骤要么全部成功，要么全部不成功，不可分解。和我们这里的原子性定义是一样的。在并发编程中，我们在临界区的某些操作，必须具有原子性。因为我们无法控制线程的切换，所以就有可能发生线程执行到某个中间位置，因为时间片或者等待资源的情况发了上下文切换，切入到另外一个线程，这时候就破坏了数据的一致性。因此，我们必须保证临界区中这些操作的原子性。</p>\n<h3>保证原子性的手段</h3>\n\n<p>保证原子性的手段之一就是加锁。所谓锁，我们可以这么理解，当我们某个线程获取了锁，就代表他获得了一个特殊通行证，并且这个通行证一定是唯一的。在它归还这个通行证之前，其他线程是没办法进入到锁区域的。自然其他线程也就无法看到锁区域中数据的状态，也不能修改其状态。因此，只要我们的线程没有释放锁，其他线程是无法进入到锁区域的。直到我们成功释放了锁，我们的操作都是原子性的，不会被其他线程所干扰。</p>\n<p>加锁的第一种方式是synchronized，这是Java提供的一个关键字，这个关键字的含义就是内置锁或者监视器锁。当我们的线程进入到了synchronized区域时，自动会获取锁，当退出这个区域是自动释放锁。如果我们使用javap打印一下一个synchronized修饰的代码块，我们会发现，有个叫<strong>enter monitor</strong>和<strong>exit monitor</strong>的两条指令，它们所包围的指令就是使用synchronized修饰的区域。</p>\n<p>在J.U.C里，提供了更加灵活的加锁机制，就是Lock类，这是从Java代码层面提供的锁机制。这套机制比synchronized更加灵活，而且从JDK 1.6之后，这套锁机制的性能比synchronized更好了。这里面将锁划分的更细，可以有互斥锁(写锁)和共享锁(读锁)。获取锁和释放锁的操作都是可控的了，因此更加灵活，但是带来的使用复杂性也更加高了，如果我们获取了锁忘记释放锁或者释放锁失败将有可能会造成死锁等。</p>\n<p>当我们看过J.U.C实现锁的方式(基于AQS)，我们自己也可以实现锁。如果使用Semaphore类的话，自己实现锁就更加简单了。</p>\n<p>当然，保证原子性的手段并不是只有加锁这一种。事实上，锁机制对指令执行性能是有影响的。因此，如果不是有必要，我们不要随便加锁，而且加锁的区域尽量保证最小化，不要将没有必要加锁的代码放到锁区域中来。</p>\n<p>原子性的另外一种方式是无锁化。这个看起来比较矛盾，其实是不矛盾的。无锁化是通过CAS(Compare and set)来实现的。J.U.C中提供了一些原子类，它保证原子性的方式就是CAS。后续我们分析J.U.C的原子类时将详细讲解CAS操作。</p>\n<p>两种实现原子性的方式并不是可以互相替代的，而是他们在特定的场景具有特定的使用方式。加锁一般是代码块。而无锁化则是一些需要原子化的变量，通过CAS比使用加锁在变量层面性能更高。</p>\n<h2>可见性</h2>\n\n<p>所谓可见性是指我们希望对于某些状态我们进行了修改，希望其他线程能够感知到。这里就有线程通信的意思在里面了。考虑这样一种场景，变量x是两个线程A,B都可以看到的，线程A，B都保存了一份副本在彼此的栈帧里，当线程A修改了x时，如果没有一种机制去通信告知线程B，线程B仍然使用的是旧的x值。因此可见性就是要保证线程B能及时感知到x的状态变化。同样在CPU层面，也有这种场景，比如多核多寄存器。同样有变量的缓存以及修改需要通知其他CPU或寄存器变量的修改。当然这个层面不是JVM来保证了。</p>\n<h3>保证可见性的手段</h3>\n\n<p>保证可见性的第一种方法是直接使用锁，从效果上是可以的。但是前文说过，锁的方式对性能影响比较大。因此Java提供了另外一个关键字叫做volatile。这个关键字就是用来保证可见性的，它还有一个别称叫“轻量级锁”。</p>\n<p>volatile为什么可以保证可见性呢? 这里可以从JMM找到原理。在下一篇讲解JMM时我们将详细分析synchronized和volatile两个关键字的原理。</p>\n<h2>总结</h2>\n\n<p>原子性和可见性是并发编程里两个非常重要的基础概念，只有深入理解了这两个概念，我们才能用好锁，用好可见性。才能编写出性能优越，线程安全的代码来。</p>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>\n","excerpt":"<p>在并发编程的世界里，有两个非常重要的关键字，分别是synchronized和volatile. 一句话概括这两个关键字的作用的话就是synchronized保证了原子性，volatile保证了可见性。本文将深入分析原子性和可见性。</p>","more":"<h2>原子性</h2>\n\n<p>所谓原子性就是指操作不可分解，不会出现一半成功，一半失败的情况。我们都知道事务具有ACID属性，其中的A就是原子性。事务中的原子性也是说一个完整的事务中定义的全部操作步骤要么全部成功，要么全部不成功，不可分解。和我们这里的原子性定义是一样的。在并发编程中，我们在临界区的某些操作，必须具有原子性。因为我们无法控制线程的切换，所以就有可能发生线程执行到某个中间位置，因为时间片或者等待资源的情况发了上下文切换，切入到另外一个线程，这时候就破坏了数据的一致性。因此，我们必须保证临界区中这些操作的原子性。</p>\n<h3>保证原子性的手段</h3>\n\n<p>保证原子性的手段之一就是加锁。所谓锁，我们可以这么理解，当我们某个线程获取了锁，就代表他获得了一个特殊通行证，并且这个通行证一定是唯一的。在它归还这个通行证之前，其他线程是没办法进入到锁区域的。自然其他线程也就无法看到锁区域中数据的状态，也不能修改其状态。因此，只要我们的线程没有释放锁，其他线程是无法进入到锁区域的。直到我们成功释放了锁，我们的操作都是原子性的，不会被其他线程所干扰。</p>\n<p>加锁的第一种方式是synchronized，这是Java提供的一个关键字，这个关键字的含义就是内置锁或者监视器锁。当我们的线程进入到了synchronized区域时，自动会获取锁，当退出这个区域是自动释放锁。如果我们使用javap打印一下一个synchronized修饰的代码块，我们会发现，有个叫<strong>enter monitor</strong>和<strong>exit monitor</strong>的两条指令，它们所包围的指令就是使用synchronized修饰的区域。</p>\n<p>在J.U.C里，提供了更加灵活的加锁机制，就是Lock类，这是从Java代码层面提供的锁机制。这套机制比synchronized更加灵活，而且从JDK 1.6之后，这套锁机制的性能比synchronized更好了。这里面将锁划分的更细，可以有互斥锁(写锁)和共享锁(读锁)。获取锁和释放锁的操作都是可控的了，因此更加灵活，但是带来的使用复杂性也更加高了，如果我们获取了锁忘记释放锁或者释放锁失败将有可能会造成死锁等。</p>\n<p>当我们看过J.U.C实现锁的方式(基于AQS)，我们自己也可以实现锁。如果使用Semaphore类的话，自己实现锁就更加简单了。</p>\n<p>当然，保证原子性的手段并不是只有加锁这一种。事实上，锁机制对指令执行性能是有影响的。因此，如果不是有必要，我们不要随便加锁，而且加锁的区域尽量保证最小化，不要将没有必要加锁的代码放到锁区域中来。</p>\n<p>原子性的另外一种方式是无锁化。这个看起来比较矛盾，其实是不矛盾的。无锁化是通过CAS(Compare and set)来实现的。J.U.C中提供了一些原子类，它保证原子性的方式就是CAS。后续我们分析J.U.C的原子类时将详细讲解CAS操作。</p>\n<p>两种实现原子性的方式并不是可以互相替代的，而是他们在特定的场景具有特定的使用方式。加锁一般是代码块。而无锁化则是一些需要原子化的变量，通过CAS比使用加锁在变量层面性能更高。</p>\n<h2>可见性</h2>\n\n<p>所谓可见性是指我们希望对于某些状态我们进行了修改，希望其他线程能够感知到。这里就有线程通信的意思在里面了。考虑这样一种场景，变量x是两个线程A,B都可以看到的，线程A，B都保存了一份副本在彼此的栈帧里，当线程A修改了x时，如果没有一种机制去通信告知线程B，线程B仍然使用的是旧的x值。因此可见性就是要保证线程B能及时感知到x的状态变化。同样在CPU层面，也有这种场景，比如多核多寄存器。同样有变量的缓存以及修改需要通知其他CPU或寄存器变量的修改。当然这个层面不是JVM来保证了。</p>\n<h3>保证可见性的手段</h3>\n\n<p>保证可见性的第一种方法是直接使用锁，从效果上是可以的。但是前文说过，锁的方式对性能影响比较大。因此Java提供了另外一个关键字叫做volatile。这个关键字就是用来保证可见性的，它还有一个别称叫“轻量级锁”。</p>\n<p>volatile为什么可以保证可见性呢? 这里可以从JMM找到原理。在下一篇讲解JMM时我们将详细分析synchronized和volatile两个关键字的原理。</p>\n<h2>总结</h2>\n\n<p>原子性和可见性是并发编程里两个非常重要的基础概念，只有深入理解了这两个概念，我们才能用好锁，用好可见性。才能编写出性能优越，线程安全的代码来。</p>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>"},{"title":"Java并发编程的基本手段","date":"2016-10-18T15:25:18.000Z","_content":"\n实现并发的一个关键或者说核心手段就是使用多线程。线程就是轻量级的进程。它和进程的区别在于是否共享临界区或者说共享数据内存。我们一般把可以分解的任务使用多线程来实现。所谓可以分解的任务就是可以并行化的任务。比如从1加到100，我们可以先两两相加，求得的和再两两相加。这里两两相加都一样的，只是输入的加数不一样而已，显然是可以并行化的。本文将介绍Java中实现并发的几种方法以及两个重要的关键字的用法。\n\n<!--more-->\n\n<h2>继承Thread类</h2>\n\n初学Java的人学到多线程介绍的方法一定是继承**Thread**类，然后覆写其中的**run**方法。启动线程的时候再调用该Thread类的start方法。\n\n但是Java只支持单继承，如果要既要实现线程，又要继承其他类的话就需要使用接口了。因此才有了**Runnable**接口。\n\n<h2>实现Runnable接口</h2>\n\n所谓接口，就是一个约定，一个规范。Runnable接口约定了我们如果要抽象出一个任务来实现多线程，只要实现run方法接口。然后把这个Runnable子类放到Thread作为参数去调用即可。\n\n查看Thread源码或Runnable的run方法签名即可知道，这两种方式执行完都是没有返回值的。假如我们有一个任务需要将返回值返回出来怎么办？一种方式是通过传参，并且这个参数是引用参数。但是这种方式有点C语言味道。在Java里，更加直观的方式显然是通过返回值。怎么办呢？\n\n<h2>实现Callable接口</h2>\n\n在J.U.C(java.util.concurrent)包里，从J.D.K 1.5开始就提供了一个叫做**Callable**接口的类。这个接口有一个方法叫做**call**，在使用前需要指定返回值V，该方法就可以返回一个V类型的对象。\n\n除了有返回值，这个接口和**Runnable**接口的功能一模一样。但是用法稍微有些不同。显然，不能像Runnable一样放到Thread里。这个接口是J.U.C提供的，自然在J.U.C里有相应的类来执行Callable子类。\n\n这就是Executors框架。\n\nExecutors框架最常见的功能就是提供了4中类型的线程池。抽象线程池(AbstractExecutorService)提供了一个submit方法和newTaskFor方法。submit方法就是将一个Callable类作为参数提交到线程池，当线程池执行完之后会返回一个Future对象将返回值带出来。newTaskFor是一个装饰器方法，返回一个RunableFuture对象，这个对象就是一个包装的任务。可以用于线程池的工作窃取队列等地方。详细的线程池以及使用在后面用单独的文章来说明。\n\n<h2>线程的本质</h2>\n\n关于线程的形象描述。我只服这篇[文章](https://segmentfault.com/a/1190000004694556)。\n\n这里阐述线程的本质，我打算从Java中Thread类的源码角度来阐述。\n\n首先，看看javadoc关于线程的一些描述。\n\n{% cq %}A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently. {% endcq %}\n\n从这里我们可以看出，Java中的线程是虚拟机层面的线程。是由虚拟机来保证并发的。那么它和操作系统层面提供的线程是否是一一对应？这点我没有看过JVM的源码，因此无法说出准确答案。但是从Thread源码来看,虚拟机的线程和操作系统是有关系的。因为在Thread类中引用了一些native方法，只是这些native方法源码以及实现我目前还无法得知。\n\n``` \nprivate static native void registerNatives(); \n```\n\n一个线程的一些基本属性有优先级，线程名(可以不指定)等。这些属性在初始化一个线程的时候，可以通过构造函数来设置。\n\n\n<h3>线程的一些基本概念</h3>\n\n\n<h4>1 守护线程</h4>\n\n所谓守护线程是指一些优先级比较低(通常情况下),在后台执行的一些线程。比如我们的程序入口main函数所在的线程，JVM的垃圾回收线程等。守护线程的特点就是它要等其他所有非守护线程执行完成，JVM虚拟机打算退出的时候它在结束运行。守护线程的作用就是用于一些后台执行的任务，一般来说，他们的优先级不是很高。不然其他普通线程都没有时间片去执行了。\n\n<h4>2 线程组</h4>\n\nThreadGroup就是将一些功能相近的线程或者有父子关系的线程放到一个集合里。这个集合就是ThreadGroup，它内部就是一个数组。同时也可以将ThreadGroup放进去。这样相互联系的一些线程之间的拓扑关系就可以表达出来。使用线程组的好处是我们可以一次设置一组线程的属性，比如优先级，名字，是否是守护线程等。同时还可以一次控制一组线程(线程组的暂停唤醒方法因为安全问题已经不建议使用了)。\n\n<h4>3 线程优先级</h4>\n\n这个概念应该很好理解。Java里将线程优先级定义为 1-10，同时定义了三个常量：\n\n```\npublic final static int MIN_PRIORITY = 1;\n\npublic final static int NORM_PRIORITY = 5;\n\npublic final static int MAX_PRIORITY = 10;\n\n```\n\n一般我们就用这三种级别来设定线程优先级即可。优先级越高，就越优先执行。\n\n<h3>线程的生命周期</h3>\n\n前面说过，启动一个线程调用Thread的start方法。线程从启动开始到线程执行完毕被操作系统回收，是有一系列的生命周期状态转换的。在Java里，这些状态定义在Thread内部的一个枚举State里。这5个状态分别是\tNEW,RUNNABLE,BLOCKED,WAITTING,TIMED_WAITING。关于状态的互相转换以及如何观察线程状态可以另开一篇文章来说明了。这里不再详述，总之和操作系统课上关于进程的状态转换有一点点类似。\n\n<h3>线程的通信</h3>\n\n线程最重要的一个话题就是线程之间的通信。因为线程之间彼此共享内存，因此必然存在一些线程安全问题和线程通信问题。线程中的wait,join,notify,sleep等方法都是为线程通信而产生的。具体作用可以在文档以及后续博文中找到。\n\n<h3>static,final等对线程安全的意义</h3>\n\n关于static，final这两个关键字的一些用法是每个资深Javaer必须掌握的。static对于线程安全的意义更多的体现在修饰一个变量上。当一个变量是static变量时意味着这个变量是个类变量，被全部线程所共享。因此必然存在线程安全问题。而final修饰一个变量则是不可变的意思。修饰引用指引用关系不可变。因此，在多线程里，可以使用static和final来实现依一些数据共享和线程安全的问题。\n\n<h3>总结展望</h3>\n\n本文很简单的介绍了Java中实现并发的几种方式。同时概括性地点到了线程的一些基本概念和线程通信和安全问题。要说清楚这些问题不是这么一篇文章能够说清楚的。这里我感到自己语言总结和学识的精通程度还没有达到专家水准。因此有些问题尽管我知道在生产实践中应该怎么用以及会出现什么问题，但是要介绍给读者却有些困难。希望后面有时间能够详细阐释清楚每一个问题。\n\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n","source":"_posts/20161018-1.md","raw":"---\ntitle: Java并发编程的基本手段\ndate: 2016-10-18 23:25:18\ntags: \n - 并发编程\n - 并发\n - 线程\ncategories: 深入理解\n---\n\n实现并发的一个关键或者说核心手段就是使用多线程。线程就是轻量级的进程。它和进程的区别在于是否共享临界区或者说共享数据内存。我们一般把可以分解的任务使用多线程来实现。所谓可以分解的任务就是可以并行化的任务。比如从1加到100，我们可以先两两相加，求得的和再两两相加。这里两两相加都一样的，只是输入的加数不一样而已，显然是可以并行化的。本文将介绍Java中实现并发的几种方法以及两个重要的关键字的用法。\n\n<!--more-->\n\n<h2>继承Thread类</h2>\n\n初学Java的人学到多线程介绍的方法一定是继承**Thread**类，然后覆写其中的**run**方法。启动线程的时候再调用该Thread类的start方法。\n\n但是Java只支持单继承，如果要既要实现线程，又要继承其他类的话就需要使用接口了。因此才有了**Runnable**接口。\n\n<h2>实现Runnable接口</h2>\n\n所谓接口，就是一个约定，一个规范。Runnable接口约定了我们如果要抽象出一个任务来实现多线程，只要实现run方法接口。然后把这个Runnable子类放到Thread作为参数去调用即可。\n\n查看Thread源码或Runnable的run方法签名即可知道，这两种方式执行完都是没有返回值的。假如我们有一个任务需要将返回值返回出来怎么办？一种方式是通过传参，并且这个参数是引用参数。但是这种方式有点C语言味道。在Java里，更加直观的方式显然是通过返回值。怎么办呢？\n\n<h2>实现Callable接口</h2>\n\n在J.U.C(java.util.concurrent)包里，从J.D.K 1.5开始就提供了一个叫做**Callable**接口的类。这个接口有一个方法叫做**call**，在使用前需要指定返回值V，该方法就可以返回一个V类型的对象。\n\n除了有返回值，这个接口和**Runnable**接口的功能一模一样。但是用法稍微有些不同。显然，不能像Runnable一样放到Thread里。这个接口是J.U.C提供的，自然在J.U.C里有相应的类来执行Callable子类。\n\n这就是Executors框架。\n\nExecutors框架最常见的功能就是提供了4中类型的线程池。抽象线程池(AbstractExecutorService)提供了一个submit方法和newTaskFor方法。submit方法就是将一个Callable类作为参数提交到线程池，当线程池执行完之后会返回一个Future对象将返回值带出来。newTaskFor是一个装饰器方法，返回一个RunableFuture对象，这个对象就是一个包装的任务。可以用于线程池的工作窃取队列等地方。详细的线程池以及使用在后面用单独的文章来说明。\n\n<h2>线程的本质</h2>\n\n关于线程的形象描述。我只服这篇[文章](https://segmentfault.com/a/1190000004694556)。\n\n这里阐述线程的本质，我打算从Java中Thread类的源码角度来阐述。\n\n首先，看看javadoc关于线程的一些描述。\n\n{% cq %}A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently. {% endcq %}\n\n从这里我们可以看出，Java中的线程是虚拟机层面的线程。是由虚拟机来保证并发的。那么它和操作系统层面提供的线程是否是一一对应？这点我没有看过JVM的源码，因此无法说出准确答案。但是从Thread源码来看,虚拟机的线程和操作系统是有关系的。因为在Thread类中引用了一些native方法，只是这些native方法源码以及实现我目前还无法得知。\n\n``` \nprivate static native void registerNatives(); \n```\n\n一个线程的一些基本属性有优先级，线程名(可以不指定)等。这些属性在初始化一个线程的时候，可以通过构造函数来设置。\n\n\n<h3>线程的一些基本概念</h3>\n\n\n<h4>1 守护线程</h4>\n\n所谓守护线程是指一些优先级比较低(通常情况下),在后台执行的一些线程。比如我们的程序入口main函数所在的线程，JVM的垃圾回收线程等。守护线程的特点就是它要等其他所有非守护线程执行完成，JVM虚拟机打算退出的时候它在结束运行。守护线程的作用就是用于一些后台执行的任务，一般来说，他们的优先级不是很高。不然其他普通线程都没有时间片去执行了。\n\n<h4>2 线程组</h4>\n\nThreadGroup就是将一些功能相近的线程或者有父子关系的线程放到一个集合里。这个集合就是ThreadGroup，它内部就是一个数组。同时也可以将ThreadGroup放进去。这样相互联系的一些线程之间的拓扑关系就可以表达出来。使用线程组的好处是我们可以一次设置一组线程的属性，比如优先级，名字，是否是守护线程等。同时还可以一次控制一组线程(线程组的暂停唤醒方法因为安全问题已经不建议使用了)。\n\n<h4>3 线程优先级</h4>\n\n这个概念应该很好理解。Java里将线程优先级定义为 1-10，同时定义了三个常量：\n\n```\npublic final static int MIN_PRIORITY = 1;\n\npublic final static int NORM_PRIORITY = 5;\n\npublic final static int MAX_PRIORITY = 10;\n\n```\n\n一般我们就用这三种级别来设定线程优先级即可。优先级越高，就越优先执行。\n\n<h3>线程的生命周期</h3>\n\n前面说过，启动一个线程调用Thread的start方法。线程从启动开始到线程执行完毕被操作系统回收，是有一系列的生命周期状态转换的。在Java里，这些状态定义在Thread内部的一个枚举State里。这5个状态分别是\tNEW,RUNNABLE,BLOCKED,WAITTING,TIMED_WAITING。关于状态的互相转换以及如何观察线程状态可以另开一篇文章来说明了。这里不再详述，总之和操作系统课上关于进程的状态转换有一点点类似。\n\n<h3>线程的通信</h3>\n\n线程最重要的一个话题就是线程之间的通信。因为线程之间彼此共享内存，因此必然存在一些线程安全问题和线程通信问题。线程中的wait,join,notify,sleep等方法都是为线程通信而产生的。具体作用可以在文档以及后续博文中找到。\n\n<h3>static,final等对线程安全的意义</h3>\n\n关于static，final这两个关键字的一些用法是每个资深Javaer必须掌握的。static对于线程安全的意义更多的体现在修饰一个变量上。当一个变量是static变量时意味着这个变量是个类变量，被全部线程所共享。因此必然存在线程安全问题。而final修饰一个变量则是不可变的意思。修饰引用指引用关系不可变。因此，在多线程里，可以使用static和final来实现依一些数据共享和线程安全的问题。\n\n<h3>总结展望</h3>\n\n本文很简单的介绍了Java中实现并发的几种方式。同时概括性地点到了线程的一些基本概念和线程通信和安全问题。要说清楚这些问题不是这么一篇文章能够说清楚的。这里我感到自己语言总结和学识的精通程度还没有达到专家水准。因此有些问题尽管我知道在生产实践中应该怎么用以及会出现什么问题，但是要介绍给读者却有些困难。希望后面有时间能够详细阐释清楚每一个问题。\n\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n","slug":"20161018-1","published":1,"updated":"2016-10-18T12:49:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3j000k1atioowr259o","content":"<p>实现并发的一个关键或者说核心手段就是使用多线程。线程就是轻量级的进程。它和进程的区别在于是否共享临界区或者说共享数据内存。我们一般把可以分解的任务使用多线程来实现。所谓可以分解的任务就是可以并行化的任务。比如从1加到100，我们可以先两两相加，求得的和再两两相加。这里两两相加都一样的，只是输入的加数不一样而已，显然是可以并行化的。本文将介绍Java中实现并发的几种方法以及两个重要的关键字的用法。</p>\n<a id=\"more\"></a>\n<h2>继承Thread类</h2>\n\n<p>初学Java的人学到多线程介绍的方法一定是继承<strong>Thread</strong>类，然后覆写其中的<strong>run</strong>方法。启动线程的时候再调用该Thread类的start方法。</p>\n<p>但是Java只支持单继承，如果要既要实现线程，又要继承其他类的话就需要使用接口了。因此才有了<strong>Runnable</strong>接口。</p>\n<h2>实现Runnable接口</h2>\n\n<p>所谓接口，就是一个约定，一个规范。Runnable接口约定了我们如果要抽象出一个任务来实现多线程，只要实现run方法接口。然后把这个Runnable子类放到Thread作为参数去调用即可。</p>\n<p>查看Thread源码或Runnable的run方法签名即可知道，这两种方式执行完都是没有返回值的。假如我们有一个任务需要将返回值返回出来怎么办？一种方式是通过传参，并且这个参数是引用参数。但是这种方式有点C语言味道。在Java里，更加直观的方式显然是通过返回值。怎么办呢？</p>\n<h2>实现Callable接口</h2>\n\n<p>在J.U.C(java.util.concurrent)包里，从J.D.K 1.5开始就提供了一个叫做<strong>Callable</strong>接口的类。这个接口有一个方法叫做<strong>call</strong>，在使用前需要指定返回值V，该方法就可以返回一个V类型的对象。</p>\n<p>除了有返回值，这个接口和<strong>Runnable</strong>接口的功能一模一样。但是用法稍微有些不同。显然，不能像Runnable一样放到Thread里。这个接口是J.U.C提供的，自然在J.U.C里有相应的类来执行Callable子类。</p>\n<p>这就是Executors框架。</p>\n<p>Executors框架最常见的功能就是提供了4中类型的线程池。抽象线程池(AbstractExecutorService)提供了一个submit方法和newTaskFor方法。submit方法就是将一个Callable类作为参数提交到线程池，当线程池执行完之后会返回一个Future对象将返回值带出来。newTaskFor是一个装饰器方法，返回一个RunableFuture对象，这个对象就是一个包装的任务。可以用于线程池的工作窃取队列等地方。详细的线程池以及使用在后面用单独的文章来说明。</p>\n<h2>线程的本质</h2>\n\n<p>关于线程的形象描述。我只服这篇<a href=\"https://segmentfault.com/a/1190000004694556\" target=\"_blank\" rel=\"external\">文章</a>。</p>\n<p>这里阐述线程的本质，我打算从Java中Thread类的源码角度来阐述。</p>\n<p>首先，看看javadoc关于线程的一些描述。</p>\n<blockquote class=\"blockquote-center\"><p>A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently. </p>\n</blockquote>\n<p>从这里我们可以看出，Java中的线程是虚拟机层面的线程。是由虚拟机来保证并发的。那么它和操作系统层面提供的线程是否是一一对应？这点我没有看过JVM的源码，因此无法说出准确答案。但是从Thread源码来看,虚拟机的线程和操作系统是有关系的。因为在Thread类中引用了一些native方法，只是这些native方法源码以及实现我目前还无法得知。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static native void registerNatives();</div></pre></td></tr></table></figure>\n<p>一个线程的一些基本属性有优先级，线程名(可以不指定)等。这些属性在初始化一个线程的时候，可以通过构造函数来设置。</p>\n<h3>线程的一些基本概念</h3>\n\n\n<h4>1 守护线程</h4>\n\n<p>所谓守护线程是指一些优先级比较低(通常情况下),在后台执行的一些线程。比如我们的程序入口main函数所在的线程，JVM的垃圾回收线程等。守护线程的特点就是它要等其他所有非守护线程执行完成，JVM虚拟机打算退出的时候它在结束运行。守护线程的作用就是用于一些后台执行的任务，一般来说，他们的优先级不是很高。不然其他普通线程都没有时间片去执行了。</p>\n<h4>2 线程组</h4>\n\n<p>ThreadGroup就是将一些功能相近的线程或者有父子关系的线程放到一个集合里。这个集合就是ThreadGroup，它内部就是一个数组。同时也可以将ThreadGroup放进去。这样相互联系的一些线程之间的拓扑关系就可以表达出来。使用线程组的好处是我们可以一次设置一组线程的属性，比如优先级，名字，是否是守护线程等。同时还可以一次控制一组线程(线程组的暂停唤醒方法因为安全问题已经不建议使用了)。</p>\n<h4>3 线程优先级</h4>\n\n<p>这个概念应该很好理解。Java里将线程优先级定义为 1-10，同时定义了三个常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final static int MIN_PRIORITY = 1;</div><div class=\"line\"></div><div class=\"line\">public final static int NORM_PRIORITY = 5;</div><div class=\"line\"></div><div class=\"line\">public final static int MAX_PRIORITY = 10;</div></pre></td></tr></table></figure>\n<p>一般我们就用这三种级别来设定线程优先级即可。优先级越高，就越优先执行。</p>\n<h3>线程的生命周期</h3>\n\n<p>前面说过，启动一个线程调用Thread的start方法。线程从启动开始到线程执行完毕被操作系统回收，是有一系列的生命周期状态转换的。在Java里，这些状态定义在Thread内部的一个枚举State里。这5个状态分别是    NEW,RUNNABLE,BLOCKED,WAITTING,TIMED_WAITING。关于状态的互相转换以及如何观察线程状态可以另开一篇文章来说明了。这里不再详述，总之和操作系统课上关于进程的状态转换有一点点类似。</p>\n<h3>线程的通信</h3>\n\n<p>线程最重要的一个话题就是线程之间的通信。因为线程之间彼此共享内存，因此必然存在一些线程安全问题和线程通信问题。线程中的wait,join,notify,sleep等方法都是为线程通信而产生的。具体作用可以在文档以及后续博文中找到。</p>\n<h3>static,final等对线程安全的意义</h3>\n\n<p>关于static，final这两个关键字的一些用法是每个资深Javaer必须掌握的。static对于线程安全的意义更多的体现在修饰一个变量上。当一个变量是static变量时意味着这个变量是个类变量，被全部线程所共享。因此必然存在线程安全问题。而final修饰一个变量则是不可变的意思。修饰引用指引用关系不可变。因此，在多线程里，可以使用static和final来实现依一些数据共享和线程安全的问题。</p>\n<h3>总结展望</h3>\n\n<p>本文很简单的介绍了Java中实现并发的几种方式。同时概括性地点到了线程的一些基本概念和线程通信和安全问题。要说清楚这些问题不是这么一篇文章能够说清楚的。这里我感到自己语言总结和学识的精通程度还没有达到专家水准。因此有些问题尽管我知道在生产实践中应该怎么用以及会出现什么问题，但是要介绍给读者却有些困难。希望后面有时间能够详细阐释清楚每一个问题。</p>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>\n","excerpt":"<p>实现并发的一个关键或者说核心手段就是使用多线程。线程就是轻量级的进程。它和进程的区别在于是否共享临界区或者说共享数据内存。我们一般把可以分解的任务使用多线程来实现。所谓可以分解的任务就是可以并行化的任务。比如从1加到100，我们可以先两两相加，求得的和再两两相加。这里两两相加都一样的，只是输入的加数不一样而已，显然是可以并行化的。本文将介绍Java中实现并发的几种方法以及两个重要的关键字的用法。</p>","more":"<h2>继承Thread类</h2>\n\n<p>初学Java的人学到多线程介绍的方法一定是继承<strong>Thread</strong>类，然后覆写其中的<strong>run</strong>方法。启动线程的时候再调用该Thread类的start方法。</p>\n<p>但是Java只支持单继承，如果要既要实现线程，又要继承其他类的话就需要使用接口了。因此才有了<strong>Runnable</strong>接口。</p>\n<h2>实现Runnable接口</h2>\n\n<p>所谓接口，就是一个约定，一个规范。Runnable接口约定了我们如果要抽象出一个任务来实现多线程，只要实现run方法接口。然后把这个Runnable子类放到Thread作为参数去调用即可。</p>\n<p>查看Thread源码或Runnable的run方法签名即可知道，这两种方式执行完都是没有返回值的。假如我们有一个任务需要将返回值返回出来怎么办？一种方式是通过传参，并且这个参数是引用参数。但是这种方式有点C语言味道。在Java里，更加直观的方式显然是通过返回值。怎么办呢？</p>\n<h2>实现Callable接口</h2>\n\n<p>在J.U.C(java.util.concurrent)包里，从J.D.K 1.5开始就提供了一个叫做<strong>Callable</strong>接口的类。这个接口有一个方法叫做<strong>call</strong>，在使用前需要指定返回值V，该方法就可以返回一个V类型的对象。</p>\n<p>除了有返回值，这个接口和<strong>Runnable</strong>接口的功能一模一样。但是用法稍微有些不同。显然，不能像Runnable一样放到Thread里。这个接口是J.U.C提供的，自然在J.U.C里有相应的类来执行Callable子类。</p>\n<p>这就是Executors框架。</p>\n<p>Executors框架最常见的功能就是提供了4中类型的线程池。抽象线程池(AbstractExecutorService)提供了一个submit方法和newTaskFor方法。submit方法就是将一个Callable类作为参数提交到线程池，当线程池执行完之后会返回一个Future对象将返回值带出来。newTaskFor是一个装饰器方法，返回一个RunableFuture对象，这个对象就是一个包装的任务。可以用于线程池的工作窃取队列等地方。详细的线程池以及使用在后面用单独的文章来说明。</p>\n<h2>线程的本质</h2>\n\n<p>关于线程的形象描述。我只服这篇<a href=\"https://segmentfault.com/a/1190000004694556\">文章</a>。</p>\n<p>这里阐述线程的本质，我打算从Java中Thread类的源码角度来阐述。</p>\n<p>首先，看看javadoc关于线程的一些描述。</p>\n<blockquote class=\"blockquote-center\"><p>A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently. </p>\n</blockquote>\n<p>从这里我们可以看出，Java中的线程是虚拟机层面的线程。是由虚拟机来保证并发的。那么它和操作系统层面提供的线程是否是一一对应？这点我没有看过JVM的源码，因此无法说出准确答案。但是从Thread源码来看,虚拟机的线程和操作系统是有关系的。因为在Thread类中引用了一些native方法，只是这些native方法源码以及实现我目前还无法得知。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static native void registerNatives();</div></pre></td></tr></table></figure>\n<p>一个线程的一些基本属性有优先级，线程名(可以不指定)等。这些属性在初始化一个线程的时候，可以通过构造函数来设置。</p>\n<h3>线程的一些基本概念</h3>\n\n\n<h4>1 守护线程</h4>\n\n<p>所谓守护线程是指一些优先级比较低(通常情况下),在后台执行的一些线程。比如我们的程序入口main函数所在的线程，JVM的垃圾回收线程等。守护线程的特点就是它要等其他所有非守护线程执行完成，JVM虚拟机打算退出的时候它在结束运行。守护线程的作用就是用于一些后台执行的任务，一般来说，他们的优先级不是很高。不然其他普通线程都没有时间片去执行了。</p>\n<h4>2 线程组</h4>\n\n<p>ThreadGroup就是将一些功能相近的线程或者有父子关系的线程放到一个集合里。这个集合就是ThreadGroup，它内部就是一个数组。同时也可以将ThreadGroup放进去。这样相互联系的一些线程之间的拓扑关系就可以表达出来。使用线程组的好处是我们可以一次设置一组线程的属性，比如优先级，名字，是否是守护线程等。同时还可以一次控制一组线程(线程组的暂停唤醒方法因为安全问题已经不建议使用了)。</p>\n<h4>3 线程优先级</h4>\n\n<p>这个概念应该很好理解。Java里将线程优先级定义为 1-10，同时定义了三个常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final static int MIN_PRIORITY = 1;</div><div class=\"line\"></div><div class=\"line\">public final static int NORM_PRIORITY = 5;</div><div class=\"line\"></div><div class=\"line\">public final static int MAX_PRIORITY = 10;</div></pre></td></tr></table></figure>\n<p>一般我们就用这三种级别来设定线程优先级即可。优先级越高，就越优先执行。</p>\n<h3>线程的生命周期</h3>\n\n<p>前面说过，启动一个线程调用Thread的start方法。线程从启动开始到线程执行完毕被操作系统回收，是有一系列的生命周期状态转换的。在Java里，这些状态定义在Thread内部的一个枚举State里。这5个状态分别是    NEW,RUNNABLE,BLOCKED,WAITTING,TIMED_WAITING。关于状态的互相转换以及如何观察线程状态可以另开一篇文章来说明了。这里不再详述，总之和操作系统课上关于进程的状态转换有一点点类似。</p>\n<h3>线程的通信</h3>\n\n<p>线程最重要的一个话题就是线程之间的通信。因为线程之间彼此共享内存，因此必然存在一些线程安全问题和线程通信问题。线程中的wait,join,notify,sleep等方法都是为线程通信而产生的。具体作用可以在文档以及后续博文中找到。</p>\n<h3>static,final等对线程安全的意义</h3>\n\n<p>关于static，final这两个关键字的一些用法是每个资深Javaer必须掌握的。static对于线程安全的意义更多的体现在修饰一个变量上。当一个变量是static变量时意味着这个变量是个类变量，被全部线程所共享。因此必然存在线程安全问题。而final修饰一个变量则是不可变的意思。修饰引用指引用关系不可变。因此，在多线程里，可以使用static和final来实现依一些数据共享和线程安全的问题。</p>\n<h3>总结展望</h3>\n\n<p>本文很简单的介绍了Java中实现并发的几种方式。同时概括性地点到了线程的一些基本概念和线程通信和安全问题。要说清楚这些问题不是这么一篇文章能够说清楚的。这里我感到自己语言总结和学识的精通程度还没有达到专家水准。因此有些问题尽管我知道在生产实践中应该怎么用以及会出现什么问题，但是要介绍给读者却有些困难。希望后面有时间能够详细阐释清楚每一个问题。</p>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>"},{"title":"多线程带来的线程安全和线程通信问题","date":"2016-10-20T09:29:07.000Z","_content":"前文多次说过，多线程会带来线程安全问题以及线程与线程之间需要进行通信。在本文中，我想说说我理解的线程安全以及线程通信问题。当然，依然保持我博客的特点，很多东西仅仅点到为止，不做非常深入的分析。原因在于我自认为我离专家还有一定的距离，因此对于这些知识不敢以专家自居。仅仅分享我的理解，起到一个提纲挈领的作用。读者如果想要就某个点深入下去，还是需要一定的时间钻研的。 \n\n<!--more-->\n\n<h2>临界区</h2>\n\n只要是涉及到多线程，就一定涉及到临界区。前文说过，线程与进程的重要区别是线程共享临界区。临界区就是多个线程共享的一块内存。可以这样说，线程安全和线程通信的基础就是临界区。因此，只要是多线程编程，一定要时刻考虑临界区的数据变化。\n\n<h2>线程安全的本质</h2>\n\n在《Java并发编程实战》这本著作中对线程安全的定义大概是这样的(大概意思，非原文)，多线程的数据表现和单线程的数据表现是一样的话我们认为这个是线程安全的。我认为线程安全有这么几种情况。\n\n<h3>1 指令线程安全</h3>\n\n指令线程安全这个术语是本人原创(如有雷同，纯属意外)。对于**a++**类似的语句，我们都知道，JVM会编译成三条指令。因此如果在多线程环境下，因为线程上下文切换等就可能造成线程安全问题最终导致数据不一致。这种情况的办法一般只有使用原子锁或一些线程安全机制了(比如CAS)。指令线程安全还有一种情况是指令的重排序。\n\n**重排序**\n\n重排序是指CPU或者操作系统或者编译器在考虑性能的情况下对某些彼此关系不是很大的指令进行了优化和调整执行顺序。这里需要说明的是如果两条指令有非常明显的逻辑顺序，颠倒的话会影响语义的话是不会进行重排序的。重排序有三个层次，分别是CPU基本的重排序，操作系统执行时的重排序以及Java编译器的重排序。如果不考虑原子性或者可见性，在多线程环境下因为指令重排序是会导致线程安全问题的。因此针对这些，Java才定义了一个JMM(Java Memory Model Java内存模型)。关于JMM，这里不再展开，后面相关专题再涉及。\n\n<h3>2 共享数据线程安全</h3>\n\n所谓共享数据是指临界区的数据。在多线程环境下，这些数据事实上是暴露给各个线程的。各个线程都有权对其进行操作。因此这里自然就产生了线程安全问题。同样，共享数据只能通过加锁或者私有化(著名的ThreadLocal可以理解为干这事)或者直接让其不可变(final,权限控制)来实现线程安全，有句话说最好的线程安全就是让其不可变。\n\n<h2>线程通信的本质</h2>\n\n在保证线程安全的情况下，多线程之间需要进行通信的。这里的通信不是指发消息这种通信。我们可以把线程通信理解为多线程之间线程之间的协调。而协调的一些机制就是通过发送指令或者一种消息给JVM或操作系统来实现协调的。\n\n<h3>线程通信的手段</h3>\n\nJava里实现线程通信的方法有很多。最常见的有Object类的wait和notify系列。Thread里的sleep和Join等。同时在J.U.C里，提供了很多方式来实现线程通信，比如闭锁(CountDownLatch)，栅栏(CyclicBarrier)，条件类(Condition)等。同时，线程还提供了中断机制等，我们自己也可以控制一个线程的执行。需要说明的是因为消息安全(比如丢失消息)问题导致的死锁等，JDK已经废弃了Thread的stop等方法。\n\n<h2>总结</h2>\n\n本文从大逻辑点到了多线程带来的线程安全问题和线程之间通信的方法。很多东西如果研究下去又可以单独写一篇文章了。在后面会对一些比较重要的地方再做说明。\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n\n","source":"_posts/20161020-1.md","raw":"---\ntitle: '多线程带来的线程安全和线程通信问题'\ndate: 2016-10-20 17:29:07\ntags: \n - 并发\n - 多线程通信\n - 线程安全\ncategories: 深入理解\n---\n前文多次说过，多线程会带来线程安全问题以及线程与线程之间需要进行通信。在本文中，我想说说我理解的线程安全以及线程通信问题。当然，依然保持我博客的特点，很多东西仅仅点到为止，不做非常深入的分析。原因在于我自认为我离专家还有一定的距离，因此对于这些知识不敢以专家自居。仅仅分享我的理解，起到一个提纲挈领的作用。读者如果想要就某个点深入下去，还是需要一定的时间钻研的。 \n\n<!--more-->\n\n<h2>临界区</h2>\n\n只要是涉及到多线程，就一定涉及到临界区。前文说过，线程与进程的重要区别是线程共享临界区。临界区就是多个线程共享的一块内存。可以这样说，线程安全和线程通信的基础就是临界区。因此，只要是多线程编程，一定要时刻考虑临界区的数据变化。\n\n<h2>线程安全的本质</h2>\n\n在《Java并发编程实战》这本著作中对线程安全的定义大概是这样的(大概意思，非原文)，多线程的数据表现和单线程的数据表现是一样的话我们认为这个是线程安全的。我认为线程安全有这么几种情况。\n\n<h3>1 指令线程安全</h3>\n\n指令线程安全这个术语是本人原创(如有雷同，纯属意外)。对于**a++**类似的语句，我们都知道，JVM会编译成三条指令。因此如果在多线程环境下，因为线程上下文切换等就可能造成线程安全问题最终导致数据不一致。这种情况的办法一般只有使用原子锁或一些线程安全机制了(比如CAS)。指令线程安全还有一种情况是指令的重排序。\n\n**重排序**\n\n重排序是指CPU或者操作系统或者编译器在考虑性能的情况下对某些彼此关系不是很大的指令进行了优化和调整执行顺序。这里需要说明的是如果两条指令有非常明显的逻辑顺序，颠倒的话会影响语义的话是不会进行重排序的。重排序有三个层次，分别是CPU基本的重排序，操作系统执行时的重排序以及Java编译器的重排序。如果不考虑原子性或者可见性，在多线程环境下因为指令重排序是会导致线程安全问题的。因此针对这些，Java才定义了一个JMM(Java Memory Model Java内存模型)。关于JMM，这里不再展开，后面相关专题再涉及。\n\n<h3>2 共享数据线程安全</h3>\n\n所谓共享数据是指临界区的数据。在多线程环境下，这些数据事实上是暴露给各个线程的。各个线程都有权对其进行操作。因此这里自然就产生了线程安全问题。同样，共享数据只能通过加锁或者私有化(著名的ThreadLocal可以理解为干这事)或者直接让其不可变(final,权限控制)来实现线程安全，有句话说最好的线程安全就是让其不可变。\n\n<h2>线程通信的本质</h2>\n\n在保证线程安全的情况下，多线程之间需要进行通信的。这里的通信不是指发消息这种通信。我们可以把线程通信理解为多线程之间线程之间的协调。而协调的一些机制就是通过发送指令或者一种消息给JVM或操作系统来实现协调的。\n\n<h3>线程通信的手段</h3>\n\nJava里实现线程通信的方法有很多。最常见的有Object类的wait和notify系列。Thread里的sleep和Join等。同时在J.U.C里，提供了很多方式来实现线程通信，比如闭锁(CountDownLatch)，栅栏(CyclicBarrier)，条件类(Condition)等。同时，线程还提供了中断机制等，我们自己也可以控制一个线程的执行。需要说明的是因为消息安全(比如丢失消息)问题导致的死锁等，JDK已经废弃了Thread的stop等方法。\n\n<h2>总结</h2>\n\n本文从大逻辑点到了多线程带来的线程安全问题和线程之间通信的方法。很多东西如果研究下去又可以单独写一篇文章了。在后面会对一些比较重要的地方再做说明。\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n\n","slug":"20161020-1","published":1,"updated":"2016-10-20T09:39:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3n000o1atiz054ykci","content":"<p>前文多次说过，多线程会带来线程安全问题以及线程与线程之间需要进行通信。在本文中，我想说说我理解的线程安全以及线程通信问题。当然，依然保持我博客的特点，很多东西仅仅点到为止，不做非常深入的分析。原因在于我自认为我离专家还有一定的距离，因此对于这些知识不敢以专家自居。仅仅分享我的理解，起到一个提纲挈领的作用。读者如果想要就某个点深入下去，还是需要一定的时间钻研的。 </p>\n<a id=\"more\"></a>\n<h2>临界区</h2>\n\n<p>只要是涉及到多线程，就一定涉及到临界区。前文说过，线程与进程的重要区别是线程共享临界区。临界区就是多个线程共享的一块内存。可以这样说，线程安全和线程通信的基础就是临界区。因此，只要是多线程编程，一定要时刻考虑临界区的数据变化。</p>\n<h2>线程安全的本质</h2>\n\n<p>在《Java并发编程实战》这本著作中对线程安全的定义大概是这样的(大概意思，非原文)，多线程的数据表现和单线程的数据表现是一样的话我们认为这个是线程安全的。我认为线程安全有这么几种情况。</p>\n<h3>1 指令线程安全</h3>\n\n<p>指令线程安全这个术语是本人原创(如有雷同，纯属意外)。对于<strong>a++</strong>类似的语句，我们都知道，JVM会编译成三条指令。因此如果在多线程环境下，因为线程上下文切换等就可能造成线程安全问题最终导致数据不一致。这种情况的办法一般只有使用原子锁或一些线程安全机制了(比如CAS)。指令线程安全还有一种情况是指令的重排序。</p>\n<p><strong>重排序</strong></p>\n<p>重排序是指CPU或者操作系统或者编译器在考虑性能的情况下对某些彼此关系不是很大的指令进行了优化和调整执行顺序。这里需要说明的是如果两条指令有非常明显的逻辑顺序，颠倒的话会影响语义的话是不会进行重排序的。重排序有三个层次，分别是CPU基本的重排序，操作系统执行时的重排序以及Java编译器的重排序。如果不考虑原子性或者可见性，在多线程环境下因为指令重排序是会导致线程安全问题的。因此针对这些，Java才定义了一个JMM(Java Memory Model Java内存模型)。关于JMM，这里不再展开，后面相关专题再涉及。</p>\n<h3>2 共享数据线程安全</h3>\n\n<p>所谓共享数据是指临界区的数据。在多线程环境下，这些数据事实上是暴露给各个线程的。各个线程都有权对其进行操作。因此这里自然就产生了线程安全问题。同样，共享数据只能通过加锁或者私有化(著名的ThreadLocal可以理解为干这事)或者直接让其不可变(final,权限控制)来实现线程安全，有句话说最好的线程安全就是让其不可变。</p>\n<h2>线程通信的本质</h2>\n\n<p>在保证线程安全的情况下，多线程之间需要进行通信的。这里的通信不是指发消息这种通信。我们可以把线程通信理解为多线程之间线程之间的协调。而协调的一些机制就是通过发送指令或者一种消息给JVM或操作系统来实现协调的。</p>\n<h3>线程通信的手段</h3>\n\n<p>Java里实现线程通信的方法有很多。最常见的有Object类的wait和notify系列。Thread里的sleep和Join等。同时在J.U.C里，提供了很多方式来实现线程通信，比如闭锁(CountDownLatch)，栅栏(CyclicBarrier)，条件类(Condition)等。同时，线程还提供了中断机制等，我们自己也可以控制一个线程的执行。需要说明的是因为消息安全(比如丢失消息)问题导致的死锁等，JDK已经废弃了Thread的stop等方法。</p>\n<h2>总结</h2>\n\n<p>本文从大逻辑点到了多线程带来的线程安全问题和线程之间通信的方法。很多东西如果研究下去又可以单独写一篇文章了。在后面会对一些比较重要的地方再做说明。</p>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>\n","excerpt":"<p>前文多次说过，多线程会带来线程安全问题以及线程与线程之间需要进行通信。在本文中，我想说说我理解的线程安全以及线程通信问题。当然，依然保持我博客的特点，很多东西仅仅点到为止，不做非常深入的分析。原因在于我自认为我离专家还有一定的距离，因此对于这些知识不敢以专家自居。仅仅分享我的理解，起到一个提纲挈领的作用。读者如果想要就某个点深入下去，还是需要一定的时间钻研的。 </p>","more":"<h2>临界区</h2>\n\n<p>只要是涉及到多线程，就一定涉及到临界区。前文说过，线程与进程的重要区别是线程共享临界区。临界区就是多个线程共享的一块内存。可以这样说，线程安全和线程通信的基础就是临界区。因此，只要是多线程编程，一定要时刻考虑临界区的数据变化。</p>\n<h2>线程安全的本质</h2>\n\n<p>在《Java并发编程实战》这本著作中对线程安全的定义大概是这样的(大概意思，非原文)，多线程的数据表现和单线程的数据表现是一样的话我们认为这个是线程安全的。我认为线程安全有这么几种情况。</p>\n<h3>1 指令线程安全</h3>\n\n<p>指令线程安全这个术语是本人原创(如有雷同，纯属意外)。对于<strong>a++</strong>类似的语句，我们都知道，JVM会编译成三条指令。因此如果在多线程环境下，因为线程上下文切换等就可能造成线程安全问题最终导致数据不一致。这种情况的办法一般只有使用原子锁或一些线程安全机制了(比如CAS)。指令线程安全还有一种情况是指令的重排序。</p>\n<p><strong>重排序</strong></p>\n<p>重排序是指CPU或者操作系统或者编译器在考虑性能的情况下对某些彼此关系不是很大的指令进行了优化和调整执行顺序。这里需要说明的是如果两条指令有非常明显的逻辑顺序，颠倒的话会影响语义的话是不会进行重排序的。重排序有三个层次，分别是CPU基本的重排序，操作系统执行时的重排序以及Java编译器的重排序。如果不考虑原子性或者可见性，在多线程环境下因为指令重排序是会导致线程安全问题的。因此针对这些，Java才定义了一个JMM(Java Memory Model Java内存模型)。关于JMM，这里不再展开，后面相关专题再涉及。</p>\n<h3>2 共享数据线程安全</h3>\n\n<p>所谓共享数据是指临界区的数据。在多线程环境下，这些数据事实上是暴露给各个线程的。各个线程都有权对其进行操作。因此这里自然就产生了线程安全问题。同样，共享数据只能通过加锁或者私有化(著名的ThreadLocal可以理解为干这事)或者直接让其不可变(final,权限控制)来实现线程安全，有句话说最好的线程安全就是让其不可变。</p>\n<h2>线程通信的本质</h2>\n\n<p>在保证线程安全的情况下，多线程之间需要进行通信的。这里的通信不是指发消息这种通信。我们可以把线程通信理解为多线程之间线程之间的协调。而协调的一些机制就是通过发送指令或者一种消息给JVM或操作系统来实现协调的。</p>\n<h3>线程通信的手段</h3>\n\n<p>Java里实现线程通信的方法有很多。最常见的有Object类的wait和notify系列。Thread里的sleep和Join等。同时在J.U.C里，提供了很多方式来实现线程通信，比如闭锁(CountDownLatch)，栅栏(CyclicBarrier)，条件类(Condition)等。同时，线程还提供了中断机制等，我们自己也可以控制一个线程的执行。需要说明的是因为消息安全(比如丢失消息)问题导致的死锁等，JDK已经废弃了Thread的stop等方法。</p>\n<h2>总结</h2>\n\n<p>本文从大逻辑点到了多线程带来的线程安全问题和线程之间通信的方法。很多东西如果研究下去又可以单独写一篇文章了。在后面会对一些比较重要的地方再做说明。</p>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>"},{"title":"分享一个Java IO方面的好东西","date":"2016-11-02T12:09:50.000Z","_content":"\n今天在研究NIO的时候找到一个好东西，并发大师Doug Lea关于NIO方面的PPT文档。非常清晰明了~分享出来，自己需要的时候也可以看看 ^V^\n\n<!--more-->\n\n[Scalable IO in Java](http://o9z6i1a1s.bkt.clouddn.com/nio.pdf)\n","source":"_posts/20161102-1.md","raw":"---\ntitle: '分享一个Java IO方面的好东西'\ndate: 2016-11-02 20:09:50\ntags:\n - JavaIO\n - Doug Lea\n - 分享\ncategories: 随笔\n---\n\n今天在研究NIO的时候找到一个好东西，并发大师Doug Lea关于NIO方面的PPT文档。非常清晰明了~分享出来，自己需要的时候也可以看看 ^V^\n\n<!--more-->\n\n[Scalable IO in Java](http://o9z6i1a1s.bkt.clouddn.com/nio.pdf)\n","slug":"20161102-1","published":1,"updated":"2016-11-02T12:11:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3p000r1atippbe242b","content":"<p>今天在研究NIO的时候找到一个好东西，并发大师Doug Lea关于NIO方面的PPT文档。非常清晰明了~分享出来，自己需要的时候也可以看看 ^V^</p>\n<a id=\"more\"></a>\n<p><a href=\"http://o9z6i1a1s.bkt.clouddn.com/nio.pdf\" target=\"_blank\" rel=\"external\">Scalable IO in Java</a></p>\n","excerpt":"<p>今天在研究NIO的时候找到一个好东西，并发大师Doug Lea关于NIO方面的PPT文档。非常清晰明了~分享出来，自己需要的时候也可以看看 ^V^</p>","more":"<p><a href=\"http://o9z6i1a1s.bkt.clouddn.com/nio.pdf\">Scalable IO in Java</a></p>"},{"title":"这个世界会好吗？","date":"2016-11-03T13:13:32.000Z","_content":"\n想来想去也想不出一个什么好的标题来概括我想要表达的东西。恰好音乐播放到李志的<这个世界会好吗>，就用这个标题好了。走入社会后，总是会遇到各种各样的人，还有各种各样的事儿。有些人，有些事甚至会让自己不断怀疑自己的三观是不是错了，严重的还会怀疑整个人生。因此借文字来吐槽发泄一下吧。发泄完之后依然需要笑对生活，笑对世界~纵使生活**我千百遍，我待生活如初恋~\n\n<!--more-->\n\n吃亏是福。但不意味着凡事都要选择吃亏。当我把你当成值得信赖的朋友的话，我可以一直吃亏。但是我的朋友也从没有让我一直吃亏过。但是如果仅仅是普通人，就没有必要一直选择吃亏了。小事还好，大事更加不想让自己吃亏。本分最重要，人都是自私的。总是想着占别人便宜的人最后一定占不到便宜。\n\n耿直与真诚。和耿直的人交往会觉得说话做事效率特别高。我是个性子比较急躁的人。也觉得是一个比较耿直的人。很多事情直接说比委婉的说或者遮遮掩掩的说给人的感觉更愉快。至于真诚，人与人的交往如果都缺少了真诚，自然没有什么意思了。你对我真诚，我对你也真诚~\n\n自我与换位思考。以前我是一个很自我的人，把自己当初世界的中心。走入社会后，自然会发现行不通。没有谁一定要围着谁转。也没有谁离不开谁。常常换位思考，自然能够理解别人，也自然能够被别人理解。\n\n这个世界多点真诚，少点套路，多点关怀，多点爱，多好~~~\n\n又快到了双十一了，请给我们这些单身狗多点关怀多点真诚。汪~汪~\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=30967310&auto=1&height=66\"></iframe>\n","source":"_posts/20161103-1.md","raw":"---\ntitle: '这个世界会好吗？'\ndate: 2016-11-03 21:13:32\ntags: \n - 生活\n - 随笔\ncategories: 随笔\n---\n\n想来想去也想不出一个什么好的标题来概括我想要表达的东西。恰好音乐播放到李志的<这个世界会好吗>，就用这个标题好了。走入社会后，总是会遇到各种各样的人，还有各种各样的事儿。有些人，有些事甚至会让自己不断怀疑自己的三观是不是错了，严重的还会怀疑整个人生。因此借文字来吐槽发泄一下吧。发泄完之后依然需要笑对生活，笑对世界~纵使生活**我千百遍，我待生活如初恋~\n\n<!--more-->\n\n吃亏是福。但不意味着凡事都要选择吃亏。当我把你当成值得信赖的朋友的话，我可以一直吃亏。但是我的朋友也从没有让我一直吃亏过。但是如果仅仅是普通人，就没有必要一直选择吃亏了。小事还好，大事更加不想让自己吃亏。本分最重要，人都是自私的。总是想着占别人便宜的人最后一定占不到便宜。\n\n耿直与真诚。和耿直的人交往会觉得说话做事效率特别高。我是个性子比较急躁的人。也觉得是一个比较耿直的人。很多事情直接说比委婉的说或者遮遮掩掩的说给人的感觉更愉快。至于真诚，人与人的交往如果都缺少了真诚，自然没有什么意思了。你对我真诚，我对你也真诚~\n\n自我与换位思考。以前我是一个很自我的人，把自己当初世界的中心。走入社会后，自然会发现行不通。没有谁一定要围着谁转。也没有谁离不开谁。常常换位思考，自然能够理解别人，也自然能够被别人理解。\n\n这个世界多点真诚，少点套路，多点关怀，多点爱，多好~~~\n\n又快到了双十一了，请给我们这些单身狗多点关怀多点真诚。汪~汪~\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=30967310&auto=1&height=66\"></iframe>\n","slug":"20161103-1","published":1,"updated":"2016-11-04T00:26:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3s000w1atil1knhyoj","content":"<p>想来想去也想不出一个什么好的标题来概括我想要表达的东西。恰好音乐播放到李志的&lt;这个世界会好吗&gt;，就用这个标题好了。走入社会后，总是会遇到各种各样的人，还有各种各样的事儿。有些人，有些事甚至会让自己不断怀疑自己的三观是不是错了，严重的还会怀疑整个人生。因此借文字来吐槽发泄一下吧。发泄完之后依然需要笑对生活，笑对世界~纵使生活**我千百遍，我待生活如初恋~</p>\n<a id=\"more\"></a>\n<p>吃亏是福。但不意味着凡事都要选择吃亏。当我把你当成值得信赖的朋友的话，我可以一直吃亏。但是我的朋友也从没有让我一直吃亏过。但是如果仅仅是普通人，就没有必要一直选择吃亏了。小事还好，大事更加不想让自己吃亏。本分最重要，人都是自私的。总是想着占别人便宜的人最后一定占不到便宜。</p>\n<p>耿直与真诚。和耿直的人交往会觉得说话做事效率特别高。我是个性子比较急躁的人。也觉得是一个比较耿直的人。很多事情直接说比委婉的说或者遮遮掩掩的说给人的感觉更愉快。至于真诚，人与人的交往如果都缺少了真诚，自然没有什么意思了。你对我真诚，我对你也真诚~</p>\n<p>自我与换位思考。以前我是一个很自我的人，把自己当初世界的中心。走入社会后，自然会发现行不通。没有谁一定要围着谁转。也没有谁离不开谁。常常换位思考，自然能够理解别人，也自然能够被别人理解。</p>\n<p>这个世界多点真诚，少点套路，多点关怀，多点爱，多好~~~</p>\n<p>又快到了双十一了，请给我们这些单身狗多点关怀多点真诚。汪~汪~</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"http://music.163.com/outchain/player?type=2&id=30967310&auto=1&height=66\"></iframe>\n","excerpt":"<p>想来想去也想不出一个什么好的标题来概括我想要表达的东西。恰好音乐播放到李志的&lt;这个世界会好吗&gt;，就用这个标题好了。走入社会后，总是会遇到各种各样的人，还有各种各样的事儿。有些人，有些事甚至会让自己不断怀疑自己的三观是不是错了，严重的还会怀疑整个人生。因此借文字来吐槽发泄一下吧。发泄完之后依然需要笑对生活，笑对世界~纵使生活**我千百遍，我待生活如初恋~</p>","more":"<p>吃亏是福。但不意味着凡事都要选择吃亏。当我把你当成值得信赖的朋友的话，我可以一直吃亏。但是我的朋友也从没有让我一直吃亏过。但是如果仅仅是普通人，就没有必要一直选择吃亏了。小事还好，大事更加不想让自己吃亏。本分最重要，人都是自私的。总是想着占别人便宜的人最后一定占不到便宜。</p>\n<p>耿直与真诚。和耿直的人交往会觉得说话做事效率特别高。我是个性子比较急躁的人。也觉得是一个比较耿直的人。很多事情直接说比委婉的说或者遮遮掩掩的说给人的感觉更愉快。至于真诚，人与人的交往如果都缺少了真诚，自然没有什么意思了。你对我真诚，我对你也真诚~</p>\n<p>自我与换位思考。以前我是一个很自我的人，把自己当初世界的中心。走入社会后，自然会发现行不通。没有谁一定要围着谁转。也没有谁离不开谁。常常换位思考，自然能够理解别人，也自然能够被别人理解。</p>\n<p>这个世界多点真诚，少点套路，多点关怀，多点爱，多好~~~</p>\n<p>又快到了双十一了，请给我们这些单身狗多点关怀多点真诚。汪~汪~</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=30967310&auto=1&height=66\"></iframe>"},{"title":"理解Java内存模型(JMM)","date":"2016-10-29T07:43:57.000Z","_content":"当对并发编程的学习从初级阶段进入到高级阶段的过程中，对Java内存模型(JMM)的理解我认为是一个重要的分水岭。只有真正理解了JMM，才可能对并发中的线程、同步、线程通信以及后续并发编程高级技巧以及性能优化等问题有所理解。本文将总结我对JMM的一些理解。当然如果需要真正深入理解透彻JMM，还是需要读一读参考文献中的链接。\n \n <!--more-->\n \n <h2>1 什么是Java内存模型</h2>\n \n Java内存模型(JMM)不是Java语言所特有的。事实上像C#,Go等也有所谓的内存模型。这几门语言的内存模型总的来说要目标是一致的，但是可能语言之间的一些细节是有所差别的。**Java内存模型要解决的一个问题是多线程中线程私有内存和主内存之间的数据一致性以及数据通信问题,这里需要重点说明的是这里主内存不是堆内存，这里的主内存是个抽象概念，并不对应JVM或者操作系统某块内存。**事实上，不仅仅是JVM存在这个问题，在多处理器多寄存器架构中，也一定存在这个问题。考虑这样一种场景：多CPU，多寄存器通过总线共享主内存。如果在多线程环境下，CPU1中线程甲对数据A进行了修改操作，这时候CPU2中线程乙需要读取数据A。数据A分别在CPU1和CPU2的寄存器中存在副本。如果没有一种机制来保证数据通信，就一定会有数据一致性问题。JVM中，线程的一些数据是存在线程栈帧中的，多线程环境下，如何保证某些需要共享的数据的一致性和通信问题就需要一种机制来保证。因此才有了Java内存模型，对Java内存模型的定义以及一些规范是在JSR-133。\n \n <h2>2 Java内存模型中几个重要概念</h2>\n \n Java内存模型中比较重要的也就是下面的三个概念了。这几个概念的最直观体现就是对synchonized,volatile,final,static等一些关键字的合理使用所带来的效果了。\n \n <h3>重排序</h3>\n \n 关于重排序在上一篇文章中也有所提到。重排序有三个层次，分别是编译器的重排序，操作系统的重排序以及CPU指令级别的重排序。之所以会有重排序，是因为我们的编译器，操作系统，CPU已经很智能化了，它能够在不影响语义的情况下对某些指令进行优化以及调整顺序，以此来达到性能优化，减少一些不必要的指令执行的目的。但是在多线程环境下，重排序会导致数据一致性问题。因此才需要一些必要的保证手段来防止这三个层次的重排序。比如synchonized，volatile等。\n \n <h3>内存屏障</h3>\n \n 内存屏障这个概念事实上以及是指令级别了。它规定了某些操作的先后顺序以及可见性问题。比如多处理环境下，对某些指令的执行必须要先于其他指令，可能就需要一个loadload指令等等。内存屏障的种类也有很多，比如loadload，loadstore，storestore等。不同的屏障功能不一样，适用场景也不一样。这一点对上层程序员是透明的。因此我觉得了解即可。\n \n <h3>Happen-Before</h3>\n \n Happen-Before是JMM所定义的一些规则。这些规则保证了一些操作的顺序问题。这些顺序是有JVM来保证，并且保证不会被编译器或CPU等重排序所打破。Happen-Before也是定义的一个顺序问题。但是和内存屏障相比，它不再是指令级别，而是一个概念级别。或者一个原则问题。因此，有的书上也直接把这个叫做Happen-Before原则。具体的Happen-Before原则有这儿几条：\n \n   - 程序顺序规则：一个线程中的每个操作，happen-before与该线程的后续操作\n   - 监视器锁规则：对一个监视器锁的解锁，happen-before于随后对这个监视器锁的加锁\n   - volatile变量规则:对一个volatile域的写，happen-before于任意后续对这个volatile域的读\n   - 传递性：如果A happen-before B，B happen-before C，那么A happen-before C\n   - Thread.start()的调用happen-before于启动线程里面的动作\n   - Thread中的所有动作都happen-before于其他线程从Thread.join中成功返回\n \n <h2>3 Java内存模型对并发编程的意义</h2>\n \n JSR-133还定义了final，static等关键字的一些详细含义。因此如果要理解JMM，势必是要读一读JSR-133的。理解JMM，对于并发编程的最大意义我认为是在于对synchonized，volatile，fianl,static等关键字的合理运用，编写性能更好的并发程序来。\n \n <h3>参考文献</h3>\n \n 1. [JSR-133](https://jcp.org/en/jsr/detail?id=133)\n 2. [Java Memory Model](http://www.cs.umd.edu/%7Epugh/java/memoryModel/)\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n","source":"_posts/20161029-1.md","raw":"---\ntitle: '理解Java内存模型(JMM)'\ndate: 2016-10-29 15:43:57\ntags: \n - JMM\n - 并发编程\n - Java内存模型\ncategories: 深入理解\n---\n当对并发编程的学习从初级阶段进入到高级阶段的过程中，对Java内存模型(JMM)的理解我认为是一个重要的分水岭。只有真正理解了JMM，才可能对并发中的线程、同步、线程通信以及后续并发编程高级技巧以及性能优化等问题有所理解。本文将总结我对JMM的一些理解。当然如果需要真正深入理解透彻JMM，还是需要读一读参考文献中的链接。\n \n <!--more-->\n \n <h2>1 什么是Java内存模型</h2>\n \n Java内存模型(JMM)不是Java语言所特有的。事实上像C#,Go等也有所谓的内存模型。这几门语言的内存模型总的来说要目标是一致的，但是可能语言之间的一些细节是有所差别的。**Java内存模型要解决的一个问题是多线程中线程私有内存和主内存之间的数据一致性以及数据通信问题,这里需要重点说明的是这里主内存不是堆内存，这里的主内存是个抽象概念，并不对应JVM或者操作系统某块内存。**事实上，不仅仅是JVM存在这个问题，在多处理器多寄存器架构中，也一定存在这个问题。考虑这样一种场景：多CPU，多寄存器通过总线共享主内存。如果在多线程环境下，CPU1中线程甲对数据A进行了修改操作，这时候CPU2中线程乙需要读取数据A。数据A分别在CPU1和CPU2的寄存器中存在副本。如果没有一种机制来保证数据通信，就一定会有数据一致性问题。JVM中，线程的一些数据是存在线程栈帧中的，多线程环境下，如何保证某些需要共享的数据的一致性和通信问题就需要一种机制来保证。因此才有了Java内存模型，对Java内存模型的定义以及一些规范是在JSR-133。\n \n <h2>2 Java内存模型中几个重要概念</h2>\n \n Java内存模型中比较重要的也就是下面的三个概念了。这几个概念的最直观体现就是对synchonized,volatile,final,static等一些关键字的合理使用所带来的效果了。\n \n <h3>重排序</h3>\n \n 关于重排序在上一篇文章中也有所提到。重排序有三个层次，分别是编译器的重排序，操作系统的重排序以及CPU指令级别的重排序。之所以会有重排序，是因为我们的编译器，操作系统，CPU已经很智能化了，它能够在不影响语义的情况下对某些指令进行优化以及调整顺序，以此来达到性能优化，减少一些不必要的指令执行的目的。但是在多线程环境下，重排序会导致数据一致性问题。因此才需要一些必要的保证手段来防止这三个层次的重排序。比如synchonized，volatile等。\n \n <h3>内存屏障</h3>\n \n 内存屏障这个概念事实上以及是指令级别了。它规定了某些操作的先后顺序以及可见性问题。比如多处理环境下，对某些指令的执行必须要先于其他指令，可能就需要一个loadload指令等等。内存屏障的种类也有很多，比如loadload，loadstore，storestore等。不同的屏障功能不一样，适用场景也不一样。这一点对上层程序员是透明的。因此我觉得了解即可。\n \n <h3>Happen-Before</h3>\n \n Happen-Before是JMM所定义的一些规则。这些规则保证了一些操作的顺序问题。这些顺序是有JVM来保证，并且保证不会被编译器或CPU等重排序所打破。Happen-Before也是定义的一个顺序问题。但是和内存屏障相比，它不再是指令级别，而是一个概念级别。或者一个原则问题。因此，有的书上也直接把这个叫做Happen-Before原则。具体的Happen-Before原则有这儿几条：\n \n   - 程序顺序规则：一个线程中的每个操作，happen-before与该线程的后续操作\n   - 监视器锁规则：对一个监视器锁的解锁，happen-before于随后对这个监视器锁的加锁\n   - volatile变量规则:对一个volatile域的写，happen-before于任意后续对这个volatile域的读\n   - 传递性：如果A happen-before B，B happen-before C，那么A happen-before C\n   - Thread.start()的调用happen-before于启动线程里面的动作\n   - Thread中的所有动作都happen-before于其他线程从Thread.join中成功返回\n \n <h2>3 Java内存模型对并发编程的意义</h2>\n \n JSR-133还定义了final，static等关键字的一些详细含义。因此如果要理解JMM，势必是要读一读JSR-133的。理解JMM，对于并发编程的最大意义我认为是在于对synchonized，volatile，fianl,static等关键字的合理运用，编写性能更好的并发程序来。\n \n <h3>参考文献</h3>\n \n 1. [JSR-133](https://jcp.org/en/jsr/detail?id=133)\n 2. [Java Memory Model](http://www.cs.umd.edu/%7Epugh/java/memoryModel/)\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n","slug":"20161029-1","published":1,"updated":"2016-10-29T07:45:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3x000z1atiollrucjb","content":"<p>当对并发编程的学习从初级阶段进入到高级阶段的过程中，对Java内存模型(JMM)的理解我认为是一个重要的分水岭。只有真正理解了JMM，才可能对并发中的线程、同步、线程通信以及后续并发编程高级技巧以及性能优化等问题有所理解。本文将总结我对JMM的一些理解。当然如果需要真正深入理解透彻JMM，还是需要读一读参考文献中的链接。</p>\n <a id=\"more\"></a>\n <h2>1 什么是Java内存模型</h2>\n\n<p> Java内存模型(JMM)不是Java语言所特有的。事实上像C#,Go等也有所谓的内存模型。这几门语言的内存模型总的来说要目标是一致的，但是可能语言之间的一些细节是有所差别的。<strong>Java内存模型要解决的一个问题是多线程中线程私有内存和主内存之间的数据一致性以及数据通信问题,这里需要重点说明的是这里主内存不是堆内存，这里的主内存是个抽象概念，并不对应JVM或者操作系统某块内存。</strong>事实上，不仅仅是JVM存在这个问题，在多处理器多寄存器架构中，也一定存在这个问题。考虑这样一种场景：多CPU，多寄存器通过总线共享主内存。如果在多线程环境下，CPU1中线程甲对数据A进行了修改操作，这时候CPU2中线程乙需要读取数据A。数据A分别在CPU1和CPU2的寄存器中存在副本。如果没有一种机制来保证数据通信，就一定会有数据一致性问题。JVM中，线程的一些数据是存在线程栈帧中的，多线程环境下，如何保证某些需要共享的数据的一致性和通信问题就需要一种机制来保证。因此才有了Java内存模型，对Java内存模型的定义以及一些规范是在JSR-133。</p>\n <h2>2 Java内存模型中几个重要概念</h2>\n\n<p> Java内存模型中比较重要的也就是下面的三个概念了。这几个概念的最直观体现就是对synchonized,volatile,final,static等一些关键字的合理使用所带来的效果了。</p>\n <h3>重排序</h3>\n\n<p> 关于重排序在上一篇文章中也有所提到。重排序有三个层次，分别是编译器的重排序，操作系统的重排序以及CPU指令级别的重排序。之所以会有重排序，是因为我们的编译器，操作系统，CPU已经很智能化了，它能够在不影响语义的情况下对某些指令进行优化以及调整顺序，以此来达到性能优化，减少一些不必要的指令执行的目的。但是在多线程环境下，重排序会导致数据一致性问题。因此才需要一些必要的保证手段来防止这三个层次的重排序。比如synchonized，volatile等。</p>\n <h3>内存屏障</h3>\n\n<p> 内存屏障这个概念事实上以及是指令级别了。它规定了某些操作的先后顺序以及可见性问题。比如多处理环境下，对某些指令的执行必须要先于其他指令，可能就需要一个loadload指令等等。内存屏障的种类也有很多，比如loadload，loadstore，storestore等。不同的屏障功能不一样，适用场景也不一样。这一点对上层程序员是透明的。因此我觉得了解即可。</p>\n <h3>Happen-Before</h3>\n\n<p> Happen-Before是JMM所定义的一些规则。这些规则保证了一些操作的顺序问题。这些顺序是有JVM来保证，并且保证不会被编译器或CPU等重排序所打破。Happen-Before也是定义的一个顺序问题。但是和内存屏障相比，它不再是指令级别，而是一个概念级别。或者一个原则问题。因此，有的书上也直接把这个叫做Happen-Before原则。具体的Happen-Before原则有这儿几条：</p>\n<ul>\n<li>程序顺序规则：一个线程中的每个操作，happen-before与该线程的后续操作</li>\n<li>监视器锁规则：对一个监视器锁的解锁，happen-before于随后对这个监视器锁的加锁</li>\n<li>volatile变量规则:对一个volatile域的写，happen-before于任意后续对这个volatile域的读</li>\n<li>传递性：如果A happen-before B，B happen-before C，那么A happen-before C</li>\n<li>Thread.start()的调用happen-before于启动线程里面的动作</li>\n<li><p>Thread中的所有动作都happen-before于其他线程从Thread.join中成功返回</p>\n<h2>3 Java内存模型对并发编程的意义</h2>\n\n<p>JSR-133还定义了final，static等关键字的一些详细含义。因此如果要理解JMM，势必是要读一读JSR-133的。理解JMM，对于并发编程的最大意义我认为是在于对synchonized，volatile，fianl,static等关键字的合理运用，编写性能更好的并发程序来。</p>\n<h3>参考文献</h3>\n\n<ol>\n<li><a href=\"https://jcp.org/en/jsr/detail?id=133\" target=\"_blank\" rel=\"external\">JSR-133</a></li>\n<li><a href=\"http://www.cs.umd.edu/%7Epugh/java/memoryModel/\" target=\"_blank\" rel=\"external\">Java Memory Model</a></li>\n</ol>\n</li>\n</ul>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>\n","excerpt":"<p>当对并发编程的学习从初级阶段进入到高级阶段的过程中，对Java内存模型(JMM)的理解我认为是一个重要的分水岭。只有真正理解了JMM，才可能对并发中的线程、同步、线程通信以及后续并发编程高级技巧以及性能优化等问题有所理解。本文将总结我对JMM的一些理解。当然如果需要真正深入理解透彻JMM，还是需要读一读参考文献中的链接。</p>","more":"<h2>1 什么是Java内存模型</h2>\n\n<p> Java内存模型(JMM)不是Java语言所特有的。事实上像C#,Go等也有所谓的内存模型。这几门语言的内存模型总的来说要目标是一致的，但是可能语言之间的一些细节是有所差别的。<strong>Java内存模型要解决的一个问题是多线程中线程私有内存和主内存之间的数据一致性以及数据通信问题,这里需要重点说明的是这里主内存不是堆内存，这里的主内存是个抽象概念，并不对应JVM或者操作系统某块内存。</strong>事实上，不仅仅是JVM存在这个问题，在多处理器多寄存器架构中，也一定存在这个问题。考虑这样一种场景：多CPU，多寄存器通过总线共享主内存。如果在多线程环境下，CPU1中线程甲对数据A进行了修改操作，这时候CPU2中线程乙需要读取数据A。数据A分别在CPU1和CPU2的寄存器中存在副本。如果没有一种机制来保证数据通信，就一定会有数据一致性问题。JVM中，线程的一些数据是存在线程栈帧中的，多线程环境下，如何保证某些需要共享的数据的一致性和通信问题就需要一种机制来保证。因此才有了Java内存模型，对Java内存模型的定义以及一些规范是在JSR-133。</p>\n <h2>2 Java内存模型中几个重要概念</h2>\n\n<p> Java内存模型中比较重要的也就是下面的三个概念了。这几个概念的最直观体现就是对synchonized,volatile,final,static等一些关键字的合理使用所带来的效果了。</p>\n <h3>重排序</h3>\n\n<p> 关于重排序在上一篇文章中也有所提到。重排序有三个层次，分别是编译器的重排序，操作系统的重排序以及CPU指令级别的重排序。之所以会有重排序，是因为我们的编译器，操作系统，CPU已经很智能化了，它能够在不影响语义的情况下对某些指令进行优化以及调整顺序，以此来达到性能优化，减少一些不必要的指令执行的目的。但是在多线程环境下，重排序会导致数据一致性问题。因此才需要一些必要的保证手段来防止这三个层次的重排序。比如synchonized，volatile等。</p>\n <h3>内存屏障</h3>\n\n<p> 内存屏障这个概念事实上以及是指令级别了。它规定了某些操作的先后顺序以及可见性问题。比如多处理环境下，对某些指令的执行必须要先于其他指令，可能就需要一个loadload指令等等。内存屏障的种类也有很多，比如loadload，loadstore，storestore等。不同的屏障功能不一样，适用场景也不一样。这一点对上层程序员是透明的。因此我觉得了解即可。</p>\n <h3>Happen-Before</h3>\n\n<p> Happen-Before是JMM所定义的一些规则。这些规则保证了一些操作的顺序问题。这些顺序是有JVM来保证，并且保证不会被编译器或CPU等重排序所打破。Happen-Before也是定义的一个顺序问题。但是和内存屏障相比，它不再是指令级别，而是一个概念级别。或者一个原则问题。因此，有的书上也直接把这个叫做Happen-Before原则。具体的Happen-Before原则有这儿几条：</p>\n<ul>\n<li>程序顺序规则：一个线程中的每个操作，happen-before与该线程的后续操作</li>\n<li>监视器锁规则：对一个监视器锁的解锁，happen-before于随后对这个监视器锁的加锁</li>\n<li>volatile变量规则:对一个volatile域的写，happen-before于任意后续对这个volatile域的读</li>\n<li>传递性：如果A happen-before B，B happen-before C，那么A happen-before C</li>\n<li>Thread.start()的调用happen-before于启动线程里面的动作</li>\n<li><p>Thread中的所有动作都happen-before于其他线程从Thread.join中成功返回</p>\n<h2>3 Java内存模型对并发编程的意义</h2>\n\n<p>JSR-133还定义了final，static等关键字的一些详细含义。因此如果要理解JMM，势必是要读一读JSR-133的。理解JMM，对于并发编程的最大意义我认为是在于对synchonized，volatile，fianl,static等关键字的合理运用，编写性能更好的并发程序来。</p>\n<h3>参考文献</h3>\n\n<ol>\n<li><a href=\"https://jcp.org/en/jsr/detail?id=133\">JSR-133</a></li>\n<li><a href=\"http://www.cs.umd.edu/%7Epugh/java/memoryModel/\">Java Memory Model</a></li>\n</ol>\n</li>\n</ul>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>"},{"title":"软件开发日常思考(二)","date":"2016-11-08T14:07:00.000Z","_content":"继续[上一篇](http://wantedonline.cn/2016/08/20/20160820-1/)的话题。上一篇谈到了单元测试和团队代码规范问题.事实上到目前为止，我还没有碰到过一个团队对单元测试有过高的要求。我碰到的大部分团队可以说是对单元测试没有要求。这也和目前大部分开发团队碰到的现实情况是相符合的，开发的时间以及团队对代码的质量没有太多的要求。功能为王，实现功能就好，至于可维护性，可读性，可拓展性等等这些问题从来不考虑。这一篇我想谈一谈我对程序员代码质量的思考。\n\n<!--more-->\n\n很感恩和很幸运，我毕业后第一家公司是华为。为什么这么说呢？在大学的时候，我接触的项目和学到的东西，基本都是书上的。读了很多关于代码质量，代码风格以及软件工程理论性的东西。而真正巩固和实践是从工作开始的。入职华为前以及入职后新员工时期，大部分是培训。这里我从华为学到的两个重要的东西就是下面这两点。\n\n<h2>以客户为中心</h2>\n\n所有新员工入职华为大队培训一定有一堂非常重要的课就是讲华为的企业文化--以客户为中心，以奋斗者为本。\n\n作为一个研发人员，我们不可能接触到一线客户。当时我所在的大部门(2012实验室)是一个SBG(Service Business Group)，我们服务的对象是产品线的兄弟。我学到的第一个理念是我们的客户是我们的上一道工序。\n\n严格来说，无论在什么时候，对待任何人以及对待任何事，如果能够真正以客户为中心，也就是以服务好上一道工序为起点，那么很多事情都会有一个比较好的结果。\n\n这个和我想讲的软件开发有什么关系呢？\n\n软件开发是一个团队合作的活动。如果团队比较小，可能一个人就负责一个模块甚至一个项目。如果团队比较大，我们很多时候需要写一些公共接口给其他人用。这时候就有一个沟通和合作的问题。\n\n过去我的经验是，谁写的接口谁负责维护。因此，如果只为了省事图个简单，没有任何接口doc说明也没有约定一个编码规范，很有可能就要出问题。比如说接口返回数据问题。如果返回了错误数据或者空指针等就是接口编写者的问题。而不应该要求使用者去做参数校验来避免踩坑。这一点我认为就是一个客户为中心的问题。\n\n当然，在这一点上，过去的两年多，我一直在努力。我也看到了自己从一个经常犯错误的新手慢慢成长为一个比较少的犯错误的老油条。在这条路上，我还有很多事情可以做。\n\n<h2>代码质量--程序员的尊严</h2>\n\n软件开发是一个非常复杂的团队合作活动。在这项活动里，我比较认同两个东西。\n\n短板理论\n\n项目成功或失败不是一个或两个比较牛掰的人能决定得了的。取决于团队的整体水平以及团队中的短板。如果一个团队有比较好的编码规范以及90%的人都有较强的软件工程思想和编码水平，那么剩下的10%的短板也会跟着团队逐渐成长，最终整个团队的作战能力都能提升上去。开发出来的代码质量一定不会太低。\n\n破窗理论\n\n如果项目从一开始就向坏的方向发展，比如代码混乱，隐藏了很多潜在的安全问题。最后发展到最后一定会越来越坏，最终可能在某个重要的时间点爆发，然后彻底蹦了。因此，从项目一开始就保持一种比较严格的要求我觉得是一个比较好的做法。\n\n这两个东西和主题代码质量的关系。\n\n很多的时候，如果我们不注重这两点，任有项目代码做布朗运动，可能最终导致的结果是很不可控的。也许我们目前的资源以及条件，是功能为主，不要考虑网络资源，内存资源，CPU资源，安全问题等。但是最终当出现问题的时候已经不可控了，只能推到重来了。这就是一个失败的项目。\n\n因此，作为程序员，珍惜每一点内存，即便是一个Java程序员，即便我们有非常足够的内存可使用；珍视每一点性能提升，时间复杂度的下降，空间复杂度的下降；保持一套可读性，可维护性高的代码风格和命名规范是极其重要的。\n\n我们的代码写完之后很有可能是其他人维护，这时候别人的体验就是代码质量的体现，就是程序员尊严的体现，\n\n<h2>总结</h2>\n\n软件开发是一项复杂的活动。是一项团队合作，团队整体作战能力要求非常高的活动。因此，有时候项目的成败从团队水平就决定了。有时候可能一年两年看不出来问题，但当真正出现问题的时候已经无力回天了。而最初那批创造原始代码的人可能已经不在这里了。\n\n","source":"_posts/20161108.md","raw":"---\ntitle: 软件开发日常思考(二)\ndate: 2016-11-08 22:07:00\ntags: \n - 软件开发\n - IT生涯\n - 随笔\ncategories: 软件开发日常\n---\n继续[上一篇](http://wantedonline.cn/2016/08/20/20160820-1/)的话题。上一篇谈到了单元测试和团队代码规范问题.事实上到目前为止，我还没有碰到过一个团队对单元测试有过高的要求。我碰到的大部分团队可以说是对单元测试没有要求。这也和目前大部分开发团队碰到的现实情况是相符合的，开发的时间以及团队对代码的质量没有太多的要求。功能为王，实现功能就好，至于可维护性，可读性，可拓展性等等这些问题从来不考虑。这一篇我想谈一谈我对程序员代码质量的思考。\n\n<!--more-->\n\n很感恩和很幸运，我毕业后第一家公司是华为。为什么这么说呢？在大学的时候，我接触的项目和学到的东西，基本都是书上的。读了很多关于代码质量，代码风格以及软件工程理论性的东西。而真正巩固和实践是从工作开始的。入职华为前以及入职后新员工时期，大部分是培训。这里我从华为学到的两个重要的东西就是下面这两点。\n\n<h2>以客户为中心</h2>\n\n所有新员工入职华为大队培训一定有一堂非常重要的课就是讲华为的企业文化--以客户为中心，以奋斗者为本。\n\n作为一个研发人员，我们不可能接触到一线客户。当时我所在的大部门(2012实验室)是一个SBG(Service Business Group)，我们服务的对象是产品线的兄弟。我学到的第一个理念是我们的客户是我们的上一道工序。\n\n严格来说，无论在什么时候，对待任何人以及对待任何事，如果能够真正以客户为中心，也就是以服务好上一道工序为起点，那么很多事情都会有一个比较好的结果。\n\n这个和我想讲的软件开发有什么关系呢？\n\n软件开发是一个团队合作的活动。如果团队比较小，可能一个人就负责一个模块甚至一个项目。如果团队比较大，我们很多时候需要写一些公共接口给其他人用。这时候就有一个沟通和合作的问题。\n\n过去我的经验是，谁写的接口谁负责维护。因此，如果只为了省事图个简单，没有任何接口doc说明也没有约定一个编码规范，很有可能就要出问题。比如说接口返回数据问题。如果返回了错误数据或者空指针等就是接口编写者的问题。而不应该要求使用者去做参数校验来避免踩坑。这一点我认为就是一个客户为中心的问题。\n\n当然，在这一点上，过去的两年多，我一直在努力。我也看到了自己从一个经常犯错误的新手慢慢成长为一个比较少的犯错误的老油条。在这条路上，我还有很多事情可以做。\n\n<h2>代码质量--程序员的尊严</h2>\n\n软件开发是一个非常复杂的团队合作活动。在这项活动里，我比较认同两个东西。\n\n短板理论\n\n项目成功或失败不是一个或两个比较牛掰的人能决定得了的。取决于团队的整体水平以及团队中的短板。如果一个团队有比较好的编码规范以及90%的人都有较强的软件工程思想和编码水平，那么剩下的10%的短板也会跟着团队逐渐成长，最终整个团队的作战能力都能提升上去。开发出来的代码质量一定不会太低。\n\n破窗理论\n\n如果项目从一开始就向坏的方向发展，比如代码混乱，隐藏了很多潜在的安全问题。最后发展到最后一定会越来越坏，最终可能在某个重要的时间点爆发，然后彻底蹦了。因此，从项目一开始就保持一种比较严格的要求我觉得是一个比较好的做法。\n\n这两个东西和主题代码质量的关系。\n\n很多的时候，如果我们不注重这两点，任有项目代码做布朗运动，可能最终导致的结果是很不可控的。也许我们目前的资源以及条件，是功能为主，不要考虑网络资源，内存资源，CPU资源，安全问题等。但是最终当出现问题的时候已经不可控了，只能推到重来了。这就是一个失败的项目。\n\n因此，作为程序员，珍惜每一点内存，即便是一个Java程序员，即便我们有非常足够的内存可使用；珍视每一点性能提升，时间复杂度的下降，空间复杂度的下降；保持一套可读性，可维护性高的代码风格和命名规范是极其重要的。\n\n我们的代码写完之后很有可能是其他人维护，这时候别人的体验就是代码质量的体现，就是程序员尊严的体现，\n\n<h2>总结</h2>\n\n软件开发是一项复杂的活动。是一项团队合作，团队整体作战能力要求非常高的活动。因此，有时候项目的成败从团队水平就决定了。有时候可能一年两年看不出来问题，但当真正出现问题的时候已经无力回天了。而最初那批创造原始代码的人可能已经不在这里了。\n\n","slug":"20161108","published":1,"updated":"2016-11-08T14:09:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf3z00121ati7zn8qnxi","content":"<p>继续<a href=\"http://wantedonline.cn/2016/08/20/20160820-1/\">上一篇</a>的话题。上一篇谈到了单元测试和团队代码规范问题.事实上到目前为止，我还没有碰到过一个团队对单元测试有过高的要求。我碰到的大部分团队可以说是对单元测试没有要求。这也和目前大部分开发团队碰到的现实情况是相符合的，开发的时间以及团队对代码的质量没有太多的要求。功能为王，实现功能就好，至于可维护性，可读性，可拓展性等等这些问题从来不考虑。这一篇我想谈一谈我对程序员代码质量的思考。</p>\n<a id=\"more\"></a>\n<p>很感恩和很幸运，我毕业后第一家公司是华为。为什么这么说呢？在大学的时候，我接触的项目和学到的东西，基本都是书上的。读了很多关于代码质量，代码风格以及软件工程理论性的东西。而真正巩固和实践是从工作开始的。入职华为前以及入职后新员工时期，大部分是培训。这里我从华为学到的两个重要的东西就是下面这两点。</p>\n<h2>以客户为中心</h2>\n\n<p>所有新员工入职华为大队培训一定有一堂非常重要的课就是讲华为的企业文化–以客户为中心，以奋斗者为本。</p>\n<p>作为一个研发人员，我们不可能接触到一线客户。当时我所在的大部门(2012实验室)是一个SBG(Service Business Group)，我们服务的对象是产品线的兄弟。我学到的第一个理念是我们的客户是我们的上一道工序。</p>\n<p>严格来说，无论在什么时候，对待任何人以及对待任何事，如果能够真正以客户为中心，也就是以服务好上一道工序为起点，那么很多事情都会有一个比较好的结果。</p>\n<p>这个和我想讲的软件开发有什么关系呢？</p>\n<p>软件开发是一个团队合作的活动。如果团队比较小，可能一个人就负责一个模块甚至一个项目。如果团队比较大，我们很多时候需要写一些公共接口给其他人用。这时候就有一个沟通和合作的问题。</p>\n<p>过去我的经验是，谁写的接口谁负责维护。因此，如果只为了省事图个简单，没有任何接口doc说明也没有约定一个编码规范，很有可能就要出问题。比如说接口返回数据问题。如果返回了错误数据或者空指针等就是接口编写者的问题。而不应该要求使用者去做参数校验来避免踩坑。这一点我认为就是一个客户为中心的问题。</p>\n<p>当然，在这一点上，过去的两年多，我一直在努力。我也看到了自己从一个经常犯错误的新手慢慢成长为一个比较少的犯错误的老油条。在这条路上，我还有很多事情可以做。</p>\n<h2>代码质量–程序员的尊严</h2>\n\n<p>软件开发是一个非常复杂的团队合作活动。在这项活动里，我比较认同两个东西。</p>\n<p>短板理论</p>\n<p>项目成功或失败不是一个或两个比较牛掰的人能决定得了的。取决于团队的整体水平以及团队中的短板。如果一个团队有比较好的编码规范以及90%的人都有较强的软件工程思想和编码水平，那么剩下的10%的短板也会跟着团队逐渐成长，最终整个团队的作战能力都能提升上去。开发出来的代码质量一定不会太低。</p>\n<p>破窗理论</p>\n<p>如果项目从一开始就向坏的方向发展，比如代码混乱，隐藏了很多潜在的安全问题。最后发展到最后一定会越来越坏，最终可能在某个重要的时间点爆发，然后彻底蹦了。因此，从项目一开始就保持一种比较严格的要求我觉得是一个比较好的做法。</p>\n<p>这两个东西和主题代码质量的关系。</p>\n<p>很多的时候，如果我们不注重这两点，任有项目代码做布朗运动，可能最终导致的结果是很不可控的。也许我们目前的资源以及条件，是功能为主，不要考虑网络资源，内存资源，CPU资源，安全问题等。但是最终当出现问题的时候已经不可控了，只能推到重来了。这就是一个失败的项目。</p>\n<p>因此，作为程序员，珍惜每一点内存，即便是一个Java程序员，即便我们有非常足够的内存可使用；珍视每一点性能提升，时间复杂度的下降，空间复杂度的下降；保持一套可读性，可维护性高的代码风格和命名规范是极其重要的。</p>\n<p>我们的代码写完之后很有可能是其他人维护，这时候别人的体验就是代码质量的体现，就是程序员尊严的体现，</p>\n<h2>总结</h2>\n\n<p>软件开发是一项复杂的活动。是一项团队合作，团队整体作战能力要求非常高的活动。因此，有时候项目的成败从团队水平就决定了。有时候可能一年两年看不出来问题，但当真正出现问题的时候已经无力回天了。而最初那批创造原始代码的人可能已经不在这里了。</p>\n","excerpt":"<p>继续<a href=\"http://wantedonline.cn/2016/08/20/20160820-1/\">上一篇</a>的话题。上一篇谈到了单元测试和团队代码规范问题.事实上到目前为止，我还没有碰到过一个团队对单元测试有过高的要求。我碰到的大部分团队可以说是对单元测试没有要求。这也和目前大部分开发团队碰到的现实情况是相符合的，开发的时间以及团队对代码的质量没有太多的要求。功能为王，实现功能就好，至于可维护性，可读性，可拓展性等等这些问题从来不考虑。这一篇我想谈一谈我对程序员代码质量的思考。</p>","more":"<p>很感恩和很幸运，我毕业后第一家公司是华为。为什么这么说呢？在大学的时候，我接触的项目和学到的东西，基本都是书上的。读了很多关于代码质量，代码风格以及软件工程理论性的东西。而真正巩固和实践是从工作开始的。入职华为前以及入职后新员工时期，大部分是培训。这里我从华为学到的两个重要的东西就是下面这两点。</p>\n<h2>以客户为中心</h2>\n\n<p>所有新员工入职华为大队培训一定有一堂非常重要的课就是讲华为的企业文化–以客户为中心，以奋斗者为本。</p>\n<p>作为一个研发人员，我们不可能接触到一线客户。当时我所在的大部门(2012实验室)是一个SBG(Service Business Group)，我们服务的对象是产品线的兄弟。我学到的第一个理念是我们的客户是我们的上一道工序。</p>\n<p>严格来说，无论在什么时候，对待任何人以及对待任何事，如果能够真正以客户为中心，也就是以服务好上一道工序为起点，那么很多事情都会有一个比较好的结果。</p>\n<p>这个和我想讲的软件开发有什么关系呢？</p>\n<p>软件开发是一个团队合作的活动。如果团队比较小，可能一个人就负责一个模块甚至一个项目。如果团队比较大，我们很多时候需要写一些公共接口给其他人用。这时候就有一个沟通和合作的问题。</p>\n<p>过去我的经验是，谁写的接口谁负责维护。因此，如果只为了省事图个简单，没有任何接口doc说明也没有约定一个编码规范，很有可能就要出问题。比如说接口返回数据问题。如果返回了错误数据或者空指针等就是接口编写者的问题。而不应该要求使用者去做参数校验来避免踩坑。这一点我认为就是一个客户为中心的问题。</p>\n<p>当然，在这一点上，过去的两年多，我一直在努力。我也看到了自己从一个经常犯错误的新手慢慢成长为一个比较少的犯错误的老油条。在这条路上，我还有很多事情可以做。</p>\n<h2>代码质量–程序员的尊严</h2>\n\n<p>软件开发是一个非常复杂的团队合作活动。在这项活动里，我比较认同两个东西。</p>\n<p>短板理论</p>\n<p>项目成功或失败不是一个或两个比较牛掰的人能决定得了的。取决于团队的整体水平以及团队中的短板。如果一个团队有比较好的编码规范以及90%的人都有较强的软件工程思想和编码水平，那么剩下的10%的短板也会跟着团队逐渐成长，最终整个团队的作战能力都能提升上去。开发出来的代码质量一定不会太低。</p>\n<p>破窗理论</p>\n<p>如果项目从一开始就向坏的方向发展，比如代码混乱，隐藏了很多潜在的安全问题。最后发展到最后一定会越来越坏，最终可能在某个重要的时间点爆发，然后彻底蹦了。因此，从项目一开始就保持一种比较严格的要求我觉得是一个比较好的做法。</p>\n<p>这两个东西和主题代码质量的关系。</p>\n<p>很多的时候，如果我们不注重这两点，任有项目代码做布朗运动，可能最终导致的结果是很不可控的。也许我们目前的资源以及条件，是功能为主，不要考虑网络资源，内存资源，CPU资源，安全问题等。但是最终当出现问题的时候已经不可控了，只能推到重来了。这就是一个失败的项目。</p>\n<p>因此，作为程序员，珍惜每一点内存，即便是一个Java程序员，即便我们有非常足够的内存可使用；珍视每一点性能提升，时间复杂度的下降，空间复杂度的下降；保持一套可读性，可维护性高的代码风格和命名规范是极其重要的。</p>\n<p>我们的代码写完之后很有可能是其他人维护，这时候别人的体验就是代码质量的体现，就是程序员尊严的体现，</p>\n<h2>总结</h2>\n\n<p>软件开发是一项复杂的活动。是一项团队合作，团队整体作战能力要求非常高的活动。因此，有时候项目的成败从团队水平就决定了。有时候可能一年两年看不出来问题，但当真正出现问题的时候已经无力回天了。而最初那批创造原始代码的人可能已经不在这里了。</p>"},{"title":"J.U.C概述","date":"2016-11-12T09:04:22.000Z","_content":"前面几篇基本说的是并发理论性的东西。除了很简单的介绍了一下synchonized和volatile两个关键字。从本篇开始，还是继续介绍一些理论性的东西。不过这些理论上的东西不同于前面。而是实实在在的工具类。\n\nJ.U.C是java.util.concurrent.*的简写。从JDK 1.5开始，JDK开始提供了一个专门用于简化并发编程的工具包，这个工具包就是J.U.C。\n\n<!--more-->\n\n业界有一句话说'并发不知[Doug Lea](http://g.oswego.edu)，学尽Java也枉然'。事实上，J.U.C的整个设计以及中间很多类的编写都是Doug Lea。上面链接是他的主页。他还编写了一本书叫做<Java并发编程实践>.这本书对于Java程序员研究并发编程的理论与实践绝对帮助很大。\n\n<h2>Executors类</h2>\n\n这个包主要提供了一些线程池的工具类。事实上，创建线程和销毁线程都是一些消耗比较大的操作。因此J.U.C提供了这样一些类来简化线程的创建和销毁以及管理。主要有这么四中线程池：newCachedThreadPool，可缓存的线程池。它的用法是当我们希望创建的线程使用完之后不要马上销毁，可以给下一个任务去使用。因此可以将这些线程缓存起来重用。这样就节省了线程频繁创建于销毁带来的开支；newFixedThreadPool，固定大小的线程池。如果我们的任务数固定，而且可以确定线程数量使用这种线程池就比较好。不会有资源的浪费；newScheduledThreadPool，可调度的线程池。有一些任务我们希望在某个时间点或者某种频率触发，就可以使用这种线程池；newSingleThreadExecutor,单个线程的线程池。这种线程池一般用于任务数比较少，可以固定一个线程来执行。生产实践中我个人还是很少用到。\n\n跟线程池相关的自然是任务。J.U.C简化了我们创建和销毁以及管理线程的步骤，我们要做的只是将可以并行化的部分抽象出任务，写好task类即可。而task又可以带返回值和不带返回值。这些是通过Future等类实现。同时，在这个Executors框架里还提供了ForkJoin机制的实现类，用于工作窃取机制算法的实现。关于这个算法的原理，可以参考这个[文档](http://ifeve.com/fork-join-1/)。涉及到线程池，涉及到任务，自然就会牵扯到很多东西，比如任务队列，优先级，启动和中断等。这些都定义在Executors这个框架里。\n\n<h2>并发集合类</h2>\n\nJ.U.C提供了非常丰富的线程安全的集合类。比如队列，Map,List等数据结构。其中生产实践中用的最多的恐怕是ConcurrentHashMap了。这个类型的Map的详细介绍后面会有。它是一个线程安全的HashMap，但是性能比直接用HashTable或者同步化包装的HashMap高很多。原因需要看这个类的实现才能理解。根据不同的适用场景，提供了非常丰富的集合类供程序员适用。\n\n<h2>原子信号量工具类</h2>\n\n锁，信号量等在Java代码层面实现了。而且J.U.C提供的Lock类更加灵活，据说性能已经开始超过synchonized等关键字了。同时提供了一些信号量用于实现一些比如流控或者自定义锁等功能。\n\n<h2>原子基本类</h2>\n\n对于int,long，double等一些基本类，提供了一些对应的原子类的实现。这些类的线程安全保证是通过无锁化的CAS操作实现的。详细的后面的文章也会介绍。\n\n同时还有一些比如TimeUnit等工具类。\n\n<h2>总结</h2>\n\nJ.U.C给Java程序员实现并发编程带来了极大的便利，因为并发编程本来就是一项比较复杂难以测试的事情，因此虽然J.U.C已经最大程度上简化了程序员的工作，但还是需要程序员对并发编程的理论非常熟悉，经历过很多次实践才能用好并发编程带来性能效率上的提升。\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n","source":"_posts/20161112.md","raw":"---\ntitle: J.U.C概述\ndate: 2016-11-12 17:04:22\ntags:\n - 并发\n - J.U.C\ncategories: 深入理解\n---\n前面几篇基本说的是并发理论性的东西。除了很简单的介绍了一下synchonized和volatile两个关键字。从本篇开始，还是继续介绍一些理论性的东西。不过这些理论上的东西不同于前面。而是实实在在的工具类。\n\nJ.U.C是java.util.concurrent.*的简写。从JDK 1.5开始，JDK开始提供了一个专门用于简化并发编程的工具包，这个工具包就是J.U.C。\n\n<!--more-->\n\n业界有一句话说'并发不知[Doug Lea](http://g.oswego.edu)，学尽Java也枉然'。事实上，J.U.C的整个设计以及中间很多类的编写都是Doug Lea。上面链接是他的主页。他还编写了一本书叫做<Java并发编程实践>.这本书对于Java程序员研究并发编程的理论与实践绝对帮助很大。\n\n<h2>Executors类</h2>\n\n这个包主要提供了一些线程池的工具类。事实上，创建线程和销毁线程都是一些消耗比较大的操作。因此J.U.C提供了这样一些类来简化线程的创建和销毁以及管理。主要有这么四中线程池：newCachedThreadPool，可缓存的线程池。它的用法是当我们希望创建的线程使用完之后不要马上销毁，可以给下一个任务去使用。因此可以将这些线程缓存起来重用。这样就节省了线程频繁创建于销毁带来的开支；newFixedThreadPool，固定大小的线程池。如果我们的任务数固定，而且可以确定线程数量使用这种线程池就比较好。不会有资源的浪费；newScheduledThreadPool，可调度的线程池。有一些任务我们希望在某个时间点或者某种频率触发，就可以使用这种线程池；newSingleThreadExecutor,单个线程的线程池。这种线程池一般用于任务数比较少，可以固定一个线程来执行。生产实践中我个人还是很少用到。\n\n跟线程池相关的自然是任务。J.U.C简化了我们创建和销毁以及管理线程的步骤，我们要做的只是将可以并行化的部分抽象出任务，写好task类即可。而task又可以带返回值和不带返回值。这些是通过Future等类实现。同时，在这个Executors框架里还提供了ForkJoin机制的实现类，用于工作窃取机制算法的实现。关于这个算法的原理，可以参考这个[文档](http://ifeve.com/fork-join-1/)。涉及到线程池，涉及到任务，自然就会牵扯到很多东西，比如任务队列，优先级，启动和中断等。这些都定义在Executors这个框架里。\n\n<h2>并发集合类</h2>\n\nJ.U.C提供了非常丰富的线程安全的集合类。比如队列，Map,List等数据结构。其中生产实践中用的最多的恐怕是ConcurrentHashMap了。这个类型的Map的详细介绍后面会有。它是一个线程安全的HashMap，但是性能比直接用HashTable或者同步化包装的HashMap高很多。原因需要看这个类的实现才能理解。根据不同的适用场景，提供了非常丰富的集合类供程序员适用。\n\n<h2>原子信号量工具类</h2>\n\n锁，信号量等在Java代码层面实现了。而且J.U.C提供的Lock类更加灵活，据说性能已经开始超过synchonized等关键字了。同时提供了一些信号量用于实现一些比如流控或者自定义锁等功能。\n\n<h2>原子基本类</h2>\n\n对于int,long，double等一些基本类，提供了一些对应的原子类的实现。这些类的线程安全保证是通过无锁化的CAS操作实现的。详细的后面的文章也会介绍。\n\n同时还有一些比如TimeUnit等工具类。\n\n<h2>总结</h2>\n\nJ.U.C给Java程序员实现并发编程带来了极大的便利，因为并发编程本来就是一项比较复杂难以测试的事情，因此虽然J.U.C已经最大程度上简化了程序员的工作，但还是需要程序员对并发编程的理论非常熟悉，经历过很多次实践才能用好并发编程带来性能效率上的提升。\n\n[专题目录](http://wantedonline.cn/2016/09/08/20160908-1/)\n","slug":"20161112","published":1,"updated":"2016-11-12T09:14:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf4000141ati3nf4rsd0","content":"<p>前面几篇基本说的是并发理论性的东西。除了很简单的介绍了一下synchonized和volatile两个关键字。从本篇开始，还是继续介绍一些理论性的东西。不过这些理论上的东西不同于前面。而是实实在在的工具类。</p>\n<p>J.U.C是java.util.concurrent.*的简写。从JDK 1.5开始，JDK开始提供了一个专门用于简化并发编程的工具包，这个工具包就是J.U.C。</p>\n<a id=\"more\"></a>\n<p>业界有一句话说’并发不知<a href=\"http://g.oswego.edu\" target=\"_blank\" rel=\"external\">Doug Lea</a>，学尽Java也枉然’。事实上，J.U.C的整个设计以及中间很多类的编写都是Doug Lea。上面链接是他的主页。他还编写了一本书叫做<java并发编程实践>.这本书对于Java程序员研究并发编程的理论与实践绝对帮助很大。</java并发编程实践></p>\n<h2>Executors类</h2>\n\n<p>这个包主要提供了一些线程池的工具类。事实上，创建线程和销毁线程都是一些消耗比较大的操作。因此J.U.C提供了这样一些类来简化线程的创建和销毁以及管理。主要有这么四中线程池：newCachedThreadPool，可缓存的线程池。它的用法是当我们希望创建的线程使用完之后不要马上销毁，可以给下一个任务去使用。因此可以将这些线程缓存起来重用。这样就节省了线程频繁创建于销毁带来的开支；newFixedThreadPool，固定大小的线程池。如果我们的任务数固定，而且可以确定线程数量使用这种线程池就比较好。不会有资源的浪费；newScheduledThreadPool，可调度的线程池。有一些任务我们希望在某个时间点或者某种频率触发，就可以使用这种线程池；newSingleThreadExecutor,单个线程的线程池。这种线程池一般用于任务数比较少，可以固定一个线程来执行。生产实践中我个人还是很少用到。</p>\n<p>跟线程池相关的自然是任务。J.U.C简化了我们创建和销毁以及管理线程的步骤，我们要做的只是将可以并行化的部分抽象出任务，写好task类即可。而task又可以带返回值和不带返回值。这些是通过Future等类实现。同时，在这个Executors框架里还提供了ForkJoin机制的实现类，用于工作窃取机制算法的实现。关于这个算法的原理，可以参考这个<a href=\"http://ifeve.com/fork-join-1/\" target=\"_blank\" rel=\"external\">文档</a>。涉及到线程池，涉及到任务，自然就会牵扯到很多东西，比如任务队列，优先级，启动和中断等。这些都定义在Executors这个框架里。</p>\n<h2>并发集合类</h2>\n\n<p>J.U.C提供了非常丰富的线程安全的集合类。比如队列，Map,List等数据结构。其中生产实践中用的最多的恐怕是ConcurrentHashMap了。这个类型的Map的详细介绍后面会有。它是一个线程安全的HashMap，但是性能比直接用HashTable或者同步化包装的HashMap高很多。原因需要看这个类的实现才能理解。根据不同的适用场景，提供了非常丰富的集合类供程序员适用。</p>\n<h2>原子信号量工具类</h2>\n\n<p>锁，信号量等在Java代码层面实现了。而且J.U.C提供的Lock类更加灵活，据说性能已经开始超过synchonized等关键字了。同时提供了一些信号量用于实现一些比如流控或者自定义锁等功能。</p>\n<h2>原子基本类</h2>\n\n<p>对于int,long，double等一些基本类，提供了一些对应的原子类的实现。这些类的线程安全保证是通过无锁化的CAS操作实现的。详细的后面的文章也会介绍。</p>\n<p>同时还有一些比如TimeUnit等工具类。</p>\n<h2>总结</h2>\n\n<p>J.U.C给Java程序员实现并发编程带来了极大的便利，因为并发编程本来就是一项比较复杂难以测试的事情，因此虽然J.U.C已经最大程度上简化了程序员的工作，但还是需要程序员对并发编程的理论非常熟悉，经历过很多次实践才能用好并发编程带来性能效率上的提升。</p>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>\n","excerpt":"<p>前面几篇基本说的是并发理论性的东西。除了很简单的介绍了一下synchonized和volatile两个关键字。从本篇开始，还是继续介绍一些理论性的东西。不过这些理论上的东西不同于前面。而是实实在在的工具类。</p>\n<p>J.U.C是java.util.concurrent.*的简写。从JDK 1.5开始，JDK开始提供了一个专门用于简化并发编程的工具包，这个工具包就是J.U.C。</p>","more":"<p>业界有一句话说’并发不知<a href=\"http://g.oswego.edu\">Doug Lea</a>，学尽Java也枉然’。事实上，J.U.C的整个设计以及中间很多类的编写都是Doug Lea。上面链接是他的主页。他还编写了一本书叫做<Java并发编程实践>.这本书对于Java程序员研究并发编程的理论与实践绝对帮助很大。</p>\n<h2>Executors类</h2>\n\n<p>这个包主要提供了一些线程池的工具类。事实上，创建线程和销毁线程都是一些消耗比较大的操作。因此J.U.C提供了这样一些类来简化线程的创建和销毁以及管理。主要有这么四中线程池：newCachedThreadPool，可缓存的线程池。它的用法是当我们希望创建的线程使用完之后不要马上销毁，可以给下一个任务去使用。因此可以将这些线程缓存起来重用。这样就节省了线程频繁创建于销毁带来的开支；newFixedThreadPool，固定大小的线程池。如果我们的任务数固定，而且可以确定线程数量使用这种线程池就比较好。不会有资源的浪费；newScheduledThreadPool，可调度的线程池。有一些任务我们希望在某个时间点或者某种频率触发，就可以使用这种线程池；newSingleThreadExecutor,单个线程的线程池。这种线程池一般用于任务数比较少，可以固定一个线程来执行。生产实践中我个人还是很少用到。</p>\n<p>跟线程池相关的自然是任务。J.U.C简化了我们创建和销毁以及管理线程的步骤，我们要做的只是将可以并行化的部分抽象出任务，写好task类即可。而task又可以带返回值和不带返回值。这些是通过Future等类实现。同时，在这个Executors框架里还提供了ForkJoin机制的实现类，用于工作窃取机制算法的实现。关于这个算法的原理，可以参考这个<a href=\"http://ifeve.com/fork-join-1/\">文档</a>。涉及到线程池，涉及到任务，自然就会牵扯到很多东西，比如任务队列，优先级，启动和中断等。这些都定义在Executors这个框架里。</p>\n<h2>并发集合类</h2>\n\n<p>J.U.C提供了非常丰富的线程安全的集合类。比如队列，Map,List等数据结构。其中生产实践中用的最多的恐怕是ConcurrentHashMap了。这个类型的Map的详细介绍后面会有。它是一个线程安全的HashMap，但是性能比直接用HashTable或者同步化包装的HashMap高很多。原因需要看这个类的实现才能理解。根据不同的适用场景，提供了非常丰富的集合类供程序员适用。</p>\n<h2>原子信号量工具类</h2>\n\n<p>锁，信号量等在Java代码层面实现了。而且J.U.C提供的Lock类更加灵活，据说性能已经开始超过synchonized等关键字了。同时提供了一些信号量用于实现一些比如流控或者自定义锁等功能。</p>\n<h2>原子基本类</h2>\n\n<p>对于int,long，double等一些基本类，提供了一些对应的原子类的实现。这些类的线程安全保证是通过无锁化的CAS操作实现的。详细的后面的文章也会介绍。</p>\n<p>同时还有一些比如TimeUnit等工具类。</p>\n<h2>总结</h2>\n\n<p>J.U.C给Java程序员实现并发编程带来了极大的便利，因为并发编程本来就是一项比较复杂难以测试的事情，因此虽然J.U.C已经最大程度上简化了程序员的工作，但还是需要程序员对并发编程的理论非常熟悉，经历过很多次实践才能用好并发编程带来性能效率上的提升。</p>\n<p><a href=\"http://wantedonline.cn/2016/09/08/20160908-1/\">专题目录</a></p>"},{"title":"镜头下的所思","date":"2016-11-12T10:19:51.000Z","_content":"2015年某个阳光明媚的周末摄于深圳莲花山公园。当时发表在QQ空间，今天偶然发现，这是目前为止我摄影天赋表现得最高的一次了(其实是这之后就没拿起过相机拍过照了。。没时间，没心情)。特地转到个人博客发表。关于照片中水印是'PHOTO TAKED BY JACKWANG' 中的JackWang就是LouisWang，16年前的英文名。后面在好朋友的建议下改成了LouisWang。\n\n<!--more-->\n\n![1](http://o9z6i1a1s.bkt.clouddn.com/1.jpg)\n![2](http://o9z6i1a1s.bkt.clouddn.com/2.jpg)\n**漫漫人生路**\n![](http://o9z6i1a1s.bkt.clouddn.com/3.jpg)\n**有时候，我们根本看不到前方是什么，即便如此，也只能往前，因为别无选择**\n![](http://o9z6i1a1s.bkt.clouddn.com/4.jpg)\n**当选择真正来临的时候，反而会辗转反侧**\n![](http://o9z6i1a1s.bkt.clouddn.com/5.jpg)\n**因为前方的路，总是有些模糊和不安**\n![](http://o9z6i1a1s.bkt.clouddn.com/6.jpg)\n**别急，走下去，总有一天，会慢慢清晰**\n![](http://o9z6i1a1s.bkt.clouddn.com/7.jpg)\n**累了的时候，可以休息一下，既然选择远方，便要风雨兼程**\n![](http://o9z6i1a1s.bkt.clouddn.com/8.jpg)\n![](http://o9z6i1a1s.bkt.clouddn.com/9.jpg)\n**前进的过程中，有可能会碰到志同道合的同伴**\n![](http://o9z6i1a1s.bkt.clouddn.com/10.jpg)\n**也可能是独自一人**\n![](http://o9z6i1a1s.bkt.clouddn.com/11.jpg)\n**但不管怎样，坚持下去，最后都会看到别样的风景**\n**只是有时候，我们以为自己是第一个**\n![](http://o9z6i1a1s.bkt.clouddn.com/12.jpg)\n**其实，早就有人比你先登上峰顶**\n![](http://o9z6i1a1s.bkt.clouddn.com/13.jpg)\n**但是，那又怎样？我看到的是我的世界里的风景**\n![](http://o9z6i1a1s.bkt.clouddn.com/14.jpg)\n**在前进的道路上，有时需要指引，才不至于迷失自己**\n![](http://o9z6i1a1s.bkt.clouddn.com/15.jpg)\n**有的指引，就是一盏路灯，照亮了前进的道路**\n![](http://o9z6i1a1s.bkt.clouddn.com/16.jpg)\n**瞬间，前面的路变得宽敞又明亮**\n![](http://o9z6i1a1s.bkt.clouddn.com/17.jpg)\n**你站在桥上看风景，看风景的人在楼上看你**\n**羡慕别人的时候，殊不知自己也被人羡慕**\n![](http://o9z6i1a1s.bkt.clouddn.com/18.jpg)\n**有时，我们会遇到这样的人**\n![](http://o9z6i1a1s.bkt.clouddn.com/19.jpg)\n**有时，不能相信自己的眼睛**\n**因为，有时自己都不知道谁应该被帮助**\n![](http://o9z6i1a1s.bkt.clouddn.com/20.jpg)\n**坚持走下去，人生，就是一个自我完善的过程……**\n------------华丽的分割------------------\n![](http://o9z6i1a1s.bkt.clouddn.com/21.jpg)\n**再见，小时候**\n![](http://o9z6i1a1s.bkt.clouddn.com/22.jpg)\n**别总是工作，不要辜负阳光和青草**\n![](http://o9z6i1a1s.bkt.clouddn.com/23.jpg)\n**年轻，真好。青春，真好！**\n![](http://o9z6i1a1s.bkt.clouddn.com/24.jpg)\n**噢，你到底爱不爱我~**\n![](http://o9z6i1a1s.bkt.clouddn.com/25.jpg)\n![](http://o9z6i1a1s.bkt.clouddn.com/26.jpg)\n![](http://o9z6i1a1s.bkt.clouddn.com/27.jpg)\n**人生，最满足的事情莫过于和好哥们一起，把兴趣当成谋生**\n![](http://o9z6i1a1s.bkt.clouddn.com/28.jpg)\n**幼有所养，老有所依**\n![](http://o9z6i1a1s.bkt.clouddn.com/29.jpg)\n![](http://o9z6i1a1s.bkt.clouddn.com/30.jpg)\n**无论我们飘多远，总有一条线拉着**\n![](http://o9z6i1a1s.bkt.clouddn.com/31.jpg)\n![](http://o9z6i1a1s.bkt.clouddn.com/32.jpg)\n**有故事有意思的大爷，他说，我喜欢满世界拉琴~~~**\n","source":"_posts/20161112-2.md","raw":"---\ntitle: '镜头下的所思'\ndate: 2016-11-12 18:19:51\ntags: \n - 随笔\n - 摄影\n - 人生思考\ncategories: 随笔\n---\n2015年某个阳光明媚的周末摄于深圳莲花山公园。当时发表在QQ空间，今天偶然发现，这是目前为止我摄影天赋表现得最高的一次了(其实是这之后就没拿起过相机拍过照了。。没时间，没心情)。特地转到个人博客发表。关于照片中水印是'PHOTO TAKED BY JACKWANG' 中的JackWang就是LouisWang，16年前的英文名。后面在好朋友的建议下改成了LouisWang。\n\n<!--more-->\n\n![1](http://o9z6i1a1s.bkt.clouddn.com/1.jpg)\n![2](http://o9z6i1a1s.bkt.clouddn.com/2.jpg)\n**漫漫人生路**\n![](http://o9z6i1a1s.bkt.clouddn.com/3.jpg)\n**有时候，我们根本看不到前方是什么，即便如此，也只能往前，因为别无选择**\n![](http://o9z6i1a1s.bkt.clouddn.com/4.jpg)\n**当选择真正来临的时候，反而会辗转反侧**\n![](http://o9z6i1a1s.bkt.clouddn.com/5.jpg)\n**因为前方的路，总是有些模糊和不安**\n![](http://o9z6i1a1s.bkt.clouddn.com/6.jpg)\n**别急，走下去，总有一天，会慢慢清晰**\n![](http://o9z6i1a1s.bkt.clouddn.com/7.jpg)\n**累了的时候，可以休息一下，既然选择远方，便要风雨兼程**\n![](http://o9z6i1a1s.bkt.clouddn.com/8.jpg)\n![](http://o9z6i1a1s.bkt.clouddn.com/9.jpg)\n**前进的过程中，有可能会碰到志同道合的同伴**\n![](http://o9z6i1a1s.bkt.clouddn.com/10.jpg)\n**也可能是独自一人**\n![](http://o9z6i1a1s.bkt.clouddn.com/11.jpg)\n**但不管怎样，坚持下去，最后都会看到别样的风景**\n**只是有时候，我们以为自己是第一个**\n![](http://o9z6i1a1s.bkt.clouddn.com/12.jpg)\n**其实，早就有人比你先登上峰顶**\n![](http://o9z6i1a1s.bkt.clouddn.com/13.jpg)\n**但是，那又怎样？我看到的是我的世界里的风景**\n![](http://o9z6i1a1s.bkt.clouddn.com/14.jpg)\n**在前进的道路上，有时需要指引，才不至于迷失自己**\n![](http://o9z6i1a1s.bkt.clouddn.com/15.jpg)\n**有的指引，就是一盏路灯，照亮了前进的道路**\n![](http://o9z6i1a1s.bkt.clouddn.com/16.jpg)\n**瞬间，前面的路变得宽敞又明亮**\n![](http://o9z6i1a1s.bkt.clouddn.com/17.jpg)\n**你站在桥上看风景，看风景的人在楼上看你**\n**羡慕别人的时候，殊不知自己也被人羡慕**\n![](http://o9z6i1a1s.bkt.clouddn.com/18.jpg)\n**有时，我们会遇到这样的人**\n![](http://o9z6i1a1s.bkt.clouddn.com/19.jpg)\n**有时，不能相信自己的眼睛**\n**因为，有时自己都不知道谁应该被帮助**\n![](http://o9z6i1a1s.bkt.clouddn.com/20.jpg)\n**坚持走下去，人生，就是一个自我完善的过程……**\n------------华丽的分割------------------\n![](http://o9z6i1a1s.bkt.clouddn.com/21.jpg)\n**再见，小时候**\n![](http://o9z6i1a1s.bkt.clouddn.com/22.jpg)\n**别总是工作，不要辜负阳光和青草**\n![](http://o9z6i1a1s.bkt.clouddn.com/23.jpg)\n**年轻，真好。青春，真好！**\n![](http://o9z6i1a1s.bkt.clouddn.com/24.jpg)\n**噢，你到底爱不爱我~**\n![](http://o9z6i1a1s.bkt.clouddn.com/25.jpg)\n![](http://o9z6i1a1s.bkt.clouddn.com/26.jpg)\n![](http://o9z6i1a1s.bkt.clouddn.com/27.jpg)\n**人生，最满足的事情莫过于和好哥们一起，把兴趣当成谋生**\n![](http://o9z6i1a1s.bkt.clouddn.com/28.jpg)\n**幼有所养，老有所依**\n![](http://o9z6i1a1s.bkt.clouddn.com/29.jpg)\n![](http://o9z6i1a1s.bkt.clouddn.com/30.jpg)\n**无论我们飘多远，总有一条线拉着**\n![](http://o9z6i1a1s.bkt.clouddn.com/31.jpg)\n![](http://o9z6i1a1s.bkt.clouddn.com/32.jpg)\n**有故事有意思的大爷，他说，我喜欢满世界拉琴~~~**\n","slug":"20161112-2","published":1,"updated":"2016-11-12T10:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf4200161ati83vw3a9t","content":"<p>2015年某个阳光明媚的周末摄于深圳莲花山公园。当时发表在QQ空间，今天偶然发现，这是目前为止我摄影天赋表现得最高的一次了(其实是这之后就没拿起过相机拍过照了。。没时间，没心情)。特地转到个人博客发表。关于照片中水印是’PHOTO TAKED BY JACKWANG’ 中的JackWang就是LouisWang，16年前的英文名。后面在好朋友的建议下改成了LouisWang。</p>\n<a id=\"more\"></a>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/1.jpg\" alt=\"1\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2.jpg\" alt=\"2\"><br><strong>漫漫人生路</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/3.jpg\" alt=\"\"><br><strong>有时候，我们根本看不到前方是什么，即便如此，也只能往前，因为别无选择</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/4.jpg\" alt=\"\"><br><strong>当选择真正来临的时候，反而会辗转反侧</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/5.jpg\" alt=\"\"><br><strong>因为前方的路，总是有些模糊和不安</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/6.jpg\" alt=\"\"><br><strong>别急，走下去，总有一天，会慢慢清晰</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/7.jpg\" alt=\"\"><br><strong>累了的时候，可以休息一下，既然选择远方，便要风雨兼程</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/8.jpg\" alt=\"\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/9.jpg\" alt=\"\"><br><strong>前进的过程中，有可能会碰到志同道合的同伴</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/10.jpg\" alt=\"\"><br><strong>也可能是独自一人</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/11.jpg\" alt=\"\"><br><strong>但不管怎样，坚持下去，最后都会看到别样的风景</strong><br><strong>只是有时候，我们以为自己是第一个</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/12.jpg\" alt=\"\"><br><strong>其实，早就有人比你先登上峰顶</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/13.jpg\" alt=\"\"><br><strong>但是，那又怎样？我看到的是我的世界里的风景</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/14.jpg\" alt=\"\"><br><strong>在前进的道路上，有时需要指引，才不至于迷失自己</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/15.jpg\" alt=\"\"><br><strong>有的指引，就是一盏路灯，照亮了前进的道路</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/16.jpg\" alt=\"\"><br><strong>瞬间，前面的路变得宽敞又明亮</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/17.jpg\" alt=\"\"><br><strong>你站在桥上看风景，看风景的人在楼上看你</strong><br><strong>羡慕别人的时候，殊不知自己也被人羡慕</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/18.jpg\" alt=\"\"><br><strong>有时，我们会遇到这样的人</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/19.jpg\" alt=\"\"><br><strong>有时，不能相信自己的眼睛</strong><br><strong>因为，有时自己都不知道谁应该被帮助</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/20.jpg\" alt=\"\"><br><strong>坚持走下去，人生，就是一个自我完善的过程……</strong><br>————华丽的分割——————<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/21.jpg\" alt=\"\"><br><strong>再见，小时候</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/22.jpg\" alt=\"\"><br><strong>别总是工作，不要辜负阳光和青草</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/23.jpg\" alt=\"\"><br><strong>年轻，真好。青春，真好！</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/24.jpg\" alt=\"\"><br><strong>噢，你到底爱不爱我~</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/25.jpg\" alt=\"\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/26.jpg\" alt=\"\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/27.jpg\" alt=\"\"><br><strong>人生，最满足的事情莫过于和好哥们一起，把兴趣当成谋生</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/28.jpg\" alt=\"\"><br><strong>幼有所养，老有所依</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/29.jpg\" alt=\"\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/30.jpg\" alt=\"\"><br><strong>无论我们飘多远，总有一条线拉着</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/31.jpg\" alt=\"\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/32.jpg\" alt=\"\"><br><strong>有故事有意思的大爷，他说，我喜欢满世界拉琴~~~</strong></p>\n","excerpt":"<p>2015年某个阳光明媚的周末摄于深圳莲花山公园。当时发表在QQ空间，今天偶然发现，这是目前为止我摄影天赋表现得最高的一次了(其实是这之后就没拿起过相机拍过照了。。没时间，没心情)。特地转到个人博客发表。关于照片中水印是’PHOTO TAKED BY JACKWANG’ 中的JackWang就是LouisWang，16年前的英文名。后面在好朋友的建议下改成了LouisWang。</p>","more":"<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/1.jpg\" alt=\"1\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/2.jpg\" alt=\"2\"><br><strong>漫漫人生路</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/3.jpg\" alt=\"\"><br><strong>有时候，我们根本看不到前方是什么，即便如此，也只能往前，因为别无选择</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/4.jpg\" alt=\"\"><br><strong>当选择真正来临的时候，反而会辗转反侧</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/5.jpg\" alt=\"\"><br><strong>因为前方的路，总是有些模糊和不安</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/6.jpg\" alt=\"\"><br><strong>别急，走下去，总有一天，会慢慢清晰</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/7.jpg\" alt=\"\"><br><strong>累了的时候，可以休息一下，既然选择远方，便要风雨兼程</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/8.jpg\" alt=\"\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/9.jpg\" alt=\"\"><br><strong>前进的过程中，有可能会碰到志同道合的同伴</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/10.jpg\" alt=\"\"><br><strong>也可能是独自一人</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/11.jpg\" alt=\"\"><br><strong>但不管怎样，坚持下去，最后都会看到别样的风景</strong><br><strong>只是有时候，我们以为自己是第一个</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/12.jpg\" alt=\"\"><br><strong>其实，早就有人比你先登上峰顶</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/13.jpg\" alt=\"\"><br><strong>但是，那又怎样？我看到的是我的世界里的风景</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/14.jpg\" alt=\"\"><br><strong>在前进的道路上，有时需要指引，才不至于迷失自己</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/15.jpg\" alt=\"\"><br><strong>有的指引，就是一盏路灯，照亮了前进的道路</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/16.jpg\" alt=\"\"><br><strong>瞬间，前面的路变得宽敞又明亮</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/17.jpg\" alt=\"\"><br><strong>你站在桥上看风景，看风景的人在楼上看你</strong><br><strong>羡慕别人的时候，殊不知自己也被人羡慕</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/18.jpg\" alt=\"\"><br><strong>有时，我们会遇到这样的人</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/19.jpg\" alt=\"\"><br><strong>有时，不能相信自己的眼睛</strong><br><strong>因为，有时自己都不知道谁应该被帮助</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/20.jpg\" alt=\"\"><br><strong>坚持走下去，人生，就是一个自我完善的过程……</strong><br>————华丽的分割——————<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/21.jpg\" alt=\"\"><br><strong>再见，小时候</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/22.jpg\" alt=\"\"><br><strong>别总是工作，不要辜负阳光和青草</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/23.jpg\" alt=\"\"><br><strong>年轻，真好。青春，真好！</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/24.jpg\" alt=\"\"><br><strong>噢，你到底爱不爱我~</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/25.jpg\" alt=\"\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/26.jpg\" alt=\"\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/27.jpg\" alt=\"\"><br><strong>人生，最满足的事情莫过于和好哥们一起，把兴趣当成谋生</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/28.jpg\" alt=\"\"><br><strong>幼有所养，老有所依</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/29.jpg\" alt=\"\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/30.jpg\" alt=\"\"><br><strong>无论我们飘多远，总有一条线拉着</strong><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/31.jpg\" alt=\"\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/32.jpg\" alt=\"\"><br><strong>有故事有意思的大爷，他说，我喜欢满世界拉琴~~~</strong></p>"},{"title":"我为什么认为学历是重要的?","date":"2016-11-28T14:22:59.000Z","_content":"{%cq%}教育是一切痛苦的根源{%endcq%}\n\n学历是一个人一生中一个非常重要的价值标签。但是我不认为学历是一个人唯一或者绝对的价值标签。名牌大学里也出人渣，野鸡大学也有凤凰。\n<!--more-->\n\n以前，从没体会到过学历对一个人的影响。相反，社会上出现了一种\"读书无用论\"，读过书的给没有读过书的人打工的论调。走入社会后，遇到过各种各样的人，接触了各种各样的人。逐渐发现学历在很大概率上代表着一种东西。\n\n以前，我也认为毕业于比较好的大学只能说明过去学生时代是比较优秀的，这个优秀仅仅局限在学术，自然科学或社会科学的研究上。甚至，我也曾一度认为社会上某些岗位对学历过高的要求是不对的。\n\n接触的人多了后发现，学历高低和是否出身优秀学校的人在做人做事上差别还真的蛮大。做事，体现在思维方式，做事效率上。做人体现在为人处世，待人待物上。\n\n和优秀的人交流会感到非常省心和愉快，或者说自然而然有一种默契和共识在里面。因此做事，交流是效率高的。而和部分人交流确实费心费力的，半天Get不到点。看待问题抓不到本质和关键所在。\n\n同样，在生活上以及婚恋市场上，学历高也很能说明一些问题。我发现学历高的人往往明白自己的需求和别人的需求。对待生活和未来有很多符合实际的思考和规划。\n\n但是，凡事都没有绝对。学历高的人也有渣渣。学历一般甚至没有读过书的人也有非常优秀的人才涌现。毕竟每个人的成长环境，家庭背景都不一样。这是一个概率高低的问题。\n\n教育带给人更加丰富的人生体验和视界。但同样也给人带来了一些难以理解的思维方式和眼光。因此有人说教育是一切痛苦的根源。似乎上帝是公平的，你获得比别人多一些东西，自然也要剥夺一些东西。思维开化了，视界提高了，对自己，对别人的要求自然也就拔高了，欲望也更多了。因此才有了一些别人所没有的痛苦吧。\n\n凡事没有绝对，但愿每个人都能拥有丰富多彩的人生和幸福快乐的生活~\n","source":"_posts/20161128.md","raw":"---\ntitle: 我为什么认为学历是重要的?\ndate: 2016-11-28 22:22:59\ntags: \n - 学历\n - 杂谈\n - 随笔\ncategories: 随笔\n---\n{%cq%}教育是一切痛苦的根源{%endcq%}\n\n学历是一个人一生中一个非常重要的价值标签。但是我不认为学历是一个人唯一或者绝对的价值标签。名牌大学里也出人渣，野鸡大学也有凤凰。\n<!--more-->\n\n以前，从没体会到过学历对一个人的影响。相反，社会上出现了一种\"读书无用论\"，读过书的给没有读过书的人打工的论调。走入社会后，遇到过各种各样的人，接触了各种各样的人。逐渐发现学历在很大概率上代表着一种东西。\n\n以前，我也认为毕业于比较好的大学只能说明过去学生时代是比较优秀的，这个优秀仅仅局限在学术，自然科学或社会科学的研究上。甚至，我也曾一度认为社会上某些岗位对学历过高的要求是不对的。\n\n接触的人多了后发现，学历高低和是否出身优秀学校的人在做人做事上差别还真的蛮大。做事，体现在思维方式，做事效率上。做人体现在为人处世，待人待物上。\n\n和优秀的人交流会感到非常省心和愉快，或者说自然而然有一种默契和共识在里面。因此做事，交流是效率高的。而和部分人交流确实费心费力的，半天Get不到点。看待问题抓不到本质和关键所在。\n\n同样，在生活上以及婚恋市场上，学历高也很能说明一些问题。我发现学历高的人往往明白自己的需求和别人的需求。对待生活和未来有很多符合实际的思考和规划。\n\n但是，凡事都没有绝对。学历高的人也有渣渣。学历一般甚至没有读过书的人也有非常优秀的人才涌现。毕竟每个人的成长环境，家庭背景都不一样。这是一个概率高低的问题。\n\n教育带给人更加丰富的人生体验和视界。但同样也给人带来了一些难以理解的思维方式和眼光。因此有人说教育是一切痛苦的根源。似乎上帝是公平的，你获得比别人多一些东西，自然也要剥夺一些东西。思维开化了，视界提高了，对自己，对别人的要求自然也就拔高了，欲望也更多了。因此才有了一些别人所没有的痛苦吧。\n\n凡事没有绝对，但愿每个人都能拥有丰富多彩的人生和幸福快乐的生活~\n","slug":"20161128","published":1,"updated":"2016-11-28T14:27:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf43001a1atipqw8esga","content":"<blockquote class=\"blockquote-center\"><p>教育是一切痛苦的根源</p>\n</blockquote>\n<p>学历是一个人一生中一个非常重要的价值标签。但是我不认为学历是一个人唯一或者绝对的价值标签。名牌大学里也出人渣，野鸡大学也有凤凰。<br><a id=\"more\"></a></p>\n<p>以前，从没体会到过学历对一个人的影响。相反，社会上出现了一种”读书无用论”，读过书的给没有读过书的人打工的论调。走入社会后，遇到过各种各样的人，接触了各种各样的人。逐渐发现学历在很大概率上代表着一种东西。</p>\n<p>以前，我也认为毕业于比较好的大学只能说明过去学生时代是比较优秀的，这个优秀仅仅局限在学术，自然科学或社会科学的研究上。甚至，我也曾一度认为社会上某些岗位对学历过高的要求是不对的。</p>\n<p>接触的人多了后发现，学历高低和是否出身优秀学校的人在做人做事上差别还真的蛮大。做事，体现在思维方式，做事效率上。做人体现在为人处世，待人待物上。</p>\n<p>和优秀的人交流会感到非常省心和愉快，或者说自然而然有一种默契和共识在里面。因此做事，交流是效率高的。而和部分人交流确实费心费力的，半天Get不到点。看待问题抓不到本质和关键所在。</p>\n<p>同样，在生活上以及婚恋市场上，学历高也很能说明一些问题。我发现学历高的人往往明白自己的需求和别人的需求。对待生活和未来有很多符合实际的思考和规划。</p>\n<p>但是，凡事都没有绝对。学历高的人也有渣渣。学历一般甚至没有读过书的人也有非常优秀的人才涌现。毕竟每个人的成长环境，家庭背景都不一样。这是一个概率高低的问题。</p>\n<p>教育带给人更加丰富的人生体验和视界。但同样也给人带来了一些难以理解的思维方式和眼光。因此有人说教育是一切痛苦的根源。似乎上帝是公平的，你获得比别人多一些东西，自然也要剥夺一些东西。思维开化了，视界提高了，对自己，对别人的要求自然也就拔高了，欲望也更多了。因此才有了一些别人所没有的痛苦吧。</p>\n<p>凡事没有绝对，但愿每个人都能拥有丰富多彩的人生和幸福快乐的生活~</p>\n","excerpt":"<blockquote class=\"blockquote-center\"><p>教育是一切痛苦的根源</p>\n</blockquote>\n<p>学历是一个人一生中一个非常重要的价值标签。但是我不认为学历是一个人唯一或者绝对的价值标签。名牌大学里也出人渣，野鸡大学也有凤凰。<br>","more":"</p>\n<p>以前，从没体会到过学历对一个人的影响。相反，社会上出现了一种”读书无用论”，读过书的给没有读过书的人打工的论调。走入社会后，遇到过各种各样的人，接触了各种各样的人。逐渐发现学历在很大概率上代表着一种东西。</p>\n<p>以前，我也认为毕业于比较好的大学只能说明过去学生时代是比较优秀的，这个优秀仅仅局限在学术，自然科学或社会科学的研究上。甚至，我也曾一度认为社会上某些岗位对学历过高的要求是不对的。</p>\n<p>接触的人多了后发现，学历高低和是否出身优秀学校的人在做人做事上差别还真的蛮大。做事，体现在思维方式，做事效率上。做人体现在为人处世，待人待物上。</p>\n<p>和优秀的人交流会感到非常省心和愉快，或者说自然而然有一种默契和共识在里面。因此做事，交流是效率高的。而和部分人交流确实费心费力的，半天Get不到点。看待问题抓不到本质和关键所在。</p>\n<p>同样，在生活上以及婚恋市场上，学历高也很能说明一些问题。我发现学历高的人往往明白自己的需求和别人的需求。对待生活和未来有很多符合实际的思考和规划。</p>\n<p>但是，凡事都没有绝对。学历高的人也有渣渣。学历一般甚至没有读过书的人也有非常优秀的人才涌现。毕竟每个人的成长环境，家庭背景都不一样。这是一个概率高低的问题。</p>\n<p>教育带给人更加丰富的人生体验和视界。但同样也给人带来了一些难以理解的思维方式和眼光。因此有人说教育是一切痛苦的根源。似乎上帝是公平的，你获得比别人多一些东西，自然也要剥夺一些东西。思维开化了，视界提高了，对自己，对别人的要求自然也就拔高了，欲望也更多了。因此才有了一些别人所没有的痛苦吧。</p>\n<p>凡事没有绝对，但愿每个人都能拥有丰富多彩的人生和幸福快乐的生活~</p>"},{"title":"基于LinkedList实现的固定大小线性排序数据结构","date":"2016-07-06T09:52:28.000Z","_content":"\n<h3>概要：</h3>\n本文详细讲解了在Java中使用LinkedList实现一种可以设置固定大小的线性集合，该集合线程安全，需要达到业务的最优性能。\n\n<!--more-->\n\n<h3>1. 缘起</h3>\n最近工作过程中碰到一个做周期性更新排行榜的需求。涉及的数据字段和记录条数非常多。概括如下：\n1. 数据分布于后台数据库100张数据表中；\n2. 每张表的数据更新非常快，每天预估数据增量在1W条左右；\n3. 排行榜的数据生成来源于这100张表中，只取前面100条；\n\n约束：\n\n- 数据库服务目前只有一个主从，数据周期性变化，原始数据必须放MySQL持久化，不能放Redis\n- 尽可能减少数据库连接获取，尽可能减少数据库查询，这些昂贵的资源必须优先保证核心业务\n\n<h3>2. 基本思路</h3>\n如果数据量比较少，我们直接放到一个List然后调用Collections.sort排序即可。但是假如我们的排行榜要求的数据量是1W或者10W，每条记录按1KB的大小计算，那么100张表的数据量就是100*10W*1KB，服务器内存早就爆表。显然这种方案是不行的。\n\n我们需要这样一种结构，每次一张数据库表中查出前m条记录，将这m条记录插入到一个容器中，这个容器会自动将这m条记录按大小排序，从另外一张表中查出m条记录，继续放到这个容器，容器依然能保证从大到小存储前m条记录。\n\n这就好像一个擂台，我们可以设置这个擂台大小。每次放到擂台的选手，经过比赛之后，自动从大到小排好序，如果超过擂台大小，排在后面的选手自动淘汰。新加进来的选手可以来踢馆，最终强者留下。如果擂台大小还有剩余，可以容纳更多的选手。直到达到擂台大小就进入淘汰赛。\n\n同时，还有一个需求，我们100张表可以用100个线程一次查询出来，因此这个容器必须线程安全。同时，性能要好。\n\n纵观JDK的集合包，似乎没有现成的数据结构可以用。那是否可以直接使用J.U.C包中线程安全的集合？理论上是可以的。通过组合比如LinkedBlockingQueue，PriorityBlockingQueue或其他线程安全的数据结构。问题是我们还要时刻保持有序，大小固定这两个要求，隐含一个性能要好的隐形需求。如果直接使用线程安全的集合，显然还要额外加锁，两把锁以上的数据结构有可能存在死锁问题。\n\n与其苦苦死锁寻找JDK给我们的馅饼，还不如自己动手，丰衣足食。即便重复写的轮子不如大师的轮子，但是先写一个放到测试环境跑一跑，只要大流程不出问题，还是不会给公司带来损失，发现小bug后面再慢慢优化就是。\n\n<h3>3. 初步实现</h3>\n首先，这个擂台比如增删频繁，因此使用链式结构是最优选。容器的元素一开始就有序，并且后面新加的元素要有序，使用插入排序是最优选，后面新加元素要找到合适的插入位置。就必定要和容器中的元素打擂，但并没必要一一比赛，因为容器的元素已经是有序的了。这时候使用二分查找寻找待插入元素的位置便是最优解。\n\n插入：O(1),使用链表，无需移动元素\n二分查找: O(lgn)\n遍历集合: O(n)\n\n我们JDK提供的集合排序会根据数据量规模自动选择排序算法，最优性能是O(nlgn),因为集合中的元素一开始是无序的。因此相比较而言，理论上我们的集合性能上要优于直接使用JDK提供的排序方法。\n\n元素类型不确定，比较依据也不确定，固定大小可以由使用者设置，一旦设置就不能更改。因此这里必须使用泛型，同时由用户传入一个比较器，可以使用匿名内部类。同时传入一个固定大小。容器内部每添加一个元素前都要判断，当前是否已经达到擂台大小，如果新加入的元素超出了擂台大小，则必须进入淘汰赛，将最小元素淘汰。当然，维护从大到小还是从小到大可以通过比较器的返回值决定，这里我的需求是从大到小。\n\n综合以上的条件，我们可以动手写代码了。\n\n<h3>4. 核心实现</h3>\n\n```java\n    public class ArenaList<E> {\n    /*the arena capacity*/\n    private final int capacity;\n    /*need user to define，int r = compare(e1, e2),when r > 0，e1 > e2,r = 0, e1 = e2, r < 0, e1 < e2*/\n    private final Comparator<E> comparator;\n    \n    private final LinkedList<E> values;\n    /*if there is an element in list e1, that e1 equal e2, which e2 is we want to add,\n     * if keepNewerElement is false,we will drop e2,else drop e1*/\n    private final boolean keepNewerElement;\n    /*at this moment,the element count, when eCount < size, we can add new element into list and will not remove the last element*/\n    private volatile int eCount = 0;\n```\n\n容器定义的字段如上代码所示，\ncapacity必须在构造函数中传入，一旦初始化之后就不能更改。同时以后可能会实现序列化，虽然现在没有考虑序列化问题。\ncomparator是用户定义的比较器，也必须在构造时初始化。我们约定，调用比较器的compare(e1, e2)比较元素，当返回值r > 0，表示e1 > e2,当r < 0,表示e1 < e2。r = 0则表示元素相等。\nvalues是存储元素的最终容器，因为增删频繁，因此使用链表，初始化之后就不能更改；\nkeepNewerElement是这样一个作用，当排在最后的两个元素en和em，如果en = em,em是待加入元素，并且擂台已满，是否用新加入的淘汰旧的。默认这个开关是false。\neCount，表示当前容器中添加了多少元素。当擂台没有满时，eCount < size，当擂台满了的时候 eCount = size。这里加了volatile修饰，是为了保证多线程下该变量的可见性。这里不深入探讨Java并发问题，因为这个问题要说清楚可以另开一篇文章来说。简单的说volatile是轻量级同步锁，可能保证变量的可见性但不能保证原子性。同时保证了一些可能引发潜在问题的重排序问题。这些涉及到Java内存模型(JMM)，不在多说。这里没有用J.U.C包下的原子变量是因为我们这里容器的增删也要加锁，为了更好的性能，就没必要CAS自旋消耗性能。\n\n提供的两个构造函数：\n\n```java\n\tpublic ArenaList(int capacity, Comparator<E> comparator) {\n        if (capacity <= 0) {\n            throw new IllegalArgumentException(\"size can't be negative number\");\n        }\n        \n        this.capacity = capacity;\n        this.comparator = comparator;\n        this.keepNewerElement = false;\n        this.values = new LinkedList<E>();\n    }\n```\n    \n默认keepNewerElement是false，我们也可以自定义为true\n```java  \n    public ArenaList(int capacity, Comparator<E> comparator, boolean keepNewerElement) {\n        if (capacity <= 0) {\n            throw new IllegalArgumentException(\"size can't be negative number\");\n        }\n        \n        this.capacity = capacity;\n        this.comparator = comparator;\n        this.keepNewerElement = keepNewerElement;\n        this.values = new LinkedList<E>();\n    }\n```\n\n这个容器中，凡是涉及到容器的增删操作都要考虑线程安全问题。因此都要加锁。锁的实现也有好多种。比如粗粒度的方法锁，或JDK提供的可重入锁(ReentrantLock)。但隐含的性能要求最好时将临界区保持最小。同时代码简洁，因此这里我选用了synchronized对象锁。以values作为锁对象。\n\n添加删除元素的部分代码如下：\n\n```java\n    /**\n     * add e into list with thread-safe\n     * @param e\n     */\n    public void add(E e) {\n        if (null == e) {\n            throw new NullPointerException(\"Null Element.\");\n        }\n        \n        synchronized (values) {\n            int index = findElementIndex(e);\n            if (values.size() >= capacity) {\n                if (keepNewerElement && index <= values.size()) {\n                    values.removeLast();\n                } else if (index < values.size()){\n                    //e is in the middle of this list\n                    values.removeLast();\n                } else {\n                    //e is at the end of this list and e equals the minElement, no need to add.\n                    return;\n                }\n            }\n            values.add(index, e);\n            eCount++;\n        }\n    }\n```\n\n删除元素:\n```java    \n    /**\n     * remove e from list with thread-safe\n     * @param e\n     * @return\n     */\n    public boolean remove(E e) {\n        if (null == e) {\n            throw new NullPointerException(\"Null Element.\");\n        }\n        synchronized (values) {\n            if(values.remove(e)) {\n                eCount--;\n                return true;\n            }\n            return false;\n        }\n    }\n```\n\n寻找待插入元素元素采用的算法是二分查找，这个算法原理非常简单，但是陷阱非常多，一不小心就会陷入死循环。我还记得当年我大学毕业处女面BAT中某一家，面试官让我写个二分查找。我三下五除二洋洋洒洒写完了，完全手写，没办法测试。估计当时肯定有bug。反正最终挂了。这个算法还真不是那么简单，代码如下：\n```java  \n    /**\n     * find the index of e should be\n     * @param e\n     * @return\n     */\n    private int findElementIndex(E e) {\n        int index = 0;\n        if (values.size() == 0) {\n            return index;\n        }\n        //values.size() > 0\n        E minElement = values.getLast();\n        //the largest element at the index of 0\n        int high = values.lastIndexOf(minElement);\n        \n        E maxElement = values.getFirst();\n        //the least element at the index of values.size() - 1\n        int low = values.indexOf(maxElement);\n        \n        if (compareTwoElement(minElement, e) >= 0) {\n            //minElement >= e\n            index = high + 1;\n            return index;\n        }\n        \n        if (compareTwoElement(maxElement, e) <= 0) {\n            //maxElement <= e\n            return index;\n        }\n        \n        //only one element\n        if (low == high) {\n            if (capacity == 1) {\n                return index;\n            }\n            if (compareTwoElement(minElement, e) > 0) {\n                //minElement > e\n                index = high + 1;\n                return index;\n            } else if (compareTwoElement(minElement, e) < 0) {\n                //minElement < e\n                return index;\n            } else {\n                //minElement = maxElement = e\n                return index;\n            }\n        }\n        \n        //more than one element and e must at the middle of this list,use binary search to find index\n        int middle = 0;\n        while (low < high) {\n            middle = (low + high) / 2;\n            E minddleE = values.get(middle);\n            if (compareTwoElement(minddleE, e) == 0) {\n                //find it.\n                index = middle;\n                return index;\n            }\n            \n            if (compareTwoElement(minddleE, e) > 0) {\n                //middleE > e\n                low = middle;\n            } else {\n                //middleE < e\n                high = middle;\n            }\n            if (high - low == 1) {\n                //if there only two element, e is in the middle of this list,low will never be higher or equal high\n                //at this moment,should check out\n                //[4,2,1],3 need to insert into it or [4,3,1],2 need to insert into it\n                return low + 1;\n            }\n            \n        }\n        //at this moment,low >= high,and (middle + 1)is we should find\n        index = middle + 1;\n        return index;\n    }\n```\n这里注意的是，容器中，大的元素在index为0，因此low表示大元素，high表示小元素。这点有悖于约定俗称。当只剩一个元素比较时就要特别注意了。\n\n<h3>5. 总结</h3>\n到这里，基本分析完了。我写过测试用例，尝试过使用100个线程来添加元素。目前业务上似乎没有问题。\n\n这个容器的原理非常简单，涉及的知识点也不算难。都是大学学过的。但是真正写起来却花费了很多时间。需要想各种测试场景写各种测试代码。到现在我完全没有信心说这个容器没有任何bug。但目前基本能满足我们的业务需求。Java并发是一门非常精深非常有意思的学问。很多时候我们写出的代码功能是符合要求，但是性能上本来可以做到更好的。其中并发就是一门需要丰富的经验和钻研才能写出高并发高性能程序的学问。在这条路上，我才刚刚起步。\n\n所有代码开源，可以自由使用。欢迎提出bug或更好的意见。特别是并发优化部分。\n\n源码下载：[https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java](https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java \"https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java\")\n\n<h3>6. 参考资料</h3>\n\n- [http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/util/LinkedList.java#LinkedList](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/util/LinkedList.java#LinkedList)\n\n","source":"_posts/base_linkedlist_data_structure20160706.md","raw":"---\ntitle: 基于LinkedList实现的固定大小线性排序数据结构\ndate: 2016-07-06 17:52:28\ntags: \n  - 并发 \n  - 数据结构\ncategories: 基础技术\n---\n\n<h3>概要：</h3>\n本文详细讲解了在Java中使用LinkedList实现一种可以设置固定大小的线性集合，该集合线程安全，需要达到业务的最优性能。\n\n<!--more-->\n\n<h3>1. 缘起</h3>\n最近工作过程中碰到一个做周期性更新排行榜的需求。涉及的数据字段和记录条数非常多。概括如下：\n1. 数据分布于后台数据库100张数据表中；\n2. 每张表的数据更新非常快，每天预估数据增量在1W条左右；\n3. 排行榜的数据生成来源于这100张表中，只取前面100条；\n\n约束：\n\n- 数据库服务目前只有一个主从，数据周期性变化，原始数据必须放MySQL持久化，不能放Redis\n- 尽可能减少数据库连接获取，尽可能减少数据库查询，这些昂贵的资源必须优先保证核心业务\n\n<h3>2. 基本思路</h3>\n如果数据量比较少，我们直接放到一个List然后调用Collections.sort排序即可。但是假如我们的排行榜要求的数据量是1W或者10W，每条记录按1KB的大小计算，那么100张表的数据量就是100*10W*1KB，服务器内存早就爆表。显然这种方案是不行的。\n\n我们需要这样一种结构，每次一张数据库表中查出前m条记录，将这m条记录插入到一个容器中，这个容器会自动将这m条记录按大小排序，从另外一张表中查出m条记录，继续放到这个容器，容器依然能保证从大到小存储前m条记录。\n\n这就好像一个擂台，我们可以设置这个擂台大小。每次放到擂台的选手，经过比赛之后，自动从大到小排好序，如果超过擂台大小，排在后面的选手自动淘汰。新加进来的选手可以来踢馆，最终强者留下。如果擂台大小还有剩余，可以容纳更多的选手。直到达到擂台大小就进入淘汰赛。\n\n同时，还有一个需求，我们100张表可以用100个线程一次查询出来，因此这个容器必须线程安全。同时，性能要好。\n\n纵观JDK的集合包，似乎没有现成的数据结构可以用。那是否可以直接使用J.U.C包中线程安全的集合？理论上是可以的。通过组合比如LinkedBlockingQueue，PriorityBlockingQueue或其他线程安全的数据结构。问题是我们还要时刻保持有序，大小固定这两个要求，隐含一个性能要好的隐形需求。如果直接使用线程安全的集合，显然还要额外加锁，两把锁以上的数据结构有可能存在死锁问题。\n\n与其苦苦死锁寻找JDK给我们的馅饼，还不如自己动手，丰衣足食。即便重复写的轮子不如大师的轮子，但是先写一个放到测试环境跑一跑，只要大流程不出问题，还是不会给公司带来损失，发现小bug后面再慢慢优化就是。\n\n<h3>3. 初步实现</h3>\n首先，这个擂台比如增删频繁，因此使用链式结构是最优选。容器的元素一开始就有序，并且后面新加的元素要有序，使用插入排序是最优选，后面新加元素要找到合适的插入位置。就必定要和容器中的元素打擂，但并没必要一一比赛，因为容器的元素已经是有序的了。这时候使用二分查找寻找待插入元素的位置便是最优解。\n\n插入：O(1),使用链表，无需移动元素\n二分查找: O(lgn)\n遍历集合: O(n)\n\n我们JDK提供的集合排序会根据数据量规模自动选择排序算法，最优性能是O(nlgn),因为集合中的元素一开始是无序的。因此相比较而言，理论上我们的集合性能上要优于直接使用JDK提供的排序方法。\n\n元素类型不确定，比较依据也不确定，固定大小可以由使用者设置，一旦设置就不能更改。因此这里必须使用泛型，同时由用户传入一个比较器，可以使用匿名内部类。同时传入一个固定大小。容器内部每添加一个元素前都要判断，当前是否已经达到擂台大小，如果新加入的元素超出了擂台大小，则必须进入淘汰赛，将最小元素淘汰。当然，维护从大到小还是从小到大可以通过比较器的返回值决定，这里我的需求是从大到小。\n\n综合以上的条件，我们可以动手写代码了。\n\n<h3>4. 核心实现</h3>\n\n```java\n    public class ArenaList<E> {\n    /*the arena capacity*/\n    private final int capacity;\n    /*need user to define，int r = compare(e1, e2),when r > 0，e1 > e2,r = 0, e1 = e2, r < 0, e1 < e2*/\n    private final Comparator<E> comparator;\n    \n    private final LinkedList<E> values;\n    /*if there is an element in list e1, that e1 equal e2, which e2 is we want to add,\n     * if keepNewerElement is false,we will drop e2,else drop e1*/\n    private final boolean keepNewerElement;\n    /*at this moment,the element count, when eCount < size, we can add new element into list and will not remove the last element*/\n    private volatile int eCount = 0;\n```\n\n容器定义的字段如上代码所示，\ncapacity必须在构造函数中传入，一旦初始化之后就不能更改。同时以后可能会实现序列化，虽然现在没有考虑序列化问题。\ncomparator是用户定义的比较器，也必须在构造时初始化。我们约定，调用比较器的compare(e1, e2)比较元素，当返回值r > 0，表示e1 > e2,当r < 0,表示e1 < e2。r = 0则表示元素相等。\nvalues是存储元素的最终容器，因为增删频繁，因此使用链表，初始化之后就不能更改；\nkeepNewerElement是这样一个作用，当排在最后的两个元素en和em，如果en = em,em是待加入元素，并且擂台已满，是否用新加入的淘汰旧的。默认这个开关是false。\neCount，表示当前容器中添加了多少元素。当擂台没有满时，eCount < size，当擂台满了的时候 eCount = size。这里加了volatile修饰，是为了保证多线程下该变量的可见性。这里不深入探讨Java并发问题，因为这个问题要说清楚可以另开一篇文章来说。简单的说volatile是轻量级同步锁，可能保证变量的可见性但不能保证原子性。同时保证了一些可能引发潜在问题的重排序问题。这些涉及到Java内存模型(JMM)，不在多说。这里没有用J.U.C包下的原子变量是因为我们这里容器的增删也要加锁，为了更好的性能，就没必要CAS自旋消耗性能。\n\n提供的两个构造函数：\n\n```java\n\tpublic ArenaList(int capacity, Comparator<E> comparator) {\n        if (capacity <= 0) {\n            throw new IllegalArgumentException(\"size can't be negative number\");\n        }\n        \n        this.capacity = capacity;\n        this.comparator = comparator;\n        this.keepNewerElement = false;\n        this.values = new LinkedList<E>();\n    }\n```\n    \n默认keepNewerElement是false，我们也可以自定义为true\n```java  \n    public ArenaList(int capacity, Comparator<E> comparator, boolean keepNewerElement) {\n        if (capacity <= 0) {\n            throw new IllegalArgumentException(\"size can't be negative number\");\n        }\n        \n        this.capacity = capacity;\n        this.comparator = comparator;\n        this.keepNewerElement = keepNewerElement;\n        this.values = new LinkedList<E>();\n    }\n```\n\n这个容器中，凡是涉及到容器的增删操作都要考虑线程安全问题。因此都要加锁。锁的实现也有好多种。比如粗粒度的方法锁，或JDK提供的可重入锁(ReentrantLock)。但隐含的性能要求最好时将临界区保持最小。同时代码简洁，因此这里我选用了synchronized对象锁。以values作为锁对象。\n\n添加删除元素的部分代码如下：\n\n```java\n    /**\n     * add e into list with thread-safe\n     * @param e\n     */\n    public void add(E e) {\n        if (null == e) {\n            throw new NullPointerException(\"Null Element.\");\n        }\n        \n        synchronized (values) {\n            int index = findElementIndex(e);\n            if (values.size() >= capacity) {\n                if (keepNewerElement && index <= values.size()) {\n                    values.removeLast();\n                } else if (index < values.size()){\n                    //e is in the middle of this list\n                    values.removeLast();\n                } else {\n                    //e is at the end of this list and e equals the minElement, no need to add.\n                    return;\n                }\n            }\n            values.add(index, e);\n            eCount++;\n        }\n    }\n```\n\n删除元素:\n```java    \n    /**\n     * remove e from list with thread-safe\n     * @param e\n     * @return\n     */\n    public boolean remove(E e) {\n        if (null == e) {\n            throw new NullPointerException(\"Null Element.\");\n        }\n        synchronized (values) {\n            if(values.remove(e)) {\n                eCount--;\n                return true;\n            }\n            return false;\n        }\n    }\n```\n\n寻找待插入元素元素采用的算法是二分查找，这个算法原理非常简单，但是陷阱非常多，一不小心就会陷入死循环。我还记得当年我大学毕业处女面BAT中某一家，面试官让我写个二分查找。我三下五除二洋洋洒洒写完了，完全手写，没办法测试。估计当时肯定有bug。反正最终挂了。这个算法还真不是那么简单，代码如下：\n```java  \n    /**\n     * find the index of e should be\n     * @param e\n     * @return\n     */\n    private int findElementIndex(E e) {\n        int index = 0;\n        if (values.size() == 0) {\n            return index;\n        }\n        //values.size() > 0\n        E minElement = values.getLast();\n        //the largest element at the index of 0\n        int high = values.lastIndexOf(minElement);\n        \n        E maxElement = values.getFirst();\n        //the least element at the index of values.size() - 1\n        int low = values.indexOf(maxElement);\n        \n        if (compareTwoElement(minElement, e) >= 0) {\n            //minElement >= e\n            index = high + 1;\n            return index;\n        }\n        \n        if (compareTwoElement(maxElement, e) <= 0) {\n            //maxElement <= e\n            return index;\n        }\n        \n        //only one element\n        if (low == high) {\n            if (capacity == 1) {\n                return index;\n            }\n            if (compareTwoElement(minElement, e) > 0) {\n                //minElement > e\n                index = high + 1;\n                return index;\n            } else if (compareTwoElement(minElement, e) < 0) {\n                //minElement < e\n                return index;\n            } else {\n                //minElement = maxElement = e\n                return index;\n            }\n        }\n        \n        //more than one element and e must at the middle of this list,use binary search to find index\n        int middle = 0;\n        while (low < high) {\n            middle = (low + high) / 2;\n            E minddleE = values.get(middle);\n            if (compareTwoElement(minddleE, e) == 0) {\n                //find it.\n                index = middle;\n                return index;\n            }\n            \n            if (compareTwoElement(minddleE, e) > 0) {\n                //middleE > e\n                low = middle;\n            } else {\n                //middleE < e\n                high = middle;\n            }\n            if (high - low == 1) {\n                //if there only two element, e is in the middle of this list,low will never be higher or equal high\n                //at this moment,should check out\n                //[4,2,1],3 need to insert into it or [4,3,1],2 need to insert into it\n                return low + 1;\n            }\n            \n        }\n        //at this moment,low >= high,and (middle + 1)is we should find\n        index = middle + 1;\n        return index;\n    }\n```\n这里注意的是，容器中，大的元素在index为0，因此low表示大元素，high表示小元素。这点有悖于约定俗称。当只剩一个元素比较时就要特别注意了。\n\n<h3>5. 总结</h3>\n到这里，基本分析完了。我写过测试用例，尝试过使用100个线程来添加元素。目前业务上似乎没有问题。\n\n这个容器的原理非常简单，涉及的知识点也不算难。都是大学学过的。但是真正写起来却花费了很多时间。需要想各种测试场景写各种测试代码。到现在我完全没有信心说这个容器没有任何bug。但目前基本能满足我们的业务需求。Java并发是一门非常精深非常有意思的学问。很多时候我们写出的代码功能是符合要求，但是性能上本来可以做到更好的。其中并发就是一门需要丰富的经验和钻研才能写出高并发高性能程序的学问。在这条路上，我才刚刚起步。\n\n所有代码开源，可以自由使用。欢迎提出bug或更好的意见。特别是并发优化部分。\n\n源码下载：[https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java](https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java \"https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java\")\n\n<h3>6. 参考资料</h3>\n\n- [http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/util/LinkedList.java#LinkedList](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/util/LinkedList.java#LinkedList)\n\n","slug":"base_linkedlist_data_structure20160706","published":1,"updated":"2016-07-16T14:52:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf45001d1ati3vscj6v5","content":"<h3>概要：</h3><br>本文详细讲解了在Java中使用LinkedList实现一种可以设置固定大小的线性集合，该集合线程安全，需要达到业务的最优性能。<br><br><a id=\"more\"></a><br><br><h3>1. 缘起</h3><br>最近工作过程中碰到一个做周期性更新排行榜的需求。涉及的数据字段和记录条数非常多。概括如下：<br>1. 数据分布于后台数据库100张数据表中；<br>2. 每张表的数据更新非常快，每天预估数据增量在1W条左右；<br>3. 排行榜的数据生成来源于这100张表中，只取前面100条；<br><br>约束：<br><br>- 数据库服务目前只有一个主从，数据周期性变化，原始数据必须放MySQL持久化，不能放Redis<br>- 尽可能减少数据库连接获取，尽可能减少数据库查询，这些昂贵的资源必须优先保证核心业务<br><br><h3>2. 基本思路</h3><br>如果数据量比较少，我们直接放到一个List然后调用Collections.sort排序即可。但是假如我们的排行榜要求的数据量是1W或者10W，每条记录按1KB的大小计算，那么100张表的数据量就是100<em>10W</em>1KB，服务器内存早就爆表。显然这种方案是不行的。<br><br>我们需要这样一种结构，每次一张数据库表中查出前m条记录，将这m条记录插入到一个容器中，这个容器会自动将这m条记录按大小排序，从另外一张表中查出m条记录，继续放到这个容器，容器依然能保证从大到小存储前m条记录。<br><br>这就好像一个擂台，我们可以设置这个擂台大小。每次放到擂台的选手，经过比赛之后，自动从大到小排好序，如果超过擂台大小，排在后面的选手自动淘汰。新加进来的选手可以来踢馆，最终强者留下。如果擂台大小还有剩余，可以容纳更多的选手。直到达到擂台大小就进入淘汰赛。<br><br>同时，还有一个需求，我们100张表可以用100个线程一次查询出来，因此这个容器必须线程安全。同时，性能要好。<br><br>纵观JDK的集合包，似乎没有现成的数据结构可以用。那是否可以直接使用J.U.C包中线程安全的集合？理论上是可以的。通过组合比如LinkedBlockingQueue，PriorityBlockingQueue或其他线程安全的数据结构。问题是我们还要时刻保持有序，大小固定这两个要求，隐含一个性能要好的隐形需求。如果直接使用线程安全的集合，显然还要额外加锁，两把锁以上的数据结构有可能存在死锁问题。<br><br>与其苦苦死锁寻找JDK给我们的馅饼，还不如自己动手，丰衣足食。即便重复写的轮子不如大师的轮子，但是先写一个放到测试环境跑一跑，只要大流程不出问题，还是不会给公司带来损失，发现小bug后面再慢慢优化就是。<br><br><h3>3. 初步实现</h3><br>首先，这个擂台比如增删频繁，因此使用链式结构是最优选。容器的元素一开始就有序，并且后面新加的元素要有序，使用插入排序是最优选，后面新加元素要找到合适的插入位置。就必定要和容器中的元素打擂，但并没必要一一比赛，因为容器的元素已经是有序的了。这时候使用二分查找寻找待插入元素的位置便是最优解。<br><br>插入：O(1),使用链表，无需移动元素<br>二分查找: O(lgn)<br>遍历集合: O(n)<br><br>我们JDK提供的集合排序会根据数据量规模自动选择排序算法，最优性能是O(nlgn),因为集合中的元素一开始是无序的。因此相比较而言，理论上我们的集合性能上要优于直接使用JDK提供的排序方法。<br><br>元素类型不确定，比较依据也不确定，固定大小可以由使用者设置，一旦设置就不能更改。因此这里必须使用泛型，同时由用户传入一个比较器，可以使用匿名内部类。同时传入一个固定大小。容器内部每添加一个元素前都要判断，当前是否已经达到擂台大小，如果新加入的元素超出了擂台大小，则必须进入淘汰赛，将最小元素淘汰。当然，维护从大到小还是从小到大可以通过比较器的返回值决定，这里我的需求是从大到小。<br><br>综合以上的条件，我们可以动手写代码了。<br><br><h3>4. 核心实现</h3>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArenaList</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\"><span class=\"comment\">/*the arena capacity*/</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> capacity;</div><div class=\"line\"><span class=\"comment\">/*need user to define，int r = compare(e1, e2),when r &gt; 0，e1 &gt; e2,r = 0, e1 = e2, r &lt; 0, e1 &lt; e2*/</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Comparator&lt;E&gt; comparator;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedList&lt;E&gt; values;</div><div class=\"line\"><span class=\"comment\">/*if there is an element in list e1, that e1 equal e2, which e2 is we want to add,</span></div><div class=\"line\"> * if keepNewerElement is false,we will drop e2,else drop e1*/</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> keepNewerElement;</div><div class=\"line\"><span class=\"comment\">/*at this moment,the element count, when eCount &lt; size, we can add new element into list and will not remove the last element*/</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> eCount = <span class=\"number\">0</span>;</div></pre></td></tr></table></figure>\n<p>容器定义的字段如上代码所示，<br>capacity必须在构造函数中传入，一旦初始化之后就不能更改。同时以后可能会实现序列化，虽然现在没有考虑序列化问题。<br>comparator是用户定义的比较器，也必须在构造时初始化。我们约定，调用比较器的compare(e1, e2)比较元素，当返回值r &gt; 0，表示e1 &gt; e2,当r &lt; 0,表示e1 &lt; e2。r = 0则表示元素相等。<br>values是存储元素的最终容器，因为增删频繁，因此使用链表，初始化之后就不能更改；<br>keepNewerElement是这样一个作用，当排在最后的两个元素en和em，如果en = em,em是待加入元素，并且擂台已满，是否用新加入的淘汰旧的。默认这个开关是false。<br>eCount，表示当前容器中添加了多少元素。当擂台没有满时，eCount &lt; size，当擂台满了的时候 eCount = size。这里加了volatile修饰，是为了保证多线程下该变量的可见性。这里不深入探讨Java并发问题，因为这个问题要说清楚可以另开一篇文章来说。简单的说volatile是轻量级同步锁，可能保证变量的可见性但不能保证原子性。同时保证了一些可能引发潜在问题的重排序问题。这些涉及到Java内存模型(JMM)，不在多说。这里没有用J.U.C包下的原子变量是因为我们这里容器的增删也要加锁，为了更好的性能，就没必要CAS自旋消耗性能。</p>\n<p>提供的两个构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArenaList</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity, Comparator&lt;E&gt; comparator)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (capacity &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"size can't be negative number\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"keyword\">this</span>.capacity = capacity;</div><div class=\"line\">       <span class=\"keyword\">this</span>.comparator = comparator;</div><div class=\"line\">       <span class=\"keyword\">this</span>.keepNewerElement = <span class=\"keyword\">false</span>;</div><div class=\"line\">       <span class=\"keyword\">this</span>.values = <span class=\"keyword\">new</span> LinkedList&lt;E&gt;();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>默认keepNewerElement是false，我们也可以自定义为true<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArenaList</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity, Comparator&lt;E&gt; comparator, <span class=\"keyword\">boolean</span> keepNewerElement)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (capacity &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"size can't be negative number\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">this</span>.capacity = capacity;</div><div class=\"line\">    <span class=\"keyword\">this</span>.comparator = comparator;</div><div class=\"line\">    <span class=\"keyword\">this</span>.keepNewerElement = keepNewerElement;</div><div class=\"line\">    <span class=\"keyword\">this</span>.values = <span class=\"keyword\">new</span> LinkedList&lt;E&gt;();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个容器中，凡是涉及到容器的增删操作都要考虑线程安全问题。因此都要加锁。锁的实现也有好多种。比如粗粒度的方法锁，或JDK提供的可重入锁(ReentrantLock)。但隐含的性能要求最好时将临界区保持最小。同时代码简洁，因此这里我选用了synchronized对象锁。以values作为锁对象。</p>\n<p>添加删除元素的部分代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * add e into list with thread-safe</div><div class=\"line\"> * <span class=\"doctag\">@param</span> e</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == e) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Null Element.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (values) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> index = findElementIndex(e);</div><div class=\"line\">        <span class=\"keyword\">if</span> (values.size() &gt;= capacity) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (keepNewerElement &amp;&amp; index &lt;= values.size()) &#123;</div><div class=\"line\">                values.removeLast();</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index &lt; values.size())&#123;</div><div class=\"line\">                <span class=\"comment\">//e is in the middle of this list</span></div><div class=\"line\">                values.removeLast();</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//e is at the end of this list and e equals the minElement, no need to add.</span></div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        values.add(index, e);</div><div class=\"line\">        eCount++;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>删除元素:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * remove e from list with thread-safe</div><div class=\"line\"> * <span class=\"doctag\">@param</span> e</div><div class=\"line\"> * <span class=\"doctag\">@return</span></div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == e) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Null Element.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (values) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(values.remove(e)) &#123;</div><div class=\"line\">            eCount--;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>寻找待插入元素元素采用的算法是二分查找，这个算法原理非常简单，但是陷阱非常多，一不小心就会陷入死循环。我还记得当年我大学毕业处女面BAT中某一家，面试官让我写个二分查找。我三下五除二洋洋洒洒写完了，完全手写，没办法测试。估计当时肯定有bug。反正最终挂了。这个算法还真不是那么简单，代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * find the index of e should be</div><div class=\"line\"> * <span class=\"doctag\">@param</span> e</div><div class=\"line\"> * <span class=\"doctag\">@return</span></div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">findElementIndex</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (values.size() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//values.size() &gt; 0</span></div><div class=\"line\">    E minElement = values.getLast();</div><div class=\"line\">    <span class=\"comment\">//the largest element at the index of 0</span></div><div class=\"line\">    <span class=\"keyword\">int</span> high = values.lastIndexOf(minElement);</div><div class=\"line\">    </div><div class=\"line\">    E maxElement = values.getFirst();</div><div class=\"line\">    <span class=\"comment\">//the least element at the index of values.size() - 1</span></div><div class=\"line\">    <span class=\"keyword\">int</span> low = values.indexOf(maxElement);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (compareTwoElement(minElement, e) &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">//minElement &gt;= e</span></div><div class=\"line\">        index = high + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (compareTwoElement(maxElement, e) &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">//maxElement &lt;= e</span></div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//only one element</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (low == high) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (capacity == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> index;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (compareTwoElement(minElement, e) &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//minElement &gt; e</span></div><div class=\"line\">            index = high + <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">return</span> index;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareTwoElement(minElement, e) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//minElement &lt; e</span></div><div class=\"line\">            <span class=\"keyword\">return</span> index;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//minElement = maxElement = e</span></div><div class=\"line\">            <span class=\"keyword\">return</span> index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//more than one element and e must at the middle of this list,use binary search to find index</span></div><div class=\"line\">    <span class=\"keyword\">int</span> middle = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high) &#123;</div><div class=\"line\">        middle = (low + high) / <span class=\"number\">2</span>;</div><div class=\"line\">        E minddleE = values.get(middle);</div><div class=\"line\">        <span class=\"keyword\">if</span> (compareTwoElement(minddleE, e) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//find it.</span></div><div class=\"line\">            index = middle;</div><div class=\"line\">            <span class=\"keyword\">return</span> index;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> (compareTwoElement(minddleE, e) &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//middleE &gt; e</span></div><div class=\"line\">            low = middle;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//middleE &lt; e</span></div><div class=\"line\">            high = middle;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (high - low == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//if there only two element, e is in the middle of this list,low will never be higher or equal high</span></div><div class=\"line\">            <span class=\"comment\">//at this moment,should check out</span></div><div class=\"line\">            <span class=\"comment\">//[4,2,1],3 need to insert into it or [4,3,1],2 need to insert into it</span></div><div class=\"line\">            <span class=\"keyword\">return</span> low + <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//at this moment,low &gt;= high,and (middle + 1)is we should find</span></div><div class=\"line\">    index = middle + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> index;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里注意的是，容器中，大的元素在index为0，因此low表示大元素，high表示小元素。这点有悖于约定俗称。当只剩一个元素比较时就要特别注意了。</p>\n<h3>5. 总结</h3><br>到这里，基本分析完了。我写过测试用例，尝试过使用100个线程来添加元素。目前业务上似乎没有问题。<br><br>这个容器的原理非常简单，涉及的知识点也不算难。都是大学学过的。但是真正写起来却花费了很多时间。需要想各种测试场景写各种测试代码。到现在我完全没有信心说这个容器没有任何bug。但目前基本能满足我们的业务需求。Java并发是一门非常精深非常有意思的学问。很多时候我们写出的代码功能是符合要求，但是性能上本来可以做到更好的。其中并发就是一门需要丰富的经验和钻研才能写出高并发高性能程序的学问。在这条路上，我才刚刚起步。<br><br>所有代码开源，可以自由使用。欢迎提出bug或更好的意见。特别是并发优化部分。<br><br>源码下载：<a href=\"https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java\" title=\"https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java\" target=\"_blank\" rel=\"external\">https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java</a><br><br><h3>6. 参考资料</h3>\n\n<ul>\n<li><a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/util/LinkedList.java#LinkedList\" target=\"_blank\" rel=\"external\">http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/util/LinkedList.java#LinkedList</a></li>\n</ul>\n","excerpt":"<h3>概要：</h3><br>本文详细讲解了在Java中使用LinkedList实现一种可以设置固定大小的线性集合，该集合线程安全，需要达到业务的最优性能。<br><br>","more":"<br><br><h3>1. 缘起</h3><br>最近工作过程中碰到一个做周期性更新排行榜的需求。涉及的数据字段和记录条数非常多。概括如下：<br>1. 数据分布于后台数据库100张数据表中；<br>2. 每张表的数据更新非常快，每天预估数据增量在1W条左右；<br>3. 排行榜的数据生成来源于这100张表中，只取前面100条；<br><br>约束：<br><br>- 数据库服务目前只有一个主从，数据周期性变化，原始数据必须放MySQL持久化，不能放Redis<br>- 尽可能减少数据库连接获取，尽可能减少数据库查询，这些昂贵的资源必须优先保证核心业务<br><br><h3>2. 基本思路</h3><br>如果数据量比较少，我们直接放到一个List然后调用Collections.sort排序即可。但是假如我们的排行榜要求的数据量是1W或者10W，每条记录按1KB的大小计算，那么100张表的数据量就是100<em>10W</em>1KB，服务器内存早就爆表。显然这种方案是不行的。<br><br>我们需要这样一种结构，每次一张数据库表中查出前m条记录，将这m条记录插入到一个容器中，这个容器会自动将这m条记录按大小排序，从另外一张表中查出m条记录，继续放到这个容器，容器依然能保证从大到小存储前m条记录。<br><br>这就好像一个擂台，我们可以设置这个擂台大小。每次放到擂台的选手，经过比赛之后，自动从大到小排好序，如果超过擂台大小，排在后面的选手自动淘汰。新加进来的选手可以来踢馆，最终强者留下。如果擂台大小还有剩余，可以容纳更多的选手。直到达到擂台大小就进入淘汰赛。<br><br>同时，还有一个需求，我们100张表可以用100个线程一次查询出来，因此这个容器必须线程安全。同时，性能要好。<br><br>纵观JDK的集合包，似乎没有现成的数据结构可以用。那是否可以直接使用J.U.C包中线程安全的集合？理论上是可以的。通过组合比如LinkedBlockingQueue，PriorityBlockingQueue或其他线程安全的数据结构。问题是我们还要时刻保持有序，大小固定这两个要求，隐含一个性能要好的隐形需求。如果直接使用线程安全的集合，显然还要额外加锁，两把锁以上的数据结构有可能存在死锁问题。<br><br>与其苦苦死锁寻找JDK给我们的馅饼，还不如自己动手，丰衣足食。即便重复写的轮子不如大师的轮子，但是先写一个放到测试环境跑一跑，只要大流程不出问题，还是不会给公司带来损失，发现小bug后面再慢慢优化就是。<br><br><h3>3. 初步实现</h3><br>首先，这个擂台比如增删频繁，因此使用链式结构是最优选。容器的元素一开始就有序，并且后面新加的元素要有序，使用插入排序是最优选，后面新加元素要找到合适的插入位置。就必定要和容器中的元素打擂，但并没必要一一比赛，因为容器的元素已经是有序的了。这时候使用二分查找寻找待插入元素的位置便是最优解。<br><br>插入：O(1),使用链表，无需移动元素<br>二分查找: O(lgn)<br>遍历集合: O(n)<br><br>我们JDK提供的集合排序会根据数据量规模自动选择排序算法，最优性能是O(nlgn),因为集合中的元素一开始是无序的。因此相比较而言，理论上我们的集合性能上要优于直接使用JDK提供的排序方法。<br><br>元素类型不确定，比较依据也不确定，固定大小可以由使用者设置，一旦设置就不能更改。因此这里必须使用泛型，同时由用户传入一个比较器，可以使用匿名内部类。同时传入一个固定大小。容器内部每添加一个元素前都要判断，当前是否已经达到擂台大小，如果新加入的元素超出了擂台大小，则必须进入淘汰赛，将最小元素淘汰。当然，维护从大到小还是从小到大可以通过比较器的返回值决定，这里我的需求是从大到小。<br><br>综合以上的条件，我们可以动手写代码了。<br><br><h3>4. 核心实现</h3>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArenaList</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\"><span class=\"comment\">/*the arena capacity*/</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> capacity;</div><div class=\"line\"><span class=\"comment\">/*need user to define，int r = compare(e1, e2),when r &gt; 0，e1 &gt; e2,r = 0, e1 = e2, r &lt; 0, e1 &lt; e2*/</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Comparator&lt;E&gt; comparator;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedList&lt;E&gt; values;</div><div class=\"line\"><span class=\"comment\">/*if there is an element in list e1, that e1 equal e2, which e2 is we want to add,</div><div class=\"line\"> * if keepNewerElement is false,we will drop e2,else drop e1*/</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> keepNewerElement;</div><div class=\"line\"><span class=\"comment\">/*at this moment,the element count, when eCount &lt; size, we can add new element into list and will not remove the last element*/</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> eCount = <span class=\"number\">0</span>;</div></pre></td></tr></table></figure>\n<p>容器定义的字段如上代码所示，<br>capacity必须在构造函数中传入，一旦初始化之后就不能更改。同时以后可能会实现序列化，虽然现在没有考虑序列化问题。<br>comparator是用户定义的比较器，也必须在构造时初始化。我们约定，调用比较器的compare(e1, e2)比较元素，当返回值r &gt; 0，表示e1 &gt; e2,当r &lt; 0,表示e1 &lt; e2。r = 0则表示元素相等。<br>values是存储元素的最终容器，因为增删频繁，因此使用链表，初始化之后就不能更改；<br>keepNewerElement是这样一个作用，当排在最后的两个元素en和em，如果en = em,em是待加入元素，并且擂台已满，是否用新加入的淘汰旧的。默认这个开关是false。<br>eCount，表示当前容器中添加了多少元素。当擂台没有满时，eCount &lt; size，当擂台满了的时候 eCount = size。这里加了volatile修饰，是为了保证多线程下该变量的可见性。这里不深入探讨Java并发问题，因为这个问题要说清楚可以另开一篇文章来说。简单的说volatile是轻量级同步锁，可能保证变量的可见性但不能保证原子性。同时保证了一些可能引发潜在问题的重排序问题。这些涉及到Java内存模型(JMM)，不在多说。这里没有用J.U.C包下的原子变量是因为我们这里容器的增删也要加锁，为了更好的性能，就没必要CAS自旋消耗性能。</p>\n<p>提供的两个构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArenaList</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity, Comparator&lt;E&gt; comparator)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (capacity &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"size can't be negative number\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"keyword\">this</span>.capacity = capacity;</div><div class=\"line\">       <span class=\"keyword\">this</span>.comparator = comparator;</div><div class=\"line\">       <span class=\"keyword\">this</span>.keepNewerElement = <span class=\"keyword\">false</span>;</div><div class=\"line\">       <span class=\"keyword\">this</span>.values = <span class=\"keyword\">new</span> LinkedList&lt;E&gt;();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>默认keepNewerElement是false，我们也可以自定义为true<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArenaList</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity, Comparator&lt;E&gt; comparator, <span class=\"keyword\">boolean</span> keepNewerElement)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (capacity &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"size can't be negative number\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">this</span>.capacity = capacity;</div><div class=\"line\">    <span class=\"keyword\">this</span>.comparator = comparator;</div><div class=\"line\">    <span class=\"keyword\">this</span>.keepNewerElement = keepNewerElement;</div><div class=\"line\">    <span class=\"keyword\">this</span>.values = <span class=\"keyword\">new</span> LinkedList&lt;E&gt;();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个容器中，凡是涉及到容器的增删操作都要考虑线程安全问题。因此都要加锁。锁的实现也有好多种。比如粗粒度的方法锁，或JDK提供的可重入锁(ReentrantLock)。但隐含的性能要求最好时将临界区保持最小。同时代码简洁，因此这里我选用了synchronized对象锁。以values作为锁对象。</p>\n<p>添加删除元素的部分代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * add e into list with thread-safe</div><div class=\"line\"> * <span class=\"doctag\">@param</span> e</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == e) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Null Element.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (values) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> index = findElementIndex(e);</div><div class=\"line\">        <span class=\"keyword\">if</span> (values.size() &gt;= capacity) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (keepNewerElement &amp;&amp; index &lt;= values.size()) &#123;</div><div class=\"line\">                values.removeLast();</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index &lt; values.size())&#123;</div><div class=\"line\">                <span class=\"comment\">//e is in the middle of this list</span></div><div class=\"line\">                values.removeLast();</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//e is at the end of this list and e equals the minElement, no need to add.</span></div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        values.add(index, e);</div><div class=\"line\">        eCount++;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>删除元素:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * remove e from list with thread-safe</div><div class=\"line\"> * <span class=\"doctag\">@param</span> e</div><div class=\"line\"> * <span class=\"doctag\">@return</span></div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == e) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Null Element.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (values) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(values.remove(e)) &#123;</div><div class=\"line\">            eCount--;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>寻找待插入元素元素采用的算法是二分查找，这个算法原理非常简单，但是陷阱非常多，一不小心就会陷入死循环。我还记得当年我大学毕业处女面BAT中某一家，面试官让我写个二分查找。我三下五除二洋洋洒洒写完了，完全手写，没办法测试。估计当时肯定有bug。反正最终挂了。这个算法还真不是那么简单，代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * find the index of e should be</div><div class=\"line\"> * <span class=\"doctag\">@param</span> e</div><div class=\"line\"> * <span class=\"doctag\">@return</span></div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">findElementIndex</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (values.size() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//values.size() &gt; 0</span></div><div class=\"line\">    E minElement = values.getLast();</div><div class=\"line\">    <span class=\"comment\">//the largest element at the index of 0</span></div><div class=\"line\">    <span class=\"keyword\">int</span> high = values.lastIndexOf(minElement);</div><div class=\"line\">    </div><div class=\"line\">    E maxElement = values.getFirst();</div><div class=\"line\">    <span class=\"comment\">//the least element at the index of values.size() - 1</span></div><div class=\"line\">    <span class=\"keyword\">int</span> low = values.indexOf(maxElement);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (compareTwoElement(minElement, e) &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">//minElement &gt;= e</span></div><div class=\"line\">        index = high + <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (compareTwoElement(maxElement, e) &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">//maxElement &lt;= e</span></div><div class=\"line\">        <span class=\"keyword\">return</span> index;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//only one element</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (low == high) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (capacity == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> index;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (compareTwoElement(minElement, e) &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//minElement &gt; e</span></div><div class=\"line\">            index = high + <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">return</span> index;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareTwoElement(minElement, e) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//minElement &lt; e</span></div><div class=\"line\">            <span class=\"keyword\">return</span> index;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//minElement = maxElement = e</span></div><div class=\"line\">            <span class=\"keyword\">return</span> index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//more than one element and e must at the middle of this list,use binary search to find index</span></div><div class=\"line\">    <span class=\"keyword\">int</span> middle = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high) &#123;</div><div class=\"line\">        middle = (low + high) / <span class=\"number\">2</span>;</div><div class=\"line\">        E minddleE = values.get(middle);</div><div class=\"line\">        <span class=\"keyword\">if</span> (compareTwoElement(minddleE, e) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//find it.</span></div><div class=\"line\">            index = middle;</div><div class=\"line\">            <span class=\"keyword\">return</span> index;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span> (compareTwoElement(minddleE, e) &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//middleE &gt; e</span></div><div class=\"line\">            low = middle;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//middleE &lt; e</span></div><div class=\"line\">            high = middle;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (high - low == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//if there only two element, e is in the middle of this list,low will never be higher or equal high</span></div><div class=\"line\">            <span class=\"comment\">//at this moment,should check out</span></div><div class=\"line\">            <span class=\"comment\">//[4,2,1],3 need to insert into it or [4,3,1],2 need to insert into it</span></div><div class=\"line\">            <span class=\"keyword\">return</span> low + <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//at this moment,low &gt;= high,and (middle + 1)is we should find</span></div><div class=\"line\">    index = middle + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> index;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里注意的是，容器中，大的元素在index为0，因此low表示大元素，high表示小元素。这点有悖于约定俗称。当只剩一个元素比较时就要特别注意了。</p>\n<h3>5. 总结</h3><br>到这里，基本分析完了。我写过测试用例，尝试过使用100个线程来添加元素。目前业务上似乎没有问题。<br><br>这个容器的原理非常简单，涉及的知识点也不算难。都是大学学过的。但是真正写起来却花费了很多时间。需要想各种测试场景写各种测试代码。到现在我完全没有信心说这个容器没有任何bug。但目前基本能满足我们的业务需求。Java并发是一门非常精深非常有意思的学问。很多时候我们写出的代码功能是符合要求，但是性能上本来可以做到更好的。其中并发就是一门需要丰富的经验和钻研才能写出高并发高性能程序的学问。在这条路上，我才刚刚起步。<br><br>所有代码开源，可以自由使用。欢迎提出bug或更好的意见。特别是并发优化部分。<br><br>源码下载：<a href=\"https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java\" title=\"https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java\">https://github.com/34benma/MyTools/blob/master/src/com/util/ArenaList.java</a><br><br><h3>6. 参考资料</h3>\n\n<ul>\n<li><a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/util/LinkedList.java#LinkedList\">http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/util/LinkedList.java#LinkedList</a></li>\n</ul>"},{"title":"良好的开始","date":"2016-07-06T05:23:55.000Z","_content":"我的个人博客终于搭建好了~ :)\n\n我承认我不是一个特别爱写作的人。大学毕业前还时不时地写点技术文章，或在QQ空间发点感悟或者牢骚~工作之后，就很少写东西了。不是因为工作太忙，其实是因为患上了拖延症。\n\n<!--more-->\n\n曾经几次想写一个自己的博客网站。觉得这才体现我攻(cheng)城(xu)狮(yuan)身份的优越性，尝试过几回，最终都半途而废了。这件事情想起来简单其实做起来还真不简单。\n\n一次偶然的机会发现了[Hexo](https://hexo.io/zh-cn/)，了解到可以将一个静态网站免费部署到[github](https://github.com/34benma/34benma.github.io)上。终于搭建好了自己的博客网站~\n\n在这个网站上，我将分享我再技术学习和平常工作中的一些有价值的东西。在孤单无聊(单身狗的日常生活)的时候写一写心情和人生感悟吧。\n\n希望以这个网站为起点，能更多地激励我，鞭策我在技术这条路上越走越远，分享更多的有价值的东西。\n\n这是一个良好的开始~\n\n","source":"_posts/good_start20160706.md","raw":"---\ntitle: 良好的开始\ncategories: 随笔\ndate: 2016-07-06 13:23:55\ntags: \n  - 心情\n  - 随笔\n---\n我的个人博客终于搭建好了~ :)\n\n我承认我不是一个特别爱写作的人。大学毕业前还时不时地写点技术文章，或在QQ空间发点感悟或者牢骚~工作之后，就很少写东西了。不是因为工作太忙，其实是因为患上了拖延症。\n\n<!--more-->\n\n曾经几次想写一个自己的博客网站。觉得这才体现我攻(cheng)城(xu)狮(yuan)身份的优越性，尝试过几回，最终都半途而废了。这件事情想起来简单其实做起来还真不简单。\n\n一次偶然的机会发现了[Hexo](https://hexo.io/zh-cn/)，了解到可以将一个静态网站免费部署到[github](https://github.com/34benma/34benma.github.io)上。终于搭建好了自己的博客网站~\n\n在这个网站上，我将分享我再技术学习和平常工作中的一些有价值的东西。在孤单无聊(单身狗的日常生活)的时候写一写心情和人生感悟吧。\n\n希望以这个网站为起点，能更多地激励我，鞭策我在技术这条路上越走越远，分享更多的有价值的东西。\n\n这是一个良好的开始~\n\n","slug":"good_start20160706","published":1,"updated":"2016-07-16T14:52:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf46001h1atit0dctd1l","content":"<p>我的个人博客终于搭建好了~ :)</p>\n<p>我承认我不是一个特别爱写作的人。大学毕业前还时不时地写点技术文章，或在QQ空间发点感悟或者牢骚~工作之后，就很少写东西了。不是因为工作太忙，其实是因为患上了拖延症。</p>\n<a id=\"more\"></a>\n<p>曾经几次想写一个自己的博客网站。觉得这才体现我攻(cheng)城(xu)狮(yuan)身份的优越性，尝试过几回，最终都半途而废了。这件事情想起来简单其实做起来还真不简单。</p>\n<p>一次偶然的机会发现了<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"external\">Hexo</a>，了解到可以将一个静态网站免费部署到<a href=\"https://github.com/34benma/34benma.github.io\" target=\"_blank\" rel=\"external\">github</a>上。终于搭建好了自己的博客网站~</p>\n<p>在这个网站上，我将分享我再技术学习和平常工作中的一些有价值的东西。在孤单无聊(单身狗的日常生活)的时候写一写心情和人生感悟吧。</p>\n<p>希望以这个网站为起点，能更多地激励我，鞭策我在技术这条路上越走越远，分享更多的有价值的东西。</p>\n<p>这是一个良好的开始~</p>\n","excerpt":"<p>我的个人博客终于搭建好了~ :)</p>\n<p>我承认我不是一个特别爱写作的人。大学毕业前还时不时地写点技术文章，或在QQ空间发点感悟或者牢骚~工作之后，就很少写东西了。不是因为工作太忙，其实是因为患上了拖延症。</p>","more":"<p>曾经几次想写一个自己的博客网站。觉得这才体现我攻(cheng)城(xu)狮(yuan)身份的优越性，尝试过几回，最终都半途而废了。这件事情想起来简单其实做起来还真不简单。</p>\n<p>一次偶然的机会发现了<a href=\"https://hexo.io/zh-cn/\">Hexo</a>，了解到可以将一个静态网站免费部署到<a href=\"https://github.com/34benma/34benma.github.io\">github</a>上。终于搭建好了自己的博客网站~</p>\n<p>在这个网站上，我将分享我再技术学习和平常工作中的一些有价值的东西。在孤单无聊(单身狗的日常生活)的时候写一写心情和人生感悟吧。</p>\n<p>希望以这个网站为起点，能更多地激励我，鞭策我在技术这条路上越走越远，分享更多的有价值的东西。</p>\n<p>这是一个良好的开始~</p>"},{"title":"Java中当我们new一个对象时我们是在干啥？","date":"2016-07-08T09:48:56.000Z","_content":"{% centerquote %}Java程序员不需要女票，因为他们每天都在面向对象...{% endcenterquote %}\n\nJava是一门面向对象的语言。如果不借助于Spring等这类IoC容器，我们在获得一个对象实例的时候通常都是用new这个关键字了（当然还可以用反射）。相比每一个Javaer都知道这个关键字是做什么用的。当我们使用它new一个新对象实例时，JVM到底为我们做了啥？\n\n<!--more-->\n\n当我们写完一个xxx.java源文件后，java编译器会帮我们生成xxx.class文件。这个文件就是虚拟机的输入。如果这个class文件代表一个普通的对象，当我们new的时候事实上就是初始化这个xxx.class文件。因此一句话概括当我们new一个对象的时候就是初始化一个对象实例。\n\n对于程序员，一个new就可以获得一个对象实例，但是对于Java虚拟机来说，前前后后做了大量的工作。本文将简单分析一下Java虚拟机的类装载机制。\n\n<h2>Java虚拟机的类装载过程</h2>\n\n![类的生命周期](http://o9z6i1a1s.bkt.clouddn.com/life_of_a_class.png)\n\n当我们写完一个Java源文件编译成一个.class文件的时候，如果加载进JVM，就要经历一个上图所示的生命周期。当虚拟机遇到一条new指令的时候，首先去常量池定位这个类的符号引用，如果这个类已经被加载，解析和初始化了，则直接使用(比如单例对象)。否则，就执行上述过程。当一个类对象之前已经实例化过了，再次生成一个新对象时只需要初始化了。\n\n<h3>类的加载</h3>\n\n类的加载是通过类加载器(ClassLoader)来完成。类加载器通过一个类的全限定名来获取这个类的二进制流，也就是那个.class文件流，将一些类的静态信息(字段，方法名，常量等)放到方法区，生成这个类的Class对象。事实上，虚拟机并不一定要求这个class文件必须在本地，也没有要求必须是java语言编写的(Groovy等也可以)。这个类可以来源于网络，也可以来源于数据库，甚至我们还可以手动写一个符合规范的class文件(CGlib)。当把这个class文件加载进虚拟机就完成了类加载的过程。\n\n<h3>验证阶段</h3>\n\n因为class文件可以通过各种途径获取，还可以不使用java语言来编写，在类加载的过程中怎么保证加载的class文件是合符规范并且不会在运行过程中引起JVM宕机呢？这就需要一个验证阶段。验证阶段完成了class文件格式的验证(比如魔数，版本号等)，元数据的验证(类的继承合法性)，字节码验证，符号引用验证等。当一个class文件完全通过JVM检验合格之后就可以进入准备阶段了。\n\n<h3>准备阶段</h3>\n\n准备阶段做的事情很简单。就是为这个类的一些类变量(static)在方法区分配内存但没有初始化(初始化都是在初始化阶段完成)。但是常量字段除外（static final）。这些字段在这个阶段已经赋值并且放入方法区的常量池了。\n\n<h3>解析阶段</h3>\n\n类的解析是虚拟机做的最复杂的一项工作。它会将一些符号引用(虚地址)替换为直接引用(实际地址)，完成类的继承关系的解析，完成字段和方法的解析。还会进行各种权限的验证。当一个类的各种符号引用被替换为了直接引用。它的各种父类，接口，字段，方法完成了解析。这个类就可以进入初始化阶段了。\n\n<h3>初始化阶段</h3>\n\n类的初始化阶段简单的说就是执行一个< init>方法。这个方法是Java虚拟机帮我们生成的。是在构造函数执行(构造函数是程序员主动调用的)前由java虚拟机调用执行。目的在于完成类实例各个变量的初始化赋值，静态代码块的执行等。当然，如果一个类没有静态代码块，也没有变量赋值，那么这个< init>方法什么也不用干了。我们可以写一个类，它什么也不干，然后反编译看下如果加载这个类虚拟机将执行哪些指令。\n\n    class TestObject {\n   \n    }\n\njavap一下，可以看到以下输出：\n\n![Class反汇编](http://o9z6i1a1s.bkt.clouddn.com/init_class.png)\n\n这个类啥事也不干，因此如果虚拟机加载这个类，还是会调用<init>方法，但是这个方法事实上啥事也没有干。\n\n这个时候，调用new将生产一个对象实例，这个实例的内存占用是在Java堆上。这里有一个问题，假如我们有个线程A在堆内存地址为0x123的地方实例化一个对象，但是还没有实例化完成，这时线程B也想在堆内存地址为0x123的地方实例化一个对象，会不会把线程A还没有实例化完成的对象信息给抹掉？\n\n<h3>如何保证线程安全的类初始化</h3>\n\n一种很简单的办法是同步化。虚拟机可以采用CAS操作(在并发系列中将讲到CAS操作)来保证原子化，还有一种方式是将分配对象堆内存的工作按照线程划分在不同的线程空间中进行。这个线程空间的名字就叫做TLAB(Thread Local Allocation Buffer)。我们看到java虚拟机参数中有一些参数是跟TLAB有关的。\n\n```\n\t-XX:+UseTLAB //是否开启TLAB，JDK1.4之前是false\n```\n```\n\t-XX:TLABWasteTargetPercent //TLAB占整个eden区的百分比\n```\n```\n\t-XX:+PrintTLAB //查看TLAB的使用情况\n```\n\n当堆内存分配完了，< init>方法也执行完了，一个对象就初始化完成了。这时候就开始执行构造函数，对象就到了程序员手里，可以被程序员使用了。\n\n\n\n*参考文献*\n*《深入理解Java虚拟机》 --周志明著*\n*http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#largepages*\n\n","source":"_posts/java-new-anas-20160708.md","raw":"---\ntitle: Java中当我们new一个对象时我们是在干啥？\ndate: 2016-07-08 17:48:56\ntags:\n  - JVM\n  - 类加载机制\ncategories: 深入理解\n---\n{% centerquote %}Java程序员不需要女票，因为他们每天都在面向对象...{% endcenterquote %}\n\nJava是一门面向对象的语言。如果不借助于Spring等这类IoC容器，我们在获得一个对象实例的时候通常都是用new这个关键字了（当然还可以用反射）。相比每一个Javaer都知道这个关键字是做什么用的。当我们使用它new一个新对象实例时，JVM到底为我们做了啥？\n\n<!--more-->\n\n当我们写完一个xxx.java源文件后，java编译器会帮我们生成xxx.class文件。这个文件就是虚拟机的输入。如果这个class文件代表一个普通的对象，当我们new的时候事实上就是初始化这个xxx.class文件。因此一句话概括当我们new一个对象的时候就是初始化一个对象实例。\n\n对于程序员，一个new就可以获得一个对象实例，但是对于Java虚拟机来说，前前后后做了大量的工作。本文将简单分析一下Java虚拟机的类装载机制。\n\n<h2>Java虚拟机的类装载过程</h2>\n\n![类的生命周期](http://o9z6i1a1s.bkt.clouddn.com/life_of_a_class.png)\n\n当我们写完一个Java源文件编译成一个.class文件的时候，如果加载进JVM，就要经历一个上图所示的生命周期。当虚拟机遇到一条new指令的时候，首先去常量池定位这个类的符号引用，如果这个类已经被加载，解析和初始化了，则直接使用(比如单例对象)。否则，就执行上述过程。当一个类对象之前已经实例化过了，再次生成一个新对象时只需要初始化了。\n\n<h3>类的加载</h3>\n\n类的加载是通过类加载器(ClassLoader)来完成。类加载器通过一个类的全限定名来获取这个类的二进制流，也就是那个.class文件流，将一些类的静态信息(字段，方法名，常量等)放到方法区，生成这个类的Class对象。事实上，虚拟机并不一定要求这个class文件必须在本地，也没有要求必须是java语言编写的(Groovy等也可以)。这个类可以来源于网络，也可以来源于数据库，甚至我们还可以手动写一个符合规范的class文件(CGlib)。当把这个class文件加载进虚拟机就完成了类加载的过程。\n\n<h3>验证阶段</h3>\n\n因为class文件可以通过各种途径获取，还可以不使用java语言来编写，在类加载的过程中怎么保证加载的class文件是合符规范并且不会在运行过程中引起JVM宕机呢？这就需要一个验证阶段。验证阶段完成了class文件格式的验证(比如魔数，版本号等)，元数据的验证(类的继承合法性)，字节码验证，符号引用验证等。当一个class文件完全通过JVM检验合格之后就可以进入准备阶段了。\n\n<h3>准备阶段</h3>\n\n准备阶段做的事情很简单。就是为这个类的一些类变量(static)在方法区分配内存但没有初始化(初始化都是在初始化阶段完成)。但是常量字段除外（static final）。这些字段在这个阶段已经赋值并且放入方法区的常量池了。\n\n<h3>解析阶段</h3>\n\n类的解析是虚拟机做的最复杂的一项工作。它会将一些符号引用(虚地址)替换为直接引用(实际地址)，完成类的继承关系的解析，完成字段和方法的解析。还会进行各种权限的验证。当一个类的各种符号引用被替换为了直接引用。它的各种父类，接口，字段，方法完成了解析。这个类就可以进入初始化阶段了。\n\n<h3>初始化阶段</h3>\n\n类的初始化阶段简单的说就是执行一个< init>方法。这个方法是Java虚拟机帮我们生成的。是在构造函数执行(构造函数是程序员主动调用的)前由java虚拟机调用执行。目的在于完成类实例各个变量的初始化赋值，静态代码块的执行等。当然，如果一个类没有静态代码块，也没有变量赋值，那么这个< init>方法什么也不用干了。我们可以写一个类，它什么也不干，然后反编译看下如果加载这个类虚拟机将执行哪些指令。\n\n    class TestObject {\n   \n    }\n\njavap一下，可以看到以下输出：\n\n![Class反汇编](http://o9z6i1a1s.bkt.clouddn.com/init_class.png)\n\n这个类啥事也不干，因此如果虚拟机加载这个类，还是会调用<init>方法，但是这个方法事实上啥事也没有干。\n\n这个时候，调用new将生产一个对象实例，这个实例的内存占用是在Java堆上。这里有一个问题，假如我们有个线程A在堆内存地址为0x123的地方实例化一个对象，但是还没有实例化完成，这时线程B也想在堆内存地址为0x123的地方实例化一个对象，会不会把线程A还没有实例化完成的对象信息给抹掉？\n\n<h3>如何保证线程安全的类初始化</h3>\n\n一种很简单的办法是同步化。虚拟机可以采用CAS操作(在并发系列中将讲到CAS操作)来保证原子化，还有一种方式是将分配对象堆内存的工作按照线程划分在不同的线程空间中进行。这个线程空间的名字就叫做TLAB(Thread Local Allocation Buffer)。我们看到java虚拟机参数中有一些参数是跟TLAB有关的。\n\n```\n\t-XX:+UseTLAB //是否开启TLAB，JDK1.4之前是false\n```\n```\n\t-XX:TLABWasteTargetPercent //TLAB占整个eden区的百分比\n```\n```\n\t-XX:+PrintTLAB //查看TLAB的使用情况\n```\n\n当堆内存分配完了，< init>方法也执行完了，一个对象就初始化完成了。这时候就开始执行构造函数，对象就到了程序员手里，可以被程序员使用了。\n\n\n\n*参考文献*\n*《深入理解Java虚拟机》 --周志明著*\n*http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#largepages*\n\n","slug":"java-new-anas-20160708","published":1,"updated":"2016-07-16T14:52:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf4c001k1atimglnfaaz","content":"<blockquote class=\"blockquote-center\"><p>Java程序员不需要女票，因为他们每天都在面向对象…</p>\n</blockquote>\n<p>Java是一门面向对象的语言。如果不借助于Spring等这类IoC容器，我们在获得一个对象实例的时候通常都是用new这个关键字了（当然还可以用反射）。相比每一个Javaer都知道这个关键字是做什么用的。当我们使用它new一个新对象实例时，JVM到底为我们做了啥？</p>\n<a id=\"more\"></a>\n<p>当我们写完一个xxx.java源文件后，java编译器会帮我们生成xxx.class文件。这个文件就是虚拟机的输入。如果这个class文件代表一个普通的对象，当我们new的时候事实上就是初始化这个xxx.class文件。因此一句话概括当我们new一个对象的时候就是初始化一个对象实例。</p>\n<p>对于程序员，一个new就可以获得一个对象实例，但是对于Java虚拟机来说，前前后后做了大量的工作。本文将简单分析一下Java虚拟机的类装载机制。</p>\n<h2>Java虚拟机的类装载过程</h2>\n\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/life_of_a_class.png\" alt=\"类的生命周期\"></p>\n<p>当我们写完一个Java源文件编译成一个.class文件的时候，如果加载进JVM，就要经历一个上图所示的生命周期。当虚拟机遇到一条new指令的时候，首先去常量池定位这个类的符号引用，如果这个类已经被加载，解析和初始化了，则直接使用(比如单例对象)。否则，就执行上述过程。当一个类对象之前已经实例化过了，再次生成一个新对象时只需要初始化了。</p>\n<h3>类的加载</h3>\n\n<p>类的加载是通过类加载器(ClassLoader)来完成。类加载器通过一个类的全限定名来获取这个类的二进制流，也就是那个.class文件流，将一些类的静态信息(字段，方法名，常量等)放到方法区，生成这个类的Class对象。事实上，虚拟机并不一定要求这个class文件必须在本地，也没有要求必须是java语言编写的(Groovy等也可以)。这个类可以来源于网络，也可以来源于数据库，甚至我们还可以手动写一个符合规范的class文件(CGlib)。当把这个class文件加载进虚拟机就完成了类加载的过程。</p>\n<h3>验证阶段</h3>\n\n<p>因为class文件可以通过各种途径获取，还可以不使用java语言来编写，在类加载的过程中怎么保证加载的class文件是合符规范并且不会在运行过程中引起JVM宕机呢？这就需要一个验证阶段。验证阶段完成了class文件格式的验证(比如魔数，版本号等)，元数据的验证(类的继承合法性)，字节码验证，符号引用验证等。当一个class文件完全通过JVM检验合格之后就可以进入准备阶段了。</p>\n<h3>准备阶段</h3>\n\n<p>准备阶段做的事情很简单。就是为这个类的一些类变量(static)在方法区分配内存但没有初始化(初始化都是在初始化阶段完成)。但是常量字段除外（static final）。这些字段在这个阶段已经赋值并且放入方法区的常量池了。</p>\n<h3>解析阶段</h3>\n\n<p>类的解析是虚拟机做的最复杂的一项工作。它会将一些符号引用(虚地址)替换为直接引用(实际地址)，完成类的继承关系的解析，完成字段和方法的解析。还会进行各种权限的验证。当一个类的各种符号引用被替换为了直接引用。它的各种父类，接口，字段，方法完成了解析。这个类就可以进入初始化阶段了。</p>\n<h3>初始化阶段</h3>\n\n<p>类的初始化阶段简单的说就是执行一个&lt; init&gt;方法。这个方法是Java虚拟机帮我们生成的。是在构造函数执行(构造函数是程序员主动调用的)前由java虚拟机调用执行。目的在于完成类实例各个变量的初始化赋值，静态代码块的执行等。当然，如果一个类没有静态代码块，也没有变量赋值，那么这个&lt; init&gt;方法什么也不用干了。我们可以写一个类，它什么也不干，然后反编译看下如果加载这个类虚拟机将执行哪些指令。</p>\n<pre><code>class TestObject {\n\n}\n</code></pre><p>javap一下，可以看到以下输出：</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/init_class.png\" alt=\"Class反汇编\"></p>\n<p>这个类啥事也不干，因此如果虚拟机加载这个类，还是会调用<init>方法，但是这个方法事实上啥事也没有干。</init></p>\n<p>这个时候，调用new将生产一个对象实例，这个实例的内存占用是在Java堆上。这里有一个问题，假如我们有个线程A在堆内存地址为0x123的地方实例化一个对象，但是还没有实例化完成，这时线程B也想在堆内存地址为0x123的地方实例化一个对象，会不会把线程A还没有实例化完成的对象信息给抹掉？</p>\n<h3>如何保证线程安全的类初始化</h3>\n\n<p>一种很简单的办法是同步化。虚拟机可以采用CAS操作(在并发系列中将讲到CAS操作)来保证原子化，还有一种方式是将分配对象堆内存的工作按照线程划分在不同的线程空间中进行。这个线程空间的名字就叫做TLAB(Thread Local Allocation Buffer)。我们看到java虚拟机参数中有一些参数是跟TLAB有关的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-XX:+UseTLAB //是否开启TLAB，JDK1.4之前是false</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-XX:TLABWasteTargetPercent //TLAB占整个eden区的百分比</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-XX:+PrintTLAB //查看TLAB的使用情况</div></pre></td></tr></table></figure>\n<p>当堆内存分配完了，&lt; init&gt;方法也执行完了，一个对象就初始化完成了。这时候就开始执行构造函数，对象就到了程序员手里，可以被程序员使用了。</p>\n<p><em>参考文献</em><br><em>《深入理解Java虚拟机》 –周志明著</em><br><em><a href=\"http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#largepages\" target=\"_blank\" rel=\"external\">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#largepages</a></em></p>\n","excerpt":"<blockquote class=\"blockquote-center\"><p>Java程序员不需要女票，因为他们每天都在面向对象…</p>\n</blockquote>\n<p>Java是一门面向对象的语言。如果不借助于Spring等这类IoC容器，我们在获得一个对象实例的时候通常都是用new这个关键字了（当然还可以用反射）。相比每一个Javaer都知道这个关键字是做什么用的。当我们使用它new一个新对象实例时，JVM到底为我们做了啥？</p>","more":"<p>当我们写完一个xxx.java源文件后，java编译器会帮我们生成xxx.class文件。这个文件就是虚拟机的输入。如果这个class文件代表一个普通的对象，当我们new的时候事实上就是初始化这个xxx.class文件。因此一句话概括当我们new一个对象的时候就是初始化一个对象实例。</p>\n<p>对于程序员，一个new就可以获得一个对象实例，但是对于Java虚拟机来说，前前后后做了大量的工作。本文将简单分析一下Java虚拟机的类装载机制。</p>\n<h2>Java虚拟机的类装载过程</h2>\n\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/life_of_a_class.png\" alt=\"类的生命周期\"></p>\n<p>当我们写完一个Java源文件编译成一个.class文件的时候，如果加载进JVM，就要经历一个上图所示的生命周期。当虚拟机遇到一条new指令的时候，首先去常量池定位这个类的符号引用，如果这个类已经被加载，解析和初始化了，则直接使用(比如单例对象)。否则，就执行上述过程。当一个类对象之前已经实例化过了，再次生成一个新对象时只需要初始化了。</p>\n<h3>类的加载</h3>\n\n<p>类的加载是通过类加载器(ClassLoader)来完成。类加载器通过一个类的全限定名来获取这个类的二进制流，也就是那个.class文件流，将一些类的静态信息(字段，方法名，常量等)放到方法区，生成这个类的Class对象。事实上，虚拟机并不一定要求这个class文件必须在本地，也没有要求必须是java语言编写的(Groovy等也可以)。这个类可以来源于网络，也可以来源于数据库，甚至我们还可以手动写一个符合规范的class文件(CGlib)。当把这个class文件加载进虚拟机就完成了类加载的过程。</p>\n<h3>验证阶段</h3>\n\n<p>因为class文件可以通过各种途径获取，还可以不使用java语言来编写，在类加载的过程中怎么保证加载的class文件是合符规范并且不会在运行过程中引起JVM宕机呢？这就需要一个验证阶段。验证阶段完成了class文件格式的验证(比如魔数，版本号等)，元数据的验证(类的继承合法性)，字节码验证，符号引用验证等。当一个class文件完全通过JVM检验合格之后就可以进入准备阶段了。</p>\n<h3>准备阶段</h3>\n\n<p>准备阶段做的事情很简单。就是为这个类的一些类变量(static)在方法区分配内存但没有初始化(初始化都是在初始化阶段完成)。但是常量字段除外（static final）。这些字段在这个阶段已经赋值并且放入方法区的常量池了。</p>\n<h3>解析阶段</h3>\n\n<p>类的解析是虚拟机做的最复杂的一项工作。它会将一些符号引用(虚地址)替换为直接引用(实际地址)，完成类的继承关系的解析，完成字段和方法的解析。还会进行各种权限的验证。当一个类的各种符号引用被替换为了直接引用。它的各种父类，接口，字段，方法完成了解析。这个类就可以进入初始化阶段了。</p>\n<h3>初始化阶段</h3>\n\n<p>类的初始化阶段简单的说就是执行一个&lt; init&gt;方法。这个方法是Java虚拟机帮我们生成的。是在构造函数执行(构造函数是程序员主动调用的)前由java虚拟机调用执行。目的在于完成类实例各个变量的初始化赋值，静态代码块的执行等。当然，如果一个类没有静态代码块，也没有变量赋值，那么这个&lt; init&gt;方法什么也不用干了。我们可以写一个类，它什么也不干，然后反编译看下如果加载这个类虚拟机将执行哪些指令。</p>\n<pre><code>class TestObject {\n\n}\n</code></pre><p>javap一下，可以看到以下输出：</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/init_class.png\" alt=\"Class反汇编\"></p>\n<p>这个类啥事也不干，因此如果虚拟机加载这个类，还是会调用<init>方法，但是这个方法事实上啥事也没有干。</p>\n<p>这个时候，调用new将生产一个对象实例，这个实例的内存占用是在Java堆上。这里有一个问题，假如我们有个线程A在堆内存地址为0x123的地方实例化一个对象，但是还没有实例化完成，这时线程B也想在堆内存地址为0x123的地方实例化一个对象，会不会把线程A还没有实例化完成的对象信息给抹掉？</p>\n<h3>如何保证线程安全的类初始化</h3>\n\n<p>一种很简单的办法是同步化。虚拟机可以采用CAS操作(在并发系列中将讲到CAS操作)来保证原子化，还有一种方式是将分配对象堆内存的工作按照线程划分在不同的线程空间中进行。这个线程空间的名字就叫做TLAB(Thread Local Allocation Buffer)。我们看到java虚拟机参数中有一些参数是跟TLAB有关的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-XX:+UseTLAB //是否开启TLAB，JDK1.4之前是false</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-XX:TLABWasteTargetPercent //TLAB占整个eden区的百分比</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-XX:+PrintTLAB //查看TLAB的使用情况</div></pre></td></tr></table></figure>\n<p>当堆内存分配完了，&lt; init&gt;方法也执行完了，一个对象就初始化完成了。这时候就开始执行构造函数，对象就到了程序员手里，可以被程序员使用了。</p>\n<p><em>参考文献</em><br><em>《深入理解Java虚拟机》 –周志明著</em><br><em><a href=\"http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#largepages\">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html#largepages</a></em></p>"},{"title":"Java虚拟机架构分析","date":"2016-07-07T11:11:34.000Z","_content":"Java虚拟机(JVM)是装载执行Class文件的唯一场所。Java之所以能够实现跨平台运行就是因为JVM屏蔽了不同操作系统的底层实现，统一了一套Java指令。实现了在不同操作系统的JVM都可以执行同一套Java指令。JVM事实上充当了代理的角色，将不同操作系统的底层不同屏蔽起来，对上层提供统一的接口。\n\n<!--more-->\n\nJVM的体系结构如下图所示：\n![JVM体系架构](http://o9z6i1a1s.bkt.clouddn.com/1.png)\n\n<h2>JVM的体系结构</h2>\n\n<h3>运行时数据区</h3>\n\n运行时数据区是JVM运行时的数据所在地。这些数据包括类数据，线程上下文数据，程序执行的数据等。因此可以把运行时数据区理解为JVM的数据仓库。程序运行的所有数据都来自这里。运行时数据区包括方法区、堆、Java虚拟机栈、本地方法栈、程序计数器。\n\n<h3>程序计数器(线程私有)</h3>\n\n当前线程所执行的的字节码行号指示器。虚拟机通过改变这个计数器的值来选取下一条需要执行的指令，每条线程都有一个独立的计数器，因为线程的切换需要记住上一次线程执行的位置。但如果执行的是native方法，则计数器值为空(Undefined)。\n\n<h3>虚拟机栈(线程私有)</h3>\n\nJava虚拟机栈是线程私有的，其生命周期和线程一样。虚拟机栈里保存的是当前线程所执行到的方法的上下文信息。每调用一个方法，就会有一次入栈。入栈的对象叫做栈帧(Stack Frame),这些方法的上下文信息包括局部变量表，操作数栈，动态链接，方法出口等。当方法执行完后，对应一次出栈。\n\n<h3>本地方法栈</h3>\n\n类似于虚拟机栈，区别在于Java虚拟机栈执行的是虚拟机方法，本地方法栈执行的是本地Native方法。\n\n<h3>堆(线程共享)</h3>\n\nJava堆是Java虚拟机所管理的内存中最大的一块。用于存放对象的实例，几乎所有的对象实例都在这里分配（并不是绝对）。\n\n<h3>方法区(线程共享)</h3>\n\n用于存储虚拟机加载的类信息，常量，静态变量等数据。Class文件中有一项叫做常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后就是放在方法区的运行时常量池中。事实上，在虚拟机运行时也可以将字符串常量放到运行时常量池中。JDK1.7之前的String.intern()方法就可以实现。\n\n<h3>直接内存</h3>\n\n在JDK1.4中加入的NIO有一个缓冲类叫ByteBuf，这个类有一个DirectByteBuffer方法，调用该方法得到的内存缓存就是直接内存。这块内存不再是Java虚拟机管理，而是操作系统直接管理。这样做的好处时再一些IO场景中可以显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。\n\n<h3>执行引擎</h3>\n\n执行引擎是JVM执行具体的Java指令的场所。它从运行时数据区中获取数据执行(输入)，执行完将结果再次返回运行时数据区。\n\n<h3>本地库接口</h3>\n\nJava可以通过JNI调用本地方法。这些接口就是本地库接口。调用的那些方法库叫本地方法库。通常是用C/C++写的一些本地函数库。这样做的好处是可以提高性能。\n\n<h2>JVM常见内存溢出分析</h2>\n\n所谓内存溢出就是程序运行时需要申请的内存大于目前虚拟机所在区域可用的内存。这时候程序无法运行下去，虚拟机抛出内存溢出异常，程序退出执行。能够发生内存溢出的区域有方法区，Java堆，虚拟机栈，本地方法栈。理论上直接内存也有可能发生内存溢出。程序计数器因为保存的是当前线程下一条执行指令的地址，因此不会发生内存溢出。\n\n<h3>方法区内存溢出</h3>\n\n方法区在HotSpot也可以称为永久代（Permanent Generation）。可以通过-XX:PermSize和-XX:MaxPermSize两个参数调节其初始大小和最大值。为了构造方法区内存溢出，需要将这两个值调整一下。这两个值默认分别是物理内存的1/64和1/4。\n\n设置启动参数为\n```\n    -XX:PermSize=1M -XX:MaxPermSize=2M\n```\n写一个只含有main函数的方法，里面什么也不干。运行程序发现马上会抛出以下异常：\n\n![方法区内存溢出异常信息](http://o9z6i1a1s.bkt.clouddn.com/methodarea.png)\n\n从图中可以看出，当虚拟机启动加载类的常量池的时候发现内存不够，因此启动中断，抛出PermGen space OOM。\n\n如果没有特殊需求，一般不需要设置这两个值。\n\n<h3>堆内存溢出</h3>\n\nJava堆是用于存放Java运行时各种对象等数据实例。因此当新产生的对象实例所需要的内存大于目前Java堆空余空间大小而且Java堆中对象实例都不能被垃圾回收器所回收也不能升级为老年代或直接在老年代分配的时候就会报Java堆OOM异常。\n\n从上面的描述来看，堆内存溢出产生的条件还是比较复杂。事实上，HotSpot虚拟机的Java堆进一步还可以分为新生代，老年代。新生代里面有Eden区，From Survivor空间，To Survivor空间等概念。这个涉及到JVM的垃圾回收机制。将在下一篇详述。\n\n因为Java堆内存的复杂以及垃圾回收算法影响。要分析清楚堆内存溢出的原因还是有点困难。目前，可以理解为new出来的对象需要的内存大于目前堆中可用的内存。\n\n想要构造一个简单的Java堆内存溢出，可以如下操作\n设置启动参数:\n```\n-Xms20M -Xmx20M\n```\n    \n    /**\n     * @author wangcheng\n     * @Date 2016年7月7日 下午5:31:08\n     * @Desc:\n     * -Xms20M -Xmx20M\n     */\n    public class HeapOOM {\n\t\n\t    public static void main(String[] args) {\n\t\t    byte[] b = new byte[1024*1024*100];\n\t    }\n    }\n\n\n将初始堆大小和最大堆大小都设置成20M，在程序运行的时候，在堆中new一个100M大小的byte数组。因为最大堆大小都没有100M，这时候将会抛出Java heap space OOM异常。如图：\n\n![堆内存溢出异常信息](http://o9z6i1a1s.bkt.clouddn.com/heap.png)\n\n上文说过，Java堆分为新生代，老年代等，还和垃圾回收以及引用强弱等因素，堆内存溢出的场景远比这个复杂得多。\n\n<h3>虚拟机栈栈溢出</h3>\n\n虚拟机栈是线程私有，这是一个栈结构，因此有两种类型的内存溢出。一种是栈的深度超过虚拟机所允许的最大深度抛出StackOverflowError，一种是当前的栈帧所需要的内存超过限制抛出OutOfMemoryError。\n\n本地方法栈和虚拟机栈类似，除了执行的是本地方法。要构造出本地方法栈溢出还是有些难度。需要很深的native调用。\n\n下面构造一种简单的虚拟机栈栈溢出。\n设置启动参数：\n```\n-Xss:1K\n```\n\n    /**\n \t * @author wangcheng\n\t * @Date 2016年7月7日 下午6:40:49\n\t * @Desc:\n\t * -Xss:1K -XX:ThreadStackSize=1K\n\t */\n\tpublic class StackOFE {\n\t\tpublic void call() {\n\t\t\tcall();\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tStackOFE om = new StackOFE();\n\t\t\tom.call();\n\t\t}\n\n\t}\n\n\n这里将Java虚拟机栈大小设置为1K，然后不断地递归调用方法，每调用一次方法将会入栈一次。最终导致栈溢出。和 -Xss类似的参数还有一个叫-XX:ThreadStackSize=1K\n\n![栈溢出异常信息](http://o9z6i1a1s.bkt.clouddn.com/stack.png)\n\n<h3>直接内存溢出</h3>\n\n前文说过，NIO中有一个ByteBuffer可以操作直接内存。JVM可以通过\n```\n-XX:MaxDirectMemorySize\n```\n这个参数设置直接内存大小。我们将其设置为1M。方法代码如下：\n\n    /**\n \t * @author wangcheng\n\t * @Date 2016年7月7日 下午6:54:00\n\t * @Desc:\n\t * -XX:MaxDirectMemorySize=1M\n\t */\n\tpublic class DirectOOM {\n\t\tpublic static void main(String[] args) {\n\t\t\tByteBuffer buffer = ByteBuffer.allocateDirect(1024*1024*10);\n\t\t\tbuffer.clear();\n\t\t}\n\n\t}\n\n直接分配10M的内存，将会抛出如下异常：\n\n![直接内存溢出异常信息](http://o9z6i1a1s.bkt.clouddn.com/dm.png)\n\n<h2>总结</h2>\n\n本文简要分析了JVM的架构，构造了几种简单的内存溢出场景来理解JVM的内存功能块的作用。实际生产场景中，内存溢出比这个难得多。可能需要加日志手段或获取内存快照等手段长时间分析才能分析出来原因。\n\n**注:本文只适用于HotSpot Java7**\n\n*参考文献：*\n\n*http://www.oracle.com/technetwork/java/tuning-139912.html*\n\n*《深入理解Java虚拟机》 --周志明著*\n\n\n*附*\n[Java7虚拟机规范官方文档](http://o9z6i1a1s.bkt.clouddn.com/jvms7.pdf)\n[Java8虚拟机规范官方文档](http://o9z6i1a1s.bkt.clouddn.com/jvms8.pdf)\n\n\n","source":"_posts/jvm-arch-anasi20160707.md","raw":"---\ntitle: Java虚拟机架构分析\ndate: 2016-07-07 19:11:34\ntags: \n  - JVM\n  - 架构分析\n  - 内存溢出\ncategories: 深入理解\n---\nJava虚拟机(JVM)是装载执行Class文件的唯一场所。Java之所以能够实现跨平台运行就是因为JVM屏蔽了不同操作系统的底层实现，统一了一套Java指令。实现了在不同操作系统的JVM都可以执行同一套Java指令。JVM事实上充当了代理的角色，将不同操作系统的底层不同屏蔽起来，对上层提供统一的接口。\n\n<!--more-->\n\nJVM的体系结构如下图所示：\n![JVM体系架构](http://o9z6i1a1s.bkt.clouddn.com/1.png)\n\n<h2>JVM的体系结构</h2>\n\n<h3>运行时数据区</h3>\n\n运行时数据区是JVM运行时的数据所在地。这些数据包括类数据，线程上下文数据，程序执行的数据等。因此可以把运行时数据区理解为JVM的数据仓库。程序运行的所有数据都来自这里。运行时数据区包括方法区、堆、Java虚拟机栈、本地方法栈、程序计数器。\n\n<h3>程序计数器(线程私有)</h3>\n\n当前线程所执行的的字节码行号指示器。虚拟机通过改变这个计数器的值来选取下一条需要执行的指令，每条线程都有一个独立的计数器，因为线程的切换需要记住上一次线程执行的位置。但如果执行的是native方法，则计数器值为空(Undefined)。\n\n<h3>虚拟机栈(线程私有)</h3>\n\nJava虚拟机栈是线程私有的，其生命周期和线程一样。虚拟机栈里保存的是当前线程所执行到的方法的上下文信息。每调用一个方法，就会有一次入栈。入栈的对象叫做栈帧(Stack Frame),这些方法的上下文信息包括局部变量表，操作数栈，动态链接，方法出口等。当方法执行完后，对应一次出栈。\n\n<h3>本地方法栈</h3>\n\n类似于虚拟机栈，区别在于Java虚拟机栈执行的是虚拟机方法，本地方法栈执行的是本地Native方法。\n\n<h3>堆(线程共享)</h3>\n\nJava堆是Java虚拟机所管理的内存中最大的一块。用于存放对象的实例，几乎所有的对象实例都在这里分配（并不是绝对）。\n\n<h3>方法区(线程共享)</h3>\n\n用于存储虚拟机加载的类信息，常量，静态变量等数据。Class文件中有一项叫做常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后就是放在方法区的运行时常量池中。事实上，在虚拟机运行时也可以将字符串常量放到运行时常量池中。JDK1.7之前的String.intern()方法就可以实现。\n\n<h3>直接内存</h3>\n\n在JDK1.4中加入的NIO有一个缓冲类叫ByteBuf，这个类有一个DirectByteBuffer方法，调用该方法得到的内存缓存就是直接内存。这块内存不再是Java虚拟机管理，而是操作系统直接管理。这样做的好处时再一些IO场景中可以显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。\n\n<h3>执行引擎</h3>\n\n执行引擎是JVM执行具体的Java指令的场所。它从运行时数据区中获取数据执行(输入)，执行完将结果再次返回运行时数据区。\n\n<h3>本地库接口</h3>\n\nJava可以通过JNI调用本地方法。这些接口就是本地库接口。调用的那些方法库叫本地方法库。通常是用C/C++写的一些本地函数库。这样做的好处是可以提高性能。\n\n<h2>JVM常见内存溢出分析</h2>\n\n所谓内存溢出就是程序运行时需要申请的内存大于目前虚拟机所在区域可用的内存。这时候程序无法运行下去，虚拟机抛出内存溢出异常，程序退出执行。能够发生内存溢出的区域有方法区，Java堆，虚拟机栈，本地方法栈。理论上直接内存也有可能发生内存溢出。程序计数器因为保存的是当前线程下一条执行指令的地址，因此不会发生内存溢出。\n\n<h3>方法区内存溢出</h3>\n\n方法区在HotSpot也可以称为永久代（Permanent Generation）。可以通过-XX:PermSize和-XX:MaxPermSize两个参数调节其初始大小和最大值。为了构造方法区内存溢出，需要将这两个值调整一下。这两个值默认分别是物理内存的1/64和1/4。\n\n设置启动参数为\n```\n    -XX:PermSize=1M -XX:MaxPermSize=2M\n```\n写一个只含有main函数的方法，里面什么也不干。运行程序发现马上会抛出以下异常：\n\n![方法区内存溢出异常信息](http://o9z6i1a1s.bkt.clouddn.com/methodarea.png)\n\n从图中可以看出，当虚拟机启动加载类的常量池的时候发现内存不够，因此启动中断，抛出PermGen space OOM。\n\n如果没有特殊需求，一般不需要设置这两个值。\n\n<h3>堆内存溢出</h3>\n\nJava堆是用于存放Java运行时各种对象等数据实例。因此当新产生的对象实例所需要的内存大于目前Java堆空余空间大小而且Java堆中对象实例都不能被垃圾回收器所回收也不能升级为老年代或直接在老年代分配的时候就会报Java堆OOM异常。\n\n从上面的描述来看，堆内存溢出产生的条件还是比较复杂。事实上，HotSpot虚拟机的Java堆进一步还可以分为新生代，老年代。新生代里面有Eden区，From Survivor空间，To Survivor空间等概念。这个涉及到JVM的垃圾回收机制。将在下一篇详述。\n\n因为Java堆内存的复杂以及垃圾回收算法影响。要分析清楚堆内存溢出的原因还是有点困难。目前，可以理解为new出来的对象需要的内存大于目前堆中可用的内存。\n\n想要构造一个简单的Java堆内存溢出，可以如下操作\n设置启动参数:\n```\n-Xms20M -Xmx20M\n```\n    \n    /**\n     * @author wangcheng\n     * @Date 2016年7月7日 下午5:31:08\n     * @Desc:\n     * -Xms20M -Xmx20M\n     */\n    public class HeapOOM {\n\t\n\t    public static void main(String[] args) {\n\t\t    byte[] b = new byte[1024*1024*100];\n\t    }\n    }\n\n\n将初始堆大小和最大堆大小都设置成20M，在程序运行的时候，在堆中new一个100M大小的byte数组。因为最大堆大小都没有100M，这时候将会抛出Java heap space OOM异常。如图：\n\n![堆内存溢出异常信息](http://o9z6i1a1s.bkt.clouddn.com/heap.png)\n\n上文说过，Java堆分为新生代，老年代等，还和垃圾回收以及引用强弱等因素，堆内存溢出的场景远比这个复杂得多。\n\n<h3>虚拟机栈栈溢出</h3>\n\n虚拟机栈是线程私有，这是一个栈结构，因此有两种类型的内存溢出。一种是栈的深度超过虚拟机所允许的最大深度抛出StackOverflowError，一种是当前的栈帧所需要的内存超过限制抛出OutOfMemoryError。\n\n本地方法栈和虚拟机栈类似，除了执行的是本地方法。要构造出本地方法栈溢出还是有些难度。需要很深的native调用。\n\n下面构造一种简单的虚拟机栈栈溢出。\n设置启动参数：\n```\n-Xss:1K\n```\n\n    /**\n \t * @author wangcheng\n\t * @Date 2016年7月7日 下午6:40:49\n\t * @Desc:\n\t * -Xss:1K -XX:ThreadStackSize=1K\n\t */\n\tpublic class StackOFE {\n\t\tpublic void call() {\n\t\t\tcall();\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tStackOFE om = new StackOFE();\n\t\t\tom.call();\n\t\t}\n\n\t}\n\n\n这里将Java虚拟机栈大小设置为1K，然后不断地递归调用方法，每调用一次方法将会入栈一次。最终导致栈溢出。和 -Xss类似的参数还有一个叫-XX:ThreadStackSize=1K\n\n![栈溢出异常信息](http://o9z6i1a1s.bkt.clouddn.com/stack.png)\n\n<h3>直接内存溢出</h3>\n\n前文说过，NIO中有一个ByteBuffer可以操作直接内存。JVM可以通过\n```\n-XX:MaxDirectMemorySize\n```\n这个参数设置直接内存大小。我们将其设置为1M。方法代码如下：\n\n    /**\n \t * @author wangcheng\n\t * @Date 2016年7月7日 下午6:54:00\n\t * @Desc:\n\t * -XX:MaxDirectMemorySize=1M\n\t */\n\tpublic class DirectOOM {\n\t\tpublic static void main(String[] args) {\n\t\t\tByteBuffer buffer = ByteBuffer.allocateDirect(1024*1024*10);\n\t\t\tbuffer.clear();\n\t\t}\n\n\t}\n\n直接分配10M的内存，将会抛出如下异常：\n\n![直接内存溢出异常信息](http://o9z6i1a1s.bkt.clouddn.com/dm.png)\n\n<h2>总结</h2>\n\n本文简要分析了JVM的架构，构造了几种简单的内存溢出场景来理解JVM的内存功能块的作用。实际生产场景中，内存溢出比这个难得多。可能需要加日志手段或获取内存快照等手段长时间分析才能分析出来原因。\n\n**注:本文只适用于HotSpot Java7**\n\n*参考文献：*\n\n*http://www.oracle.com/technetwork/java/tuning-139912.html*\n\n*《深入理解Java虚拟机》 --周志明著*\n\n\n*附*\n[Java7虚拟机规范官方文档](http://o9z6i1a1s.bkt.clouddn.com/jvms7.pdf)\n[Java8虚拟机规范官方文档](http://o9z6i1a1s.bkt.clouddn.com/jvms8.pdf)\n\n\n","slug":"jvm-arch-anasi20160707","published":1,"updated":"2016-07-16T14:52:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf4d001n1ati2er61dvw","content":"<p>Java虚拟机(JVM)是装载执行Class文件的唯一场所。Java之所以能够实现跨平台运行就是因为JVM屏蔽了不同操作系统的底层实现，统一了一套Java指令。实现了在不同操作系统的JVM都可以执行同一套Java指令。JVM事实上充当了代理的角色，将不同操作系统的底层不同屏蔽起来，对上层提供统一的接口。</p>\n<a id=\"more\"></a>\n<p>JVM的体系结构如下图所示：<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/1.png\" alt=\"JVM体系架构\"></p>\n<h2>JVM的体系结构</h2>\n\n<h3>运行时数据区</h3>\n\n<p>运行时数据区是JVM运行时的数据所在地。这些数据包括类数据，线程上下文数据，程序执行的数据等。因此可以把运行时数据区理解为JVM的数据仓库。程序运行的所有数据都来自这里。运行时数据区包括方法区、堆、Java虚拟机栈、本地方法栈、程序计数器。</p>\n<h3>程序计数器(线程私有)</h3>\n\n<p>当前线程所执行的的字节码行号指示器。虚拟机通过改变这个计数器的值来选取下一条需要执行的指令，每条线程都有一个独立的计数器，因为线程的切换需要记住上一次线程执行的位置。但如果执行的是native方法，则计数器值为空(Undefined)。</p>\n<h3>虚拟机栈(线程私有)</h3>\n\n<p>Java虚拟机栈是线程私有的，其生命周期和线程一样。虚拟机栈里保存的是当前线程所执行到的方法的上下文信息。每调用一个方法，就会有一次入栈。入栈的对象叫做栈帧(Stack Frame),这些方法的上下文信息包括局部变量表，操作数栈，动态链接，方法出口等。当方法执行完后，对应一次出栈。</p>\n<h3>本地方法栈</h3>\n\n<p>类似于虚拟机栈，区别在于Java虚拟机栈执行的是虚拟机方法，本地方法栈执行的是本地Native方法。</p>\n<h3>堆(线程共享)</h3>\n\n<p>Java堆是Java虚拟机所管理的内存中最大的一块。用于存放对象的实例，几乎所有的对象实例都在这里分配（并不是绝对）。</p>\n<h3>方法区(线程共享)</h3>\n\n<p>用于存储虚拟机加载的类信息，常量，静态变量等数据。Class文件中有一项叫做常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后就是放在方法区的运行时常量池中。事实上，在虚拟机运行时也可以将字符串常量放到运行时常量池中。JDK1.7之前的String.intern()方法就可以实现。</p>\n<h3>直接内存</h3>\n\n<p>在JDK1.4中加入的NIO有一个缓冲类叫ByteBuf，这个类有一个DirectByteBuffer方法，调用该方法得到的内存缓存就是直接内存。这块内存不再是Java虚拟机管理，而是操作系统直接管理。这样做的好处时再一些IO场景中可以显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>\n<h3>执行引擎</h3>\n\n<p>执行引擎是JVM执行具体的Java指令的场所。它从运行时数据区中获取数据执行(输入)，执行完将结果再次返回运行时数据区。</p>\n<h3>本地库接口</h3>\n\n<p>Java可以通过JNI调用本地方法。这些接口就是本地库接口。调用的那些方法库叫本地方法库。通常是用C/C++写的一些本地函数库。这样做的好处是可以提高性能。</p>\n<h2>JVM常见内存溢出分析</h2>\n\n<p>所谓内存溢出就是程序运行时需要申请的内存大于目前虚拟机所在区域可用的内存。这时候程序无法运行下去，虚拟机抛出内存溢出异常，程序退出执行。能够发生内存溢出的区域有方法区，Java堆，虚拟机栈，本地方法栈。理论上直接内存也有可能发生内存溢出。程序计数器因为保存的是当前线程下一条执行指令的地址，因此不会发生内存溢出。</p>\n<h3>方法区内存溢出</h3>\n\n<p>方法区在HotSpot也可以称为永久代（Permanent Generation）。可以通过-XX:PermSize和-XX:MaxPermSize两个参数调节其初始大小和最大值。为了构造方法区内存溢出，需要将这两个值调整一下。这两个值默认分别是物理内存的1/64和1/4。</p>\n<p>设置启动参数为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-XX:PermSize=1M -XX:MaxPermSize=2M</div></pre></td></tr></table></figure></p>\n<p>写一个只含有main函数的方法，里面什么也不干。运行程序发现马上会抛出以下异常：</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/methodarea.png\" alt=\"方法区内存溢出异常信息\"></p>\n<p>从图中可以看出，当虚拟机启动加载类的常量池的时候发现内存不够，因此启动中断，抛出PermGen space OOM。</p>\n<p>如果没有特殊需求，一般不需要设置这两个值。</p>\n<h3>堆内存溢出</h3>\n\n<p>Java堆是用于存放Java运行时各种对象等数据实例。因此当新产生的对象实例所需要的内存大于目前Java堆空余空间大小而且Java堆中对象实例都不能被垃圾回收器所回收也不能升级为老年代或直接在老年代分配的时候就会报Java堆OOM异常。</p>\n<p>从上面的描述来看，堆内存溢出产生的条件还是比较复杂。事实上，HotSpot虚拟机的Java堆进一步还可以分为新生代，老年代。新生代里面有Eden区，From Survivor空间，To Survivor空间等概念。这个涉及到JVM的垃圾回收机制。将在下一篇详述。</p>\n<p>因为Java堆内存的复杂以及垃圾回收算法影响。要分析清楚堆内存溢出的原因还是有点困难。目前，可以理解为new出来的对象需要的内存大于目前堆中可用的内存。</p>\n<p>想要构造一个简单的Java堆内存溢出，可以如下操作<br>设置启动参数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-Xms20M -Xmx20M</div></pre></td></tr></table></figure></p>\n<pre><code>/**\n * @author wangcheng\n * @Date 2016年7月7日 下午5:31:08\n * @Desc:\n * -Xms20M -Xmx20M\n */\npublic class HeapOOM {\n\n    public static void main(String[] args) {\n        byte[] b = new byte[1024*1024*100];\n    }\n}\n</code></pre><p>将初始堆大小和最大堆大小都设置成20M，在程序运行的时候，在堆中new一个100M大小的byte数组。因为最大堆大小都没有100M，这时候将会抛出Java heap space OOM异常。如图：</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/heap.png\" alt=\"堆内存溢出异常信息\"></p>\n<p>上文说过，Java堆分为新生代，老年代等，还和垃圾回收以及引用强弱等因素，堆内存溢出的场景远比这个复杂得多。</p>\n<h3>虚拟机栈栈溢出</h3>\n\n<p>虚拟机栈是线程私有，这是一个栈结构，因此有两种类型的内存溢出。一种是栈的深度超过虚拟机所允许的最大深度抛出StackOverflowError，一种是当前的栈帧所需要的内存超过限制抛出OutOfMemoryError。</p>\n<p>本地方法栈和虚拟机栈类似，除了执行的是本地方法。要构造出本地方法栈溢出还是有些难度。需要很深的native调用。</p>\n<p>下面构造一种简单的虚拟机栈栈溢出。<br>设置启动参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-Xss:1K</div></pre></td></tr></table></figure></p>\n<pre><code>/**\n  * @author wangcheng\n * @Date 2016年7月7日 下午6:40:49\n * @Desc:\n * -Xss:1K -XX:ThreadStackSize=1K\n */\npublic class StackOFE {\n    public void call() {\n        call();\n    }\n\n    public static void main(String[] args) {\n        StackOFE om = new StackOFE();\n        om.call();\n    }\n\n}\n</code></pre><p>这里将Java虚拟机栈大小设置为1K，然后不断地递归调用方法，每调用一次方法将会入栈一次。最终导致栈溢出。和 -Xss类似的参数还有一个叫-XX:ThreadStackSize=1K</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/stack.png\" alt=\"栈溢出异常信息\"></p>\n<h3>直接内存溢出</h3>\n\n<p>前文说过，NIO中有一个ByteBuffer可以操作直接内存。JVM可以通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-XX:MaxDirectMemorySize</div></pre></td></tr></table></figure></p>\n<p>这个参数设置直接内存大小。我们将其设置为1M。方法代码如下：</p>\n<pre><code>/**\n  * @author wangcheng\n * @Date 2016年7月7日 下午6:54:00\n * @Desc:\n * -XX:MaxDirectMemorySize=1M\n */\npublic class DirectOOM {\n    public static void main(String[] args) {\n        ByteBuffer buffer = ByteBuffer.allocateDirect(1024*1024*10);\n        buffer.clear();\n    }\n\n}\n</code></pre><p>直接分配10M的内存，将会抛出如下异常：</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/dm.png\" alt=\"直接内存溢出异常信息\"></p>\n<h2>总结</h2>\n\n<p>本文简要分析了JVM的架构，构造了几种简单的内存溢出场景来理解JVM的内存功能块的作用。实际生产场景中，内存溢出比这个难得多。可能需要加日志手段或获取内存快照等手段长时间分析才能分析出来原因。</p>\n<p><strong>注:本文只适用于HotSpot Java7</strong></p>\n<p><em>参考文献：</em></p>\n<p><em><a href=\"http://www.oracle.com/technetwork/java/tuning-139912.html\" target=\"_blank\" rel=\"external\">http://www.oracle.com/technetwork/java/tuning-139912.html</a></em></p>\n<p><em>《深入理解Java虚拟机》 –周志明著</em></p>\n<p><em>附</em><br><a href=\"http://o9z6i1a1s.bkt.clouddn.com/jvms7.pdf\" target=\"_blank\" rel=\"external\">Java7虚拟机规范官方文档</a><br><a href=\"http://o9z6i1a1s.bkt.clouddn.com/jvms8.pdf\" target=\"_blank\" rel=\"external\">Java8虚拟机规范官方文档</a></p>\n","excerpt":"<p>Java虚拟机(JVM)是装载执行Class文件的唯一场所。Java之所以能够实现跨平台运行就是因为JVM屏蔽了不同操作系统的底层实现，统一了一套Java指令。实现了在不同操作系统的JVM都可以执行同一套Java指令。JVM事实上充当了代理的角色，将不同操作系统的底层不同屏蔽起来，对上层提供统一的接口。</p>","more":"<p>JVM的体系结构如下图所示：<br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/1.png\" alt=\"JVM体系架构\"></p>\n<h2>JVM的体系结构</h2>\n\n<h3>运行时数据区</h3>\n\n<p>运行时数据区是JVM运行时的数据所在地。这些数据包括类数据，线程上下文数据，程序执行的数据等。因此可以把运行时数据区理解为JVM的数据仓库。程序运行的所有数据都来自这里。运行时数据区包括方法区、堆、Java虚拟机栈、本地方法栈、程序计数器。</p>\n<h3>程序计数器(线程私有)</h3>\n\n<p>当前线程所执行的的字节码行号指示器。虚拟机通过改变这个计数器的值来选取下一条需要执行的指令，每条线程都有一个独立的计数器，因为线程的切换需要记住上一次线程执行的位置。但如果执行的是native方法，则计数器值为空(Undefined)。</p>\n<h3>虚拟机栈(线程私有)</h3>\n\n<p>Java虚拟机栈是线程私有的，其生命周期和线程一样。虚拟机栈里保存的是当前线程所执行到的方法的上下文信息。每调用一个方法，就会有一次入栈。入栈的对象叫做栈帧(Stack Frame),这些方法的上下文信息包括局部变量表，操作数栈，动态链接，方法出口等。当方法执行完后，对应一次出栈。</p>\n<h3>本地方法栈</h3>\n\n<p>类似于虚拟机栈，区别在于Java虚拟机栈执行的是虚拟机方法，本地方法栈执行的是本地Native方法。</p>\n<h3>堆(线程共享)</h3>\n\n<p>Java堆是Java虚拟机所管理的内存中最大的一块。用于存放对象的实例，几乎所有的对象实例都在这里分配（并不是绝对）。</p>\n<h3>方法区(线程共享)</h3>\n\n<p>用于存储虚拟机加载的类信息，常量，静态变量等数据。Class文件中有一项叫做常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后就是放在方法区的运行时常量池中。事实上，在虚拟机运行时也可以将字符串常量放到运行时常量池中。JDK1.7之前的String.intern()方法就可以实现。</p>\n<h3>直接内存</h3>\n\n<p>在JDK1.4中加入的NIO有一个缓冲类叫ByteBuf，这个类有一个DirectByteBuffer方法，调用该方法得到的内存缓存就是直接内存。这块内存不再是Java虚拟机管理，而是操作系统直接管理。这样做的好处时再一些IO场景中可以显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>\n<h3>执行引擎</h3>\n\n<p>执行引擎是JVM执行具体的Java指令的场所。它从运行时数据区中获取数据执行(输入)，执行完将结果再次返回运行时数据区。</p>\n<h3>本地库接口</h3>\n\n<p>Java可以通过JNI调用本地方法。这些接口就是本地库接口。调用的那些方法库叫本地方法库。通常是用C/C++写的一些本地函数库。这样做的好处是可以提高性能。</p>\n<h2>JVM常见内存溢出分析</h2>\n\n<p>所谓内存溢出就是程序运行时需要申请的内存大于目前虚拟机所在区域可用的内存。这时候程序无法运行下去，虚拟机抛出内存溢出异常，程序退出执行。能够发生内存溢出的区域有方法区，Java堆，虚拟机栈，本地方法栈。理论上直接内存也有可能发生内存溢出。程序计数器因为保存的是当前线程下一条执行指令的地址，因此不会发生内存溢出。</p>\n<h3>方法区内存溢出</h3>\n\n<p>方法区在HotSpot也可以称为永久代（Permanent Generation）。可以通过-XX:PermSize和-XX:MaxPermSize两个参数调节其初始大小和最大值。为了构造方法区内存溢出，需要将这两个值调整一下。这两个值默认分别是物理内存的1/64和1/4。</p>\n<p>设置启动参数为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-XX:PermSize=1M -XX:MaxPermSize=2M</div></pre></td></tr></table></figure></p>\n<p>写一个只含有main函数的方法，里面什么也不干。运行程序发现马上会抛出以下异常：</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/methodarea.png\" alt=\"方法区内存溢出异常信息\"></p>\n<p>从图中可以看出，当虚拟机启动加载类的常量池的时候发现内存不够，因此启动中断，抛出PermGen space OOM。</p>\n<p>如果没有特殊需求，一般不需要设置这两个值。</p>\n<h3>堆内存溢出</h3>\n\n<p>Java堆是用于存放Java运行时各种对象等数据实例。因此当新产生的对象实例所需要的内存大于目前Java堆空余空间大小而且Java堆中对象实例都不能被垃圾回收器所回收也不能升级为老年代或直接在老年代分配的时候就会报Java堆OOM异常。</p>\n<p>从上面的描述来看，堆内存溢出产生的条件还是比较复杂。事实上，HotSpot虚拟机的Java堆进一步还可以分为新生代，老年代。新生代里面有Eden区，From Survivor空间，To Survivor空间等概念。这个涉及到JVM的垃圾回收机制。将在下一篇详述。</p>\n<p>因为Java堆内存的复杂以及垃圾回收算法影响。要分析清楚堆内存溢出的原因还是有点困难。目前，可以理解为new出来的对象需要的内存大于目前堆中可用的内存。</p>\n<p>想要构造一个简单的Java堆内存溢出，可以如下操作<br>设置启动参数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-Xms20M -Xmx20M</div></pre></td></tr></table></figure></p>\n<pre><code>/**\n * @author wangcheng\n * @Date 2016年7月7日 下午5:31:08\n * @Desc:\n * -Xms20M -Xmx20M\n */\npublic class HeapOOM {\n\n    public static void main(String[] args) {\n        byte[] b = new byte[1024*1024*100];\n    }\n}\n</code></pre><p>将初始堆大小和最大堆大小都设置成20M，在程序运行的时候，在堆中new一个100M大小的byte数组。因为最大堆大小都没有100M，这时候将会抛出Java heap space OOM异常。如图：</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/heap.png\" alt=\"堆内存溢出异常信息\"></p>\n<p>上文说过，Java堆分为新生代，老年代等，还和垃圾回收以及引用强弱等因素，堆内存溢出的场景远比这个复杂得多。</p>\n<h3>虚拟机栈栈溢出</h3>\n\n<p>虚拟机栈是线程私有，这是一个栈结构，因此有两种类型的内存溢出。一种是栈的深度超过虚拟机所允许的最大深度抛出StackOverflowError，一种是当前的栈帧所需要的内存超过限制抛出OutOfMemoryError。</p>\n<p>本地方法栈和虚拟机栈类似，除了执行的是本地方法。要构造出本地方法栈溢出还是有些难度。需要很深的native调用。</p>\n<p>下面构造一种简单的虚拟机栈栈溢出。<br>设置启动参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-Xss:1K</div></pre></td></tr></table></figure></p>\n<pre><code>/**\n  * @author wangcheng\n * @Date 2016年7月7日 下午6:40:49\n * @Desc:\n * -Xss:1K -XX:ThreadStackSize=1K\n */\npublic class StackOFE {\n    public void call() {\n        call();\n    }\n\n    public static void main(String[] args) {\n        StackOFE om = new StackOFE();\n        om.call();\n    }\n\n}\n</code></pre><p>这里将Java虚拟机栈大小设置为1K，然后不断地递归调用方法，每调用一次方法将会入栈一次。最终导致栈溢出。和 -Xss类似的参数还有一个叫-XX:ThreadStackSize=1K</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/stack.png\" alt=\"栈溢出异常信息\"></p>\n<h3>直接内存溢出</h3>\n\n<p>前文说过，NIO中有一个ByteBuffer可以操作直接内存。JVM可以通过<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-XX:MaxDirectMemorySize</div></pre></td></tr></table></figure></p>\n<p>这个参数设置直接内存大小。我们将其设置为1M。方法代码如下：</p>\n<pre><code>/**\n  * @author wangcheng\n * @Date 2016年7月7日 下午6:54:00\n * @Desc:\n * -XX:MaxDirectMemorySize=1M\n */\npublic class DirectOOM {\n    public static void main(String[] args) {\n        ByteBuffer buffer = ByteBuffer.allocateDirect(1024*1024*10);\n        buffer.clear();\n    }\n\n}\n</code></pre><p>直接分配10M的内存，将会抛出如下异常：</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/dm.png\" alt=\"直接内存溢出异常信息\"></p>\n<h2>总结</h2>\n\n<p>本文简要分析了JVM的架构，构造了几种简单的内存溢出场景来理解JVM的内存功能块的作用。实际生产场景中，内存溢出比这个难得多。可能需要加日志手段或获取内存快照等手段长时间分析才能分析出来原因。</p>\n<p><strong>注:本文只适用于HotSpot Java7</strong></p>\n<p><em>参考文献：</em></p>\n<p><em><a href=\"http://www.oracle.com/technetwork/java/tuning-139912.html\">http://www.oracle.com/technetwork/java/tuning-139912.html</a></em></p>\n<p><em>《深入理解Java虚拟机》 –周志明著</em></p>\n<p><em>附</em><br><a href=\"http://o9z6i1a1s.bkt.clouddn.com/jvms7.pdf\">Java7虚拟机规范官方文档</a><br><a href=\"http://o9z6i1a1s.bkt.clouddn.com/jvms8.pdf\">Java8虚拟机规范官方文档</a></p>"},{"title":"Java垃圾回收三大问","date":"2016-07-12T03:18:09.000Z","_content":"Java语言的一大优势在于JVM自己管理内存。解决了程序中废弃对象的内存回收问题。不再需要程序员主动去申请和释放内存，从而避免很多恼人的内存泄露问题。但是哪些内存需要回收？什么时候回收？如何回收？这是JVM垃圾回收机制需要解决的三个问题。\n\n<!--more-->\n\n<h2>哪些内存需要回收？</h2>\n\n根据JVM的架构，需要进行内存回收的区域事实上只有方法区和堆区。这两个区域都是线程共享的。其他像Java虚拟机栈，本地方法栈等不需要内存回收，因为他们是线程私有，而且是栈结构。当方法或线程执行完自动会将栈帧或栈结构释放掉。程序计数器也是线程私有，而且只是保存当前线程执行下一条指令的地址。所需要的内存很小而且固定。自然也不需要专门来进行内存管理。因此JVM中只有线程共用的Java堆和方法区需要进行垃圾回收。这些垃圾主要是类信息，常量，最多的应该是对象实例。\n\n<h2>什么时候回收？</h2>\n\n对象回收的时机必然是该对象首先要成为一个内存垃圾。事实上Java中对象存活的判断并不是用的引用计数算法(CPython等是引用计数算法)，而是用的可达性分析算法。这个算法简单的说就是讲某些常量或类变量当成根，如果从根开始到某个对象实例有可达的路径则该对象是存活的。如果某些对象和根不再有引用关系则认为这些对象已经是垃圾了，将在垃圾算法运行的时候被回收。Java是所以采用可达性分析算法的一个原因是解决循环引用的问题。引用计数算法对于循环引用无能为力。而可达性分析算法只要对象实例和根没有引用关系则认为是垃圾。即便循环引用也没有关系。\n\n那是不是只要对象实例对于根对象而言不可达就会被立马回收掉呢？事实上不是的。JVM专门有一个线程叫做GC线程，专门用于垃圾回收。如果是一旦发现垃圾立马回收，显然效率太低，将会严重降低JVM的吞吐量。如果采用定时扫描自然会好很多。\n\n因此，JVM中方法区也好，堆区也好。当有类对象或对象实例成为垃圾时，如果进入了垃圾回收区并被GC扫描到就会被回收。\n\n这个垃圾回收区在HotSpot里叫做安全点(Safepoint)，当程序执行到安全点时，将暂停下来(Stop The World)，执行GC。\n\n<h2>如何回收？</h2>\n\n说清楚了哪些内存需要回收，什么时候可以进行垃圾回收。就应该说一说JVM如何进行垃圾回收了。\n\nJava7的HotSpot的垃圾回收算法不止一个，根据不同的场景(JVM运行时-client模式还是-server模式，是在新生代，老年代还是方法区)有不同的回收算法。\n\n![JDK7 HotSpot中的GC线程](http://o9z6i1a1s.bkt.clouddn.com/gcthread.png)\n![](http://o9z6i1a1s.bkt.clouddn.com/gcthread2.png)\n\n关于JVM中采用的各种回收算法，在Oracle的这篇[博客](https://blogs.oracle.com/jonthecollector/entry/our_collectors)中写的比较官方。\n\n\n**注:本文只适用于HotSpot Java7**\n\n*参考文献*\n\n*《深入理解Java虚拟机》 –周志明著*\n*https://blogs.oracle.com/jonthecollector/entry/our_collectors*\n\n","source":"_posts/jvm-gc-desc.md","raw":"---\ntitle: Java垃圾回收三大问\ndate: 2016-07-12 11:18:09\ntags: \n - JVM\n - 垃圾回收\ncategories: 深入理解\n---\nJava语言的一大优势在于JVM自己管理内存。解决了程序中废弃对象的内存回收问题。不再需要程序员主动去申请和释放内存，从而避免很多恼人的内存泄露问题。但是哪些内存需要回收？什么时候回收？如何回收？这是JVM垃圾回收机制需要解决的三个问题。\n\n<!--more-->\n\n<h2>哪些内存需要回收？</h2>\n\n根据JVM的架构，需要进行内存回收的区域事实上只有方法区和堆区。这两个区域都是线程共享的。其他像Java虚拟机栈，本地方法栈等不需要内存回收，因为他们是线程私有，而且是栈结构。当方法或线程执行完自动会将栈帧或栈结构释放掉。程序计数器也是线程私有，而且只是保存当前线程执行下一条指令的地址。所需要的内存很小而且固定。自然也不需要专门来进行内存管理。因此JVM中只有线程共用的Java堆和方法区需要进行垃圾回收。这些垃圾主要是类信息，常量，最多的应该是对象实例。\n\n<h2>什么时候回收？</h2>\n\n对象回收的时机必然是该对象首先要成为一个内存垃圾。事实上Java中对象存活的判断并不是用的引用计数算法(CPython等是引用计数算法)，而是用的可达性分析算法。这个算法简单的说就是讲某些常量或类变量当成根，如果从根开始到某个对象实例有可达的路径则该对象是存活的。如果某些对象和根不再有引用关系则认为这些对象已经是垃圾了，将在垃圾算法运行的时候被回收。Java是所以采用可达性分析算法的一个原因是解决循环引用的问题。引用计数算法对于循环引用无能为力。而可达性分析算法只要对象实例和根没有引用关系则认为是垃圾。即便循环引用也没有关系。\n\n那是不是只要对象实例对于根对象而言不可达就会被立马回收掉呢？事实上不是的。JVM专门有一个线程叫做GC线程，专门用于垃圾回收。如果是一旦发现垃圾立马回收，显然效率太低，将会严重降低JVM的吞吐量。如果采用定时扫描自然会好很多。\n\n因此，JVM中方法区也好，堆区也好。当有类对象或对象实例成为垃圾时，如果进入了垃圾回收区并被GC扫描到就会被回收。\n\n这个垃圾回收区在HotSpot里叫做安全点(Safepoint)，当程序执行到安全点时，将暂停下来(Stop The World)，执行GC。\n\n<h2>如何回收？</h2>\n\n说清楚了哪些内存需要回收，什么时候可以进行垃圾回收。就应该说一说JVM如何进行垃圾回收了。\n\nJava7的HotSpot的垃圾回收算法不止一个，根据不同的场景(JVM运行时-client模式还是-server模式，是在新生代，老年代还是方法区)有不同的回收算法。\n\n![JDK7 HotSpot中的GC线程](http://o9z6i1a1s.bkt.clouddn.com/gcthread.png)\n![](http://o9z6i1a1s.bkt.clouddn.com/gcthread2.png)\n\n关于JVM中采用的各种回收算法，在Oracle的这篇[博客](https://blogs.oracle.com/jonthecollector/entry/our_collectors)中写的比较官方。\n\n\n**注:本文只适用于HotSpot Java7**\n\n*参考文献*\n\n*《深入理解Java虚拟机》 –周志明著*\n*https://blogs.oracle.com/jonthecollector/entry/our_collectors*\n\n","slug":"jvm-gc-desc","published":1,"updated":"2016-07-16T14:52:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf4f001p1atinok98ame","content":"<p>Java语言的一大优势在于JVM自己管理内存。解决了程序中废弃对象的内存回收问题。不再需要程序员主动去申请和释放内存，从而避免很多恼人的内存泄露问题。但是哪些内存需要回收？什么时候回收？如何回收？这是JVM垃圾回收机制需要解决的三个问题。</p>\n<a id=\"more\"></a>\n<h2>哪些内存需要回收？</h2>\n\n<p>根据JVM的架构，需要进行内存回收的区域事实上只有方法区和堆区。这两个区域都是线程共享的。其他像Java虚拟机栈，本地方法栈等不需要内存回收，因为他们是线程私有，而且是栈结构。当方法或线程执行完自动会将栈帧或栈结构释放掉。程序计数器也是线程私有，而且只是保存当前线程执行下一条指令的地址。所需要的内存很小而且固定。自然也不需要专门来进行内存管理。因此JVM中只有线程共用的Java堆和方法区需要进行垃圾回收。这些垃圾主要是类信息，常量，最多的应该是对象实例。</p>\n<h2>什么时候回收？</h2>\n\n<p>对象回收的时机必然是该对象首先要成为一个内存垃圾。事实上Java中对象存活的判断并不是用的引用计数算法(CPython等是引用计数算法)，而是用的可达性分析算法。这个算法简单的说就是讲某些常量或类变量当成根，如果从根开始到某个对象实例有可达的路径则该对象是存活的。如果某些对象和根不再有引用关系则认为这些对象已经是垃圾了，将在垃圾算法运行的时候被回收。Java是所以采用可达性分析算法的一个原因是解决循环引用的问题。引用计数算法对于循环引用无能为力。而可达性分析算法只要对象实例和根没有引用关系则认为是垃圾。即便循环引用也没有关系。</p>\n<p>那是不是只要对象实例对于根对象而言不可达就会被立马回收掉呢？事实上不是的。JVM专门有一个线程叫做GC线程，专门用于垃圾回收。如果是一旦发现垃圾立马回收，显然效率太低，将会严重降低JVM的吞吐量。如果采用定时扫描自然会好很多。</p>\n<p>因此，JVM中方法区也好，堆区也好。当有类对象或对象实例成为垃圾时，如果进入了垃圾回收区并被GC扫描到就会被回收。</p>\n<p>这个垃圾回收区在HotSpot里叫做安全点(Safepoint)，当程序执行到安全点时，将暂停下来(Stop The World)，执行GC。</p>\n<h2>如何回收？</h2>\n\n<p>说清楚了哪些内存需要回收，什么时候可以进行垃圾回收。就应该说一说JVM如何进行垃圾回收了。</p>\n<p>Java7的HotSpot的垃圾回收算法不止一个，根据不同的场景(JVM运行时-client模式还是-server模式，是在新生代，老年代还是方法区)有不同的回收算法。</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/gcthread.png\" alt=\"JDK7 HotSpot中的GC线程\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/gcthread2.png\" alt=\"\"></p>\n<p>关于JVM中采用的各种回收算法，在Oracle的这篇<a href=\"https://blogs.oracle.com/jonthecollector/entry/our_collectors\" target=\"_blank\" rel=\"external\">博客</a>中写的比较官方。</p>\n<p><strong>注:本文只适用于HotSpot Java7</strong></p>\n<p><em>参考文献</em></p>\n<p><em>《深入理解Java虚拟机》 –周志明著</em><br><em><a href=\"https://blogs.oracle.com/jonthecollector/entry/our_collectors\" target=\"_blank\" rel=\"external\">https://blogs.oracle.com/jonthecollector/entry/our_collectors</a></em></p>\n","excerpt":"<p>Java语言的一大优势在于JVM自己管理内存。解决了程序中废弃对象的内存回收问题。不再需要程序员主动去申请和释放内存，从而避免很多恼人的内存泄露问题。但是哪些内存需要回收？什么时候回收？如何回收？这是JVM垃圾回收机制需要解决的三个问题。</p>","more":"<h2>哪些内存需要回收？</h2>\n\n<p>根据JVM的架构，需要进行内存回收的区域事实上只有方法区和堆区。这两个区域都是线程共享的。其他像Java虚拟机栈，本地方法栈等不需要内存回收，因为他们是线程私有，而且是栈结构。当方法或线程执行完自动会将栈帧或栈结构释放掉。程序计数器也是线程私有，而且只是保存当前线程执行下一条指令的地址。所需要的内存很小而且固定。自然也不需要专门来进行内存管理。因此JVM中只有线程共用的Java堆和方法区需要进行垃圾回收。这些垃圾主要是类信息，常量，最多的应该是对象实例。</p>\n<h2>什么时候回收？</h2>\n\n<p>对象回收的时机必然是该对象首先要成为一个内存垃圾。事实上Java中对象存活的判断并不是用的引用计数算法(CPython等是引用计数算法)，而是用的可达性分析算法。这个算法简单的说就是讲某些常量或类变量当成根，如果从根开始到某个对象实例有可达的路径则该对象是存活的。如果某些对象和根不再有引用关系则认为这些对象已经是垃圾了，将在垃圾算法运行的时候被回收。Java是所以采用可达性分析算法的一个原因是解决循环引用的问题。引用计数算法对于循环引用无能为力。而可达性分析算法只要对象实例和根没有引用关系则认为是垃圾。即便循环引用也没有关系。</p>\n<p>那是不是只要对象实例对于根对象而言不可达就会被立马回收掉呢？事实上不是的。JVM专门有一个线程叫做GC线程，专门用于垃圾回收。如果是一旦发现垃圾立马回收，显然效率太低，将会严重降低JVM的吞吐量。如果采用定时扫描自然会好很多。</p>\n<p>因此，JVM中方法区也好，堆区也好。当有类对象或对象实例成为垃圾时，如果进入了垃圾回收区并被GC扫描到就会被回收。</p>\n<p>这个垃圾回收区在HotSpot里叫做安全点(Safepoint)，当程序执行到安全点时，将暂停下来(Stop The World)，执行GC。</p>\n<h2>如何回收？</h2>\n\n<p>说清楚了哪些内存需要回收，什么时候可以进行垃圾回收。就应该说一说JVM如何进行垃圾回收了。</p>\n<p>Java7的HotSpot的垃圾回收算法不止一个，根据不同的场景(JVM运行时-client模式还是-server模式，是在新生代，老年代还是方法区)有不同的回收算法。</p>\n<p><img src=\"http://o9z6i1a1s.bkt.clouddn.com/gcthread.png\" alt=\"JDK7 HotSpot中的GC线程\"><br><img src=\"http://o9z6i1a1s.bkt.clouddn.com/gcthread2.png\" alt=\"\"></p>\n<p>关于JVM中采用的各种回收算法，在Oracle的这篇<a href=\"https://blogs.oracle.com/jonthecollector/entry/our_collectors\">博客</a>中写的比较官方。</p>\n<p><strong>注:本文只适用于HotSpot Java7</strong></p>\n<p><em>参考文献</em></p>\n<p><em>《深入理解Java虚拟机》 –周志明著</em><br><em><a href=\"https://blogs.oracle.com/jonthecollector/entry/our_collectors\">https://blogs.oracle.com/jonthecollector/entry/our_collectors</a></em></p>"},{"title":"周末随笔","date":"2016-07-23T05:39:10.000Z","_content":"生活不是诗，不能活在文艺的情怀里，生活大部分都是在柴米油盐酱醋茶中走过。\n\n<!--more-->\n\n20岁的时候特别喜欢赵雷的歌，而现在25岁，特别喜欢李志的歌~\n\n这5年里，蜕掉了一些稚气，增添了一些责任和想法。满嘴胡言乱语和自我嘲笑中隐藏了一些无人诉说又无人可懂的无奈和辛酸。\n\n留恋一座城市，大部分原因是因为那里有一些人和事吧~\n<embed type=\"video/mp4\" allowscriptaccess=\"always\" allowfullscreen=\"true\" wmode=\"transparent\" quality=\"high\" height=\"480\" width=\"700\"  src=\"http://o9z6i1a1s.bkt.clouddn.com/%E6%9D%8E%E5%BF%97%20-%20%E5%85%B3%E4%BA%8E%E9%83%91%E5%B7%9E%E7%9A%84%E8%AE%B0%E5%BF%86.mp4\"/> \n","source":"_posts/weekend-article-1.md","raw":"---\ntitle: 周末随笔\ndate: 2016-07-23 13:39:10\ntags:\n - 随笔\n - 心情\ncategories: 随笔\n---\n生活不是诗，不能活在文艺的情怀里，生活大部分都是在柴米油盐酱醋茶中走过。\n\n<!--more-->\n\n20岁的时候特别喜欢赵雷的歌，而现在25岁，特别喜欢李志的歌~\n\n这5年里，蜕掉了一些稚气，增添了一些责任和想法。满嘴胡言乱语和自我嘲笑中隐藏了一些无人诉说又无人可懂的无奈和辛酸。\n\n留恋一座城市，大部分原因是因为那里有一些人和事吧~\n<embed type=\"video/mp4\" allowscriptaccess=\"always\" allowfullscreen=\"true\" wmode=\"transparent\" quality=\"high\" height=\"480\" width=\"700\"  src=\"http://o9z6i1a1s.bkt.clouddn.com/%E6%9D%8E%E5%BF%97%20-%20%E5%85%B3%E4%BA%8E%E9%83%91%E5%B7%9E%E7%9A%84%E8%AE%B0%E5%BF%86.mp4\"/> \n","slug":"weekend-article-1","published":1,"updated":"2016-08-07T15:26:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf4j001s1atig3knapil","content":"<p>生活不是诗，不能活在文艺的情怀里，生活大部分都是在柴米油盐酱醋茶中走过。</p>\n<a id=\"more\"></a>\n<p>20岁的时候特别喜欢赵雷的歌，而现在25岁，特别喜欢李志的歌~</p>\n<p>这5年里，蜕掉了一些稚气，增添了一些责任和想法。满嘴胡言乱语和自我嘲笑中隐藏了一些无人诉说又无人可懂的无奈和辛酸。</p>\n<p>留恋一座城市，大部分原因是因为那里有一些人和事吧~</p>\n<embed type=\"video/mp4\" allowscriptaccess=\"always\" allowfullscreen=\"true\" wmode=\"transparent\" quality=\"high\" height=\"480\" width=\"700\" src=\"http://o9z6i1a1s.bkt.clouddn.com/%E6%9D%8E%E5%BF%97%20-%20%E5%85%B3%E4%BA%8E%E9%83%91%E5%B7%9E%E7%9A%84%E8%AE%B0%E5%BF%86.mp4\"> \n","excerpt":"<p>生活不是诗，不能活在文艺的情怀里，生活大部分都是在柴米油盐酱醋茶中走过。</p>","more":"<p>20岁的时候特别喜欢赵雷的歌，而现在25岁，特别喜欢李志的歌~</p>\n<p>这5年里，蜕掉了一些稚气，增添了一些责任和想法。满嘴胡言乱语和自我嘲笑中隐藏了一些无人诉说又无人可懂的无奈和辛酸。</p>\n<p>留恋一座城市，大部分原因是因为那里有一些人和事吧~</p>\n<embed type=\"video/mp4\" allowscriptaccess=\"always\" allowfullscreen=\"true\" wmode=\"transparent\" quality=\"high\" height=\"480\" width=\"700\"  src=\"http://o9z6i1a1s.bkt.clouddn.com/%E6%9D%8E%E5%BF%97%20-%20%E5%85%B3%E4%BA%8E%E9%83%91%E5%B7%9E%E7%9A%84%E8%AE%B0%E5%BF%86.mp4\"/>"},{"title":"生活的意义","date":"2016-07-16T15:25:18.000Z","_content":"{% cq %}我们之所以会去思(zhuang)考(bi)人生或生活,是因为在无聊(alone or lonely?)的生活中总要(xian)找(de)点(dan)乐(teng)子。<p> LouisWang </p> {%endcq%}\n\n人如果闲下来就会想很多。最近加班稍微少点，难得恢复了正常的周末，才发现我生活最大的娱乐活动竟然是加班了。突然不加班反而觉得生活有一点点枯燥和无聊……想到一个问题，我现在的生活意义是什么？我活着的意义什么？忽然正襟危坐，细思极恐……\n\n<!--more-->\n\n之所以会想这个问题，是因为今天看了一部叫做[《阳光小美女》](https://movie.douban.com/subject/1777612/)的电影。也许每个人的关注点都不一样。我从这部影片中看到的是生活痛苦的一面，看到的是作为人痛苦的一面。\n\n从生下来开始，痛苦便伴随一生。小时候吃的，穿的，玩的会让人烦恼(即便是出生在富豪家庭也有各种烦恼吧)，入学后各种考试，选拔。长大后，工作，事业，家庭，爱情。总是有太多太多的烦恼。人只要有欲望，就会有痛苦。\n\n但是也因为有了痛苦，才有了快乐。无论是男的，女的，老的，少的，有家庭的，单身狗的，贫穷的，富裕的，上层阶级的，底层劳动人民的，积极的，消极的，异性恋的，同性恋的。只要是人，只要活着。只要有欲望也就会有快乐。生活不可能一直是痛苦的。\n\n我不知道我给别人带来了多大的影响。也不知道给这个社会带来了多大的效应。只希望能平平凡凡过好这一生。\n\n《教父》中的唐.柯里昂作为纽约最大的黑手党，老了心脏病死亡的时候最后一句话是“生活如此美好”。但愿那一天，每个人都能发出这样的感叹~\n\n","source":"_posts/what-is-life-meaning.md","raw":"---\ntitle: 生活的意义\ndate: 2016-07-16 23:25:18\ntags: \n - 心情\n - 随笔\n - 人生思考\ncategories: 随笔\n---\n{% cq %}我们之所以会去思(zhuang)考(bi)人生或生活,是因为在无聊(alone or lonely?)的生活中总要(xian)找(de)点(dan)乐(teng)子。<p> LouisWang </p> {%endcq%}\n\n人如果闲下来就会想很多。最近加班稍微少点，难得恢复了正常的周末，才发现我生活最大的娱乐活动竟然是加班了。突然不加班反而觉得生活有一点点枯燥和无聊……想到一个问题，我现在的生活意义是什么？我活着的意义什么？忽然正襟危坐，细思极恐……\n\n<!--more-->\n\n之所以会想这个问题，是因为今天看了一部叫做[《阳光小美女》](https://movie.douban.com/subject/1777612/)的电影。也许每个人的关注点都不一样。我从这部影片中看到的是生活痛苦的一面，看到的是作为人痛苦的一面。\n\n从生下来开始，痛苦便伴随一生。小时候吃的，穿的，玩的会让人烦恼(即便是出生在富豪家庭也有各种烦恼吧)，入学后各种考试，选拔。长大后，工作，事业，家庭，爱情。总是有太多太多的烦恼。人只要有欲望，就会有痛苦。\n\n但是也因为有了痛苦，才有了快乐。无论是男的，女的，老的，少的，有家庭的，单身狗的，贫穷的，富裕的，上层阶级的，底层劳动人民的，积极的，消极的，异性恋的，同性恋的。只要是人，只要活着。只要有欲望也就会有快乐。生活不可能一直是痛苦的。\n\n我不知道我给别人带来了多大的影响。也不知道给这个社会带来了多大的效应。只希望能平平凡凡过好这一生。\n\n《教父》中的唐.柯里昂作为纽约最大的黑手党，老了心脏病死亡的时候最后一句话是“生活如此美好”。但愿那一天，每个人都能发出这样的感叹~\n\n","slug":"what-is-life-meaning","published":1,"updated":"2016-11-28T14:27:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwdkjf4k001u1ati3mlb0hb1","content":"<blockquote class=\"blockquote-center\"><p>我们之所以会去思(zhuang)考(bi)人生或生活,是因为在无聊(alone or lonely?)的生活中总要(xian)找(de)点(dan)乐(teng)子。</p><p> LouisWang </p> <p></p>\n</blockquote>\n<p>人如果闲下来就会想很多。最近加班稍微少点，难得恢复了正常的周末，才发现我生活最大的娱乐活动竟然是加班了。突然不加班反而觉得生活有一点点枯燥和无聊……想到一个问题，我现在的生活意义是什么？我活着的意义什么？忽然正襟危坐，细思极恐……</p>\n<a id=\"more\"></a>\n<p>之所以会想这个问题，是因为今天看了一部叫做<a href=\"https://movie.douban.com/subject/1777612/\" target=\"_blank\" rel=\"external\">《阳光小美女》</a>的电影。也许每个人的关注点都不一样。我从这部影片中看到的是生活痛苦的一面，看到的是作为人痛苦的一面。</p>\n<p>从生下来开始，痛苦便伴随一生。小时候吃的，穿的，玩的会让人烦恼(即便是出生在富豪家庭也有各种烦恼吧)，入学后各种考试，选拔。长大后，工作，事业，家庭，爱情。总是有太多太多的烦恼。人只要有欲望，就会有痛苦。</p>\n<p>但是也因为有了痛苦，才有了快乐。无论是男的，女的，老的，少的，有家庭的，单身狗的，贫穷的，富裕的，上层阶级的，底层劳动人民的，积极的，消极的，异性恋的，同性恋的。只要是人，只要活着。只要有欲望也就会有快乐。生活不可能一直是痛苦的。</p>\n<p>我不知道我给别人带来了多大的影响。也不知道给这个社会带来了多大的效应。只希望能平平凡凡过好这一生。</p>\n<p>《教父》中的唐.柯里昂作为纽约最大的黑手党，老了心脏病死亡的时候最后一句话是“生活如此美好”。但愿那一天，每个人都能发出这样的感叹~</p>\n","excerpt":"<blockquote class=\"blockquote-center\"><p>我们之所以会去思(zhuang)考(bi)人生或生活,是因为在无聊(alone or lonely?)的生活中总要(xian)找(de)点(dan)乐(teng)子。<p> LouisWang </p> </p>\n</blockquote>\n<p>人如果闲下来就会想很多。最近加班稍微少点，难得恢复了正常的周末，才发现我生活最大的娱乐活动竟然是加班了。突然不加班反而觉得生活有一点点枯燥和无聊……想到一个问题，我现在的生活意义是什么？我活着的意义什么？忽然正襟危坐，细思极恐……</p>","more":"<p>之所以会想这个问题，是因为今天看了一部叫做<a href=\"https://movie.douban.com/subject/1777612/\">《阳光小美女》</a>的电影。也许每个人的关注点都不一样。我从这部影片中看到的是生活痛苦的一面，看到的是作为人痛苦的一面。</p>\n<p>从生下来开始，痛苦便伴随一生。小时候吃的，穿的，玩的会让人烦恼(即便是出生在富豪家庭也有各种烦恼吧)，入学后各种考试，选拔。长大后，工作，事业，家庭，爱情。总是有太多太多的烦恼。人只要有欲望，就会有痛苦。</p>\n<p>但是也因为有了痛苦，才有了快乐。无论是男的，女的，老的，少的，有家庭的，单身狗的，贫穷的，富裕的，上层阶级的，底层劳动人民的，积极的，消极的，异性恋的，同性恋的。只要是人，只要活着。只要有欲望也就会有快乐。生活不可能一直是痛苦的。</p>\n<p>我不知道我给别人带来了多大的影响。也不知道给这个社会带来了多大的效应。只希望能平平凡凡过好这一生。</p>\n<p>《教父》中的唐.柯里昂作为纽约最大的黑手党，老了心脏病死亡的时候最后一句话是“生活如此美好”。但愿那一天，每个人都能发出这样的感叹~</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ciwdkjf2p00011atilmnwap7b","category_id":"ciwdkjf3100061atiimjiiy5c","_id":"ciwdkjf3f000d1ati6qpyvvn1"},{"post_id":"ciwdkjf3c000a1atihbwcn249","category_id":"ciwdkjf3100061atiimjiiy5c","_id":"ciwdkjf3h000h1atiiyt43754"},{"post_id":"ciwdkjf3d000c1atiwc2w4hu4","category_id":"ciwdkjf3100061atiimjiiy5c","_id":"ciwdkjf3j000j1atieq68hgc9"},{"post_id":"ciwdkjf2w00031atiy8qxo52h","category_id":"ciwdkjf3d000b1atit6j3z2f0","_id":"ciwdkjf3l000n1ati44qoxcwy"},{"post_id":"ciwdkjf3i000i1ati4h4sbo9y","category_id":"ciwdkjf3100061atiimjiiy5c","_id":"ciwdkjf3p000q1atipldjj60m"},{"post_id":"ciwdkjf3200071ati0c3z5pxs","category_id":"ciwdkjf3h000g1atixmbulq7z","_id":"ciwdkjf3s000v1atif94zi15z"},{"post_id":"ciwdkjf3j000k1atioowr259o","category_id":"ciwdkjf3100061atiimjiiy5c","_id":"ciwdkjf3w000y1atiri75h1yg"},{"post_id":"ciwdkjf3n000o1atiz054ykci","category_id":"ciwdkjf3100061atiimjiiy5c","_id":"ciwdkjf3y00101atinsut83hp"},{"post_id":"ciwdkjf3400081aticnaj4r4j","category_id":"ciwdkjf3l000m1atinsvebwhz","_id":"ciwdkjf4000131atilos168ze"},{"post_id":"ciwdkjf3p000r1atippbe242b","category_id":"ciwdkjf3h000g1atixmbulq7z","_id":"ciwdkjf4100151ati3bzia6kd"},{"post_id":"ciwdkjf3s000w1atil1knhyoj","category_id":"ciwdkjf3h000g1atixmbulq7z","_id":"ciwdkjf4300181atilzdm76o1"},{"post_id":"ciwdkjf3f000e1ati43rvxy57","category_id":"ciwdkjf3h000g1atixmbulq7z","_id":"ciwdkjf44001b1atir15arh7r"},{"post_id":"ciwdkjf3x000z1atiollrucjb","category_id":"ciwdkjf3100061atiimjiiy5c","_id":"ciwdkjf46001f1ati0n3vu92f"},{"post_id":"ciwdkjf3z00121ati7zn8qnxi","category_id":"ciwdkjf3d000b1atit6j3z2f0","_id":"ciwdkjf4b001j1ati7ve970c2"},{"post_id":"ciwdkjf4000141ati3nf4rsd0","category_id":"ciwdkjf3100061atiimjiiy5c","_id":"ciwdkjf4d001m1atiudblg6kw"},{"post_id":"ciwdkjf4200161ati83vw3a9t","category_id":"ciwdkjf3h000g1atixmbulq7z","_id":"ciwdkjf4f001o1atix4n16snr"},{"post_id":"ciwdkjf43001a1atipqw8esga","category_id":"ciwdkjf3h000g1atixmbulq7z","_id":"ciwdkjf4i001q1atiuo2sgswy"},{"post_id":"ciwdkjf46001h1atit0dctd1l","category_id":"ciwdkjf3h000g1atixmbulq7z","_id":"ciwdkjf4k001t1ati3hdygtbv"},{"post_id":"ciwdkjf4c001k1atimglnfaaz","category_id":"ciwdkjf3100061atiimjiiy5c","_id":"ciwdkjf4m001v1atiu7m9i5cs"},{"post_id":"ciwdkjf4d001n1ati2er61dvw","category_id":"ciwdkjf3100061atiimjiiy5c","_id":"ciwdkjf4n001x1ati4tatnlkd"},{"post_id":"ciwdkjf45001d1ati3vscj6v5","category_id":"ciwdkjf4b001i1atimq34gyig","_id":"ciwdkjf4n001z1ati6ywjj9zf"},{"post_id":"ciwdkjf4f001p1atinok98ame","category_id":"ciwdkjf3100061atiimjiiy5c","_id":"ciwdkjf4o00221atikz8voqva"},{"post_id":"ciwdkjf4j001s1atig3knapil","category_id":"ciwdkjf3h000g1atixmbulq7z","_id":"ciwdkjf4p00241ati1llfnkgd"},{"post_id":"ciwdkjf4k001u1ati3mlb0hb1","category_id":"ciwdkjf3h000g1atixmbulq7z","_id":"ciwdkjf4p00271atiog5ohdma"}],"PostTag":[{"post_id":"ciwdkjf2p00011atilmnwap7b","tag_id":"ciwdkjf2z00051atiibtbmjeu","_id":"ciwdkjf3o000p1ati67yr82y8"},{"post_id":"ciwdkjf2p00011atilmnwap7b","tag_id":"ciwdkjf3b00091atid5zscevo","_id":"ciwdkjf3r000s1atitr6b6w2y"},{"post_id":"ciwdkjf2p00011atilmnwap7b","tag_id":"ciwdkjf3g000f1atijw8kr9li","_id":"ciwdkjf3w000x1ati9vyagod2"},{"post_id":"ciwdkjf2w00031atiy8qxo52h","tag_id":"ciwdkjf3l000l1ati1r5u9e05","_id":"ciwdkjf4300191ati4w64mx06"},{"post_id":"ciwdkjf2w00031atiy8qxo52h","tag_id":"ciwdkjf3r000t1atis3o6cw6k","_id":"ciwdkjf44001c1atilqn7r8ar"},{"post_id":"ciwdkjf2w00031atiy8qxo52h","tag_id":"ciwdkjf3y00111atixoq0jfrt","_id":"ciwdkjf46001g1ati5yn3j2g2"},{"post_id":"ciwdkjf3200071ati0c3z5pxs","tag_id":"ciwdkjf4300171atic9rmo6sv","_id":"ciwdkjf4n001y1atis5qkobcu"},{"post_id":"ciwdkjf3200071ati0c3z5pxs","tag_id":"ciwdkjf46001e1atilzfa5i0j","_id":"ciwdkjf4o00201atiz873e258"},{"post_id":"ciwdkjf3200071ati0c3z5pxs","tag_id":"ciwdkjf4d001l1atira1gsp1m","_id":"ciwdkjf4o00231ati13p4om4x"},{"post_id":"ciwdkjf3200071ati0c3z5pxs","tag_id":"ciwdkjf4j001r1ati5l1xvmhf","_id":"ciwdkjf4p00251ati6ahkwvnu"},{"post_id":"ciwdkjf3400081aticnaj4r4j","tag_id":"ciwdkjf4n001w1atibiscm70x","_id":"ciwdkjf4p00281ati640auqbo"},{"post_id":"ciwdkjf3400081aticnaj4r4j","tag_id":"ciwdkjf4o00211atiodupc1ry","_id":"ciwdkjf4p00291ati1mhsj6js"},{"post_id":"ciwdkjf3c000a1atihbwcn249","tag_id":"ciwdkjf4p00261atifbr18pul","_id":"ciwdkjf4q002d1ati46l93azr"},{"post_id":"ciwdkjf3c000a1atihbwcn249","tag_id":"ciwdkjf4p002a1atil9l17ne1","_id":"ciwdkjf4q002e1atijbfuz7q8"},{"post_id":"ciwdkjf3c000a1atihbwcn249","tag_id":"ciwdkjf4p002b1atied50hgut","_id":"ciwdkjf4r002g1atir8bfmlmu"},{"post_id":"ciwdkjf3d000c1atiwc2w4hu4","tag_id":"ciwdkjf4p00261atifbr18pul","_id":"ciwdkjf4s002j1atilkeis3cq"},{"post_id":"ciwdkjf3d000c1atiwc2w4hu4","tag_id":"ciwdkjf4p002b1atied50hgut","_id":"ciwdkjf4s002k1atiddu796m3"},{"post_id":"ciwdkjf3d000c1atiwc2w4hu4","tag_id":"ciwdkjf4s002h1ati2xbrhdn7","_id":"ciwdkjf4t002m1atibadxboat"},{"post_id":"ciwdkjf3f000e1ati43rvxy57","tag_id":"ciwdkjf4d001l1atira1gsp1m","_id":"ciwdkjf4t002o1ati2wlbjbz6"},{"post_id":"ciwdkjf3f000e1ati43rvxy57","tag_id":"ciwdkjf4s002l1atiwqg5z4tw","_id":"ciwdkjf4t002p1atihl0n9fmj"},{"post_id":"ciwdkjf3i000i1ati4h4sbo9y","tag_id":"ciwdkjf4p00261atifbr18pul","_id":"ciwdkjf4w002t1ati36h2nksp"},{"post_id":"ciwdkjf3i000i1ati4h4sbo9y","tag_id":"ciwdkjf4t002q1atikvqo6uoz","_id":"ciwdkjf4w002u1ati4f945k87"},{"post_id":"ciwdkjf3i000i1ati4h4sbo9y","tag_id":"ciwdkjf4u002r1ati5utzhoes","_id":"ciwdkjf4w002w1atix40gipk4"},{"post_id":"ciwdkjf3j000k1atioowr259o","tag_id":"ciwdkjf4p00261atifbr18pul","_id":"ciwdkjf4x002z1ati3730dawp"},{"post_id":"ciwdkjf3j000k1atioowr259o","tag_id":"ciwdkjf4p002b1atied50hgut","_id":"ciwdkjf4x00301ati5d5blzjz"},{"post_id":"ciwdkjf3j000k1atioowr259o","tag_id":"ciwdkjf4w002x1atimtxwouce","_id":"ciwdkjf4x00321atir63bbqd8"},{"post_id":"ciwdkjf3n000o1atiz054ykci","tag_id":"ciwdkjf4p002b1atied50hgut","_id":"ciwdkjf4y00351atienli5i1v"},{"post_id":"ciwdkjf3n000o1atiz054ykci","tag_id":"ciwdkjf4x00311atioezkddo5","_id":"ciwdkjf4y00361atiewud121b"},{"post_id":"ciwdkjf3n000o1atiz054ykci","tag_id":"ciwdkjf4y00331atilj4x3jz5","_id":"ciwdkjf4y00381ati5t1udk0d"},{"post_id":"ciwdkjf3p000r1atippbe242b","tag_id":"ciwdkjf4y00341atie9h66cn7","_id":"ciwdkjf4z003b1ati0l06wfeu"},{"post_id":"ciwdkjf3p000r1atippbe242b","tag_id":"ciwdkjf4y00371ati3had2bp0","_id":"ciwdkjf4z003c1ati2srt9xxi"},{"post_id":"ciwdkjf3p000r1atippbe242b","tag_id":"ciwdkjf4z00391atipantiz1g","_id":"ciwdkjf50003e1ati02qyfr1t"},{"post_id":"ciwdkjf3s000w1atil1knhyoj","tag_id":"ciwdkjf4300171atic9rmo6sv","_id":"ciwdkjf50003g1ati4qurg4hg"},{"post_id":"ciwdkjf3s000w1atil1knhyoj","tag_id":"ciwdkjf4d001l1atira1gsp1m","_id":"ciwdkjf51003h1ativ5vmzlmk"},{"post_id":"ciwdkjf3x000z1atiollrucjb","tag_id":"ciwdkjf50003f1ativbcn8vtn","_id":"ciwdkjf53003l1atil6xowle4"},{"post_id":"ciwdkjf3x000z1atiollrucjb","tag_id":"ciwdkjf4p00261atifbr18pul","_id":"ciwdkjf53003m1atiodnaihmn"},{"post_id":"ciwdkjf3x000z1atiollrucjb","tag_id":"ciwdkjf52003j1ati9p4hank0","_id":"ciwdkjf55003o1atitcv01mv6"},{"post_id":"ciwdkjf3z00121ati7zn8qnxi","tag_id":"ciwdkjf3r000t1atis3o6cw6k","_id":"ciwdkjf57003q1atitbzbyfdf"},{"post_id":"ciwdkjf3z00121ati7zn8qnxi","tag_id":"ciwdkjf3y00111atixoq0jfrt","_id":"ciwdkjf57003r1atiwypnkgc0"},{"post_id":"ciwdkjf3z00121ati7zn8qnxi","tag_id":"ciwdkjf4d001l1atira1gsp1m","_id":"ciwdkjf58003t1atiqf01zae4"},{"post_id":"ciwdkjf4000141ati3nf4rsd0","tag_id":"ciwdkjf4p002b1atied50hgut","_id":"ciwdkjf58003v1ati6r5hu97r"},{"post_id":"ciwdkjf4000141ati3nf4rsd0","tag_id":"ciwdkjf57003s1ati6jqytfw6","_id":"ciwdkjf58003w1ati2u7qtxnj"},{"post_id":"ciwdkjf4200161ati83vw3a9t","tag_id":"ciwdkjf4d001l1atira1gsp1m","_id":"ciwdkjf5900401atiqh89yvta"},{"post_id":"ciwdkjf4200161ati83vw3a9t","tag_id":"ciwdkjf59003x1atiskuaqhvo","_id":"ciwdkjf5900411ati7j2605s1"},{"post_id":"ciwdkjf4200161ati83vw3a9t","tag_id":"ciwdkjf59003y1atid1tl2wzh","_id":"ciwdkjf5a00431ati7wbywsit"},{"post_id":"ciwdkjf43001a1atipqw8esga","tag_id":"ciwdkjf59003z1ati7kupd02v","_id":"ciwdkjf5b00461atin5ndhvxm"},{"post_id":"ciwdkjf43001a1atipqw8esga","tag_id":"ciwdkjf5a00421atismtosycw","_id":"ciwdkjf5b00471atil19gnixv"},{"post_id":"ciwdkjf43001a1atipqw8esga","tag_id":"ciwdkjf4d001l1atira1gsp1m","_id":"ciwdkjf5b00491atizady61pd"},{"post_id":"ciwdkjf45001d1ati3vscj6v5","tag_id":"ciwdkjf4p002b1atied50hgut","_id":"ciwdkjf5c004b1atimk778aom"},{"post_id":"ciwdkjf45001d1ati3vscj6v5","tag_id":"ciwdkjf5b00481atiaj9f9k1s","_id":"ciwdkjf5c004c1atif8c6fry1"},{"post_id":"ciwdkjf46001h1atit0dctd1l","tag_id":"ciwdkjf5b004a1ati7la039va","_id":"ciwdkjf5c004f1atit4f0qkb4"},{"post_id":"ciwdkjf46001h1atit0dctd1l","tag_id":"ciwdkjf4d001l1atira1gsp1m","_id":"ciwdkjf5c004g1atiyw9k4c3d"},{"post_id":"ciwdkjf4c001k1atimglnfaaz","tag_id":"ciwdkjf5c004e1ati4ikvt25t","_id":"ciwdkjf5d004j1ati815v8yq5"},{"post_id":"ciwdkjf4c001k1atimglnfaaz","tag_id":"ciwdkjf5c004h1atiuj3t9eiv","_id":"ciwdkjf5f004k1atihw2eizee"},{"post_id":"ciwdkjf4d001n1ati2er61dvw","tag_id":"ciwdkjf5c004e1ati4ikvt25t","_id":"ciwdkjf5g004o1atipnltmrr5"},{"post_id":"ciwdkjf4d001n1ati2er61dvw","tag_id":"ciwdkjf5f004l1atik1i53ld0","_id":"ciwdkjf5g004p1atiub5wx8pa"},{"post_id":"ciwdkjf4d001n1ati2er61dvw","tag_id":"ciwdkjf5f004m1atiimdc8z0u","_id":"ciwdkjf5i004r1atiu9nunjkm"},{"post_id":"ciwdkjf4f001p1atinok98ame","tag_id":"ciwdkjf5c004e1ati4ikvt25t","_id":"ciwdkjf5j004t1atiu141tyia"},{"post_id":"ciwdkjf4f001p1atinok98ame","tag_id":"ciwdkjf5g004q1ati6950hreo","_id":"ciwdkjf5j004u1ati9qqk6lwv"},{"post_id":"ciwdkjf4j001s1atig3knapil","tag_id":"ciwdkjf4d001l1atira1gsp1m","_id":"ciwdkjf5j004w1atiiz9d0dho"},{"post_id":"ciwdkjf4j001s1atig3knapil","tag_id":"ciwdkjf5b004a1ati7la039va","_id":"ciwdkjf5k004x1atiyflf5po9"},{"post_id":"ciwdkjf4k001u1ati3mlb0hb1","tag_id":"ciwdkjf5b004a1ati7la039va","_id":"ciwdkjf5l004z1atip82i89qh"},{"post_id":"ciwdkjf4k001u1ati3mlb0hb1","tag_id":"ciwdkjf4d001l1atira1gsp1m","_id":"ciwdkjf5v00501atiiku4ynbi"},{"post_id":"ciwdkjf4k001u1ati3mlb0hb1","tag_id":"ciwdkjf59003y1atid1tl2wzh","_id":"ciwdkjf5v00511atigwi2g4kl"}],"Tag":[{"name":"模式设计","_id":"ciwdkjf2z00051atiibtbmjeu"},{"name":"高并发","_id":"ciwdkjf3b00091atid5zscevo"},{"name":"分布式","_id":"ciwdkjf3g000f1atijw8kr9li"},{"name":"周末随笔","_id":"ciwdkjf3l000l1ati1r5u9e05"},{"name":"软件开发","_id":"ciwdkjf3r000t1atis3o6cw6k"},{"name":"IT生涯","_id":"ciwdkjf3y00111atixoq0jfrt"},{"name":"生活","_id":"ciwdkjf4300171atic9rmo6sv"},{"name":"孤独","_id":"ciwdkjf46001e1atilzfa5i0j"},{"name":"随笔","_id":"ciwdkjf4d001l1atira1gsp1m"},{"name":"小诗","_id":"ciwdkjf4j001r1ati5l1xvmhf"},{"name":"工具","_id":"ciwdkjf4n001w1atibiscm70x"},{"name":"生产效率","_id":"ciwdkjf4o00211atiodupc1ry"},{"name":"并发编程","_id":"ciwdkjf4p00261atifbr18pul"},{"name":"深入理解","_id":"ciwdkjf4p002a1atil9l17ne1"},{"name":"并发","_id":"ciwdkjf4p002b1atied50hgut"},{"name":"并发专题","_id":"ciwdkjf4s002h1ati2xbrhdn7"},{"name":"博客更新","_id":"ciwdkjf4s002l1atiwqg5z4tw"},{"name":"原子性","_id":"ciwdkjf4t002q1atikvqo6uoz"},{"name":"可见性","_id":"ciwdkjf4u002r1ati5utzhoes"},{"name":"线程","_id":"ciwdkjf4w002x1atimtxwouce"},{"name":"多线程通信","_id":"ciwdkjf4x00311atioezkddo5"},{"name":"线程安全","_id":"ciwdkjf4y00331atilj4x3jz5"},{"name":"JavaIO","_id":"ciwdkjf4y00341atie9h66cn7"},{"name":"Doug Lea","_id":"ciwdkjf4y00371ati3had2bp0"},{"name":"分享","_id":"ciwdkjf4z00391atipantiz1g"},{"name":"JMM","_id":"ciwdkjf50003f1ativbcn8vtn"},{"name":"Java内存模型","_id":"ciwdkjf52003j1ati9p4hank0"},{"name":"J.U.C","_id":"ciwdkjf57003s1ati6jqytfw6"},{"name":"摄影","_id":"ciwdkjf59003x1atiskuaqhvo"},{"name":"人生思考","_id":"ciwdkjf59003y1atid1tl2wzh"},{"name":"学历","_id":"ciwdkjf59003z1ati7kupd02v"},{"name":"杂谈","_id":"ciwdkjf5a00421atismtosycw"},{"name":"数据结构","_id":"ciwdkjf5b00481atiaj9f9k1s"},{"name":"心情","_id":"ciwdkjf5b004a1ati7la039va"},{"name":"JVM","_id":"ciwdkjf5c004e1ati4ikvt25t"},{"name":"类加载机制","_id":"ciwdkjf5c004h1atiuj3t9eiv"},{"name":"架构分析","_id":"ciwdkjf5f004l1atik1i53ld0"},{"name":"内存溢出","_id":"ciwdkjf5f004m1atiimdc8z0u"},{"name":"垃圾回收","_id":"ciwdkjf5g004q1ati6950hreo"}]}}